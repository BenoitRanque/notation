{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap f67c672de9781a90dab6","webpack:///./src/utils.js","webpack:///./src/core/notation.error.js","webpack:///./src/index.js","webpack:///./src/core/notation.js","webpack:///./src/core/notation.glob.js"],"names":["toString","Object","prototype","isArray","Array","utils","isObject","o","call","a","ensureArray","undefined","hasOwn","prop","hasOwnProperty","hasMember","index","deepCopy","object","i","copy","push","k","each","array","callback","thisArg","length","eachRight","pregQuote","str","delimiter","String","replace","RegExp","stringOrArrayOf","value","hasSingleItemOf","arr","itemValue","arguments","NotationError","message","name","constructor","defineProperty","enumerable","writable","Error","captureStackTrace","stack","module","exports","Notation","ERR","SOURCE","DEST","NOTATION","NOTA_OBJ","_source","keys","key","list","keyglob","N","notation","nKey","subKey","isValid","level","eachNote","levelNotation","note","obj","create","merge","expand","result","has","match","Number","lastNote","upToLast","parent","last","inspect","defaultValue","overwrite","isArrayMember","notationsObject","set","notations","inspectRemove","globNotations","original","globs","NotationGlob","normalize","concat","filtered","shift","g","endStar","endArrStar","normalized","globNotation","absGlob","slice","indexOf","isNegated","remove","copyFrom","originalNotation","test","destination","newNotation","moveTo","rename","copyTo","extract","extrude","split","countNotes","reverse","notes","levelNotes","join","Glob","glob","ng","_","regexp","toRegExp","levels","bang","b","levelsA","levelsB","wild","mA","mB","wildA","wildB","negA","negB","nonNegA","nonNegB","globsArray","sort","compare","map","item","trim","globA","indexA","insA","duplicate","hasExactNegative","negCoversNeg","noPosCoversNeg","posCoversPos","noNegCoversPos","globB","indexB","insB","reB","redundant","splice","globsA","globsB","arrA","arrB","reA","keepNegated","aIndex","bIndex"],"mappings":"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","file":"notation.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Notation\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Notation\"] = factory();\n\telse\n\t\troot[\"Notation\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"lib/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f67c672de9781a90dab6","\r\nlet toString = Object.prototype.toString;\r\nlet isArray = Array.isArray;\r\n\r\nconst utils = {\r\n\r\n    isObject(o) {\r\n        return toString.call(o) === '[object Object]';\r\n    },\r\n\r\n    isArray(a) {\r\n        return isArray(a);\r\n    },\r\n\r\n    ensureArray(o) {\r\n        if (utils.isArray(o)) return o;\r\n        return o === null || o === undefined ? [] : [o];\r\n    },\r\n\r\n    hasOwn(o, prop) {\r\n        return o && typeof o.hasOwnProperty === 'function' && o.hasOwnProperty(prop);\r\n    },\r\n\r\n    hasMember(a, index) {\r\n        return a && a[index] !== undefined\r\n    },\r\n\r\n    deepCopy(object) {\r\n        if (utils.isArray(object)) {\r\n            let a, i,\r\n                copy = [];\r\n            for (i of object) {\r\n                copy.push(utils.deepCopy(i))\r\n            }\r\n            return copy;\r\n        } else if (utils.isObject(object)) {\r\n            let k, o,\r\n                copy = {};\r\n            for (k in object) {\r\n                if (utils.hasOwn(object, k)) {\r\n                    o = object[k];\r\n                    copy[k] = utils.deepCopy(o);\r\n                }\r\n            }\r\n            return copy;\r\n        } else {\r\n            return object;\r\n        }\r\n    },\r\n\r\n    // iterates over elements of an array, executing the callback for each\r\n    // element.\r\n    each(array, callback, thisArg) {\r\n        let length = array.length,\r\n            index = -1;\r\n        while (++index < length) {\r\n            if (callback.call(thisArg, array[index], index, array) === false) break;\r\n        }\r\n    },\r\n\r\n    eachRight(array, callback) {\r\n        let index = array.length;\r\n        while (index--) {\r\n            if (callback(array[index], index, array) === false) break;\r\n        }\r\n    },\r\n\r\n    // Borrowed from http://phpjs.org/functions/preg_quote\r\n    pregQuote(str, delimiter) {\r\n        return String(str)\r\n            .replace(new RegExp('[.\\\\\\\\+*?\\\\[\\\\^\\\\]$(){}=!<>|:\\\\' + (delimiter || '') + '-]', 'g'), '\\\\$&');\r\n    },\r\n\r\n    stringOrArrayOf(o, value) {\r\n        return (typeof o === 'string' && o === value)\r\n            || (utils.isArray(o) && o.length === 1 && o[0] === value);\r\n    },\r\n\r\n    hasSingleItemOf(arr, itemValue) {\r\n        return arr.length === 1\r\n            && (arguments.length === 2 ? arr[0] === itemValue : true);\r\n    }\r\n\r\n};\r\n\r\nexport default utils;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js","\r\n// TODO: instanceof return false.\r\n\r\n/**\r\n *  Error class specific to `Notation`.\r\n *  @name Notation.Error\r\n *  @memberof! Notation\r\n *  @class\r\n *\r\n */\r\nclass NotationError extends Error {\r\n\r\n    /**\r\n     *  Initializes a new `Notation.Error` instance.\r\n     *  @constructs Notation.Error\r\n     *  @param {String} message - The error message.\r\n     */\r\n    constructor(message = '') {\r\n        super(message);\r\n        this.name = this.constructor.name;\r\n\r\n        Object.defineProperty(this, 'name', {\r\n            enumerable: false,\r\n            writable: false,\r\n            value: 'NotationError'\r\n        });\r\n\r\n        Object.defineProperty(this, 'message', {\r\n            enumerable: false,\r\n            writable: true,\r\n            value: message\r\n        });\r\n\r\n        if (Error.hasOwnProperty('captureStackTrace')) { // V8\r\n            Error.captureStackTrace(this, this.constructor);\r\n        } else {\r\n            Object.defineProperty(this, 'stack', {\r\n                enumerable: false,\r\n                writable: false,\r\n                value: (new Error(message)).stack\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nexport default NotationError;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/notation.error.js","import Notation from './core/notation';\r\n// export default Notation;\r\n// http://stackoverflow.com/a/33683495/112731\r\nmodule.exports = Notation;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import utils from '../utils';\r\nimport NotationGlob from './notation.glob';\r\nimport NotationError from './notation.error';\r\n\r\nconst ERR = {\r\n    SOURCE: 'Invalid source object.',\r\n    DEST: 'Invalid destination object.',\r\n    NOTATION: 'Invalid notation: ',\r\n    NOTA_OBJ: 'Invalid notations object: '\r\n};\r\n\r\n/**\r\n *  Notation.js for Node and Browser.\r\n *\r\n *  Like in most programming languages, JavaScript makes use of dot-notation to\r\n *  access the value of a member of an object (or class). `Notation` class\r\n *  provides various methods for modifying / processing the contents of the\r\n *  given object; by parsing object notation strings or globs.\r\n *\r\n *  Note that this class will only deal with enumerable properties of the source\r\n *  object; so it should be used to manipulate data objects. It will not deal\r\n *  with preserving the prototype-chain of the given object.\r\n *\r\n *  @author   Onur Yıldırım <onur@cutepilot.com>\r\n *  @license  MIT\r\n */\r\nclass Notation {\r\n\r\n    /**\r\n     *  Initializes a new instance of `Notation`.\r\n     *\r\n     *  @param {Object} [object={}] - The source object to be notated.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     *  const notation = new Notation(obj);\r\n     *  notation.get('car.model'); // \"Charger\"\r\n     */\r\n    constructor(object = {}) {\r\n        // if defined, it should be an object or an array.\r\n        if (!utils.isObject(object) && !utils.isArray(object)) {\r\n            throw new NotationError(ERR.SOURCE);\r\n        }\r\n        this._source = object;\r\n    }\r\n\r\n    // --------------------------------\r\n    // Notation Instance Properties\r\n    // --------------------------------\r\n\r\n    /**\r\n     *  Gets the value of the source object.\r\n     *  @type {Object}\r\n     *\r\n     *  @example\r\n     *  const person = { name: \"Onur\" };\r\n     *  const me = Notation.create(person)\r\n     *      .set(\"age\", 36)\r\n     *      .set(\"car.brand\", \"Ford\")\r\n     *      .set(\"car.model\", \"Mustang\")\r\n     *      .value;\r\n     *  console.log(me); // { name: \"Onur\", age: 36, car: { brand: \"Ford\", model: \"Mustang\" } }\r\n     *  console.log(person === me); // true\r\n     */\r\n    get value() {\r\n        return this._source;\r\n    }\r\n\r\n    // --------------------------------\r\n    // Notation Instance Methods\r\n    // --------------------------------\r\n\r\n    /**\r\n     *  Recursively iterates through each key of the source object and invokes\r\n     *  the given callback function with parameters, on each non-object value.\r\n     *  @alias Notation#eachKey\r\n     *\r\n     *  @param {Function} callback - The callback function to be invoked on\r\n     *  each on each non-object value. To break out of the loop, return `false`\r\n     *  from within the callback.\r\n     *  Callback signature: `callback(notation, key, value, object) { ... }`\r\n     *\r\n     *  @returns {void}\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     *  Notation.create(obj).each(function (notation, key, value, object) {\r\n     *      console.log(notation, value);\r\n     *  });\r\n     *  // \"car.brand\"  \"Dodge\"\r\n     *  // \"car.model\"  \"Charger\"\r\n     *  // \"car.year\"  1970\r\n     */\r\n    each(callback) {\r\n        let isArray = utils.isArray(this._source)\r\n        let o = this._source;\r\n        let keys = isArray ? o : Object.keys(o);\r\n        utils.each(keys, (key, index, list) => {\r\n            \r\n            // this is preserved in arrow functions\r\n            let prop = isArray ? key : o[key],\r\n                keyglob = isArray ? '[' + index + ']' : key,\r\n                N;\r\n            if (utils.isObject(prop) || utils.isArray(prop)) {\r\n                N = new Notation(prop);\r\n                N.each((notation, nKey, value, prop) => {\r\n                    let subKey = utils.isArray(prop)\r\n                    ? keyglob + notation\r\n                    : keyglob + '.' + notation;\r\n                    callback.call(N, subKey, nKey, value, o);\r\n                });\r\n            } else {\r\n                callback.call(this, keyglob, keyglob, prop, o);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     *  Alias for `#each`\r\n     *  @private\r\n     */\r\n    eachKey(callback) {\r\n        return this.each(callback);\r\n    }\r\n\r\n    /**\r\n     *  Iterates through each note of the given notation string by evaluating\r\n     *  it on the source object.\r\n     *\r\n     *  @param {String} notation - The notation string to be iterated through.\r\n     *  @param {Function} callback - The callback function to be invoked on\r\n     *  each iteration. To break out of the loop, return `false` from within\r\n     *  the callback.\r\n     *  Callback signature: `callback(levelValue, note, index, list) { ... }`\r\n     *\r\n     *  @returns {void}\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     *  Notation.create(obj)\r\n     *      .eachValue(\"car.brand\", function (levelValue, note, index, list) {\r\n     *          console.log(note, levelValue); // \"car.brand\" \"Dodge\"\r\n     *      });\r\n     */\r\n    eachValue(notation, callback) {\r\n        if (!Notation.isValid(notation)) {\r\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\r\n        }\r\n        var level = this._source;\r\n        Notation.eachNote(notation, (levelNotation, note, index, list) => {\r\n            level = utils.hasOwn(level, note) ? level[note] : undefined;\r\n            if (callback(level, levelNotation, note, index, list) === false) return false;\r\n\r\n        });\r\n    }\r\n\r\n    /**\r\n     *  Gets the list of notations from the source object (keys).\r\n     *\r\n     *  @returns {Array} - An array of notation strings.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     *  const notations = Notation.create(obj).getNotations();\r\n     *  console.log(notations); // [ \"car.brand\", \"car.model\", \"car.year\" ]\r\n     */\r\n    getNotations() {\r\n        let list = [];\r\n        this.each((notation, key, value, obj) => {\r\n            list.push(notation);\r\n        });\r\n        return list;\r\n    }\r\n\r\n    /**\r\n     *  Flattens the source object to a single-level object with notated keys.\r\n     *\r\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     *  const flat = Notation.create(obj).flatten().value;\r\n     *  console.log(flat);\r\n     *  // { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\r\n     */\r\n    flatten() {\r\n        let o = {};\r\n        this.each((notation, key, value, obj) => {\r\n            o[notation] = value;\r\n        });\r\n        // return o;\r\n        this._source = o;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Aggregates notated keys of a (single-level) object, and nests them under\r\n     *  their corresponding properties. This is the opposite of `Notation#flatten`\r\n     *  method. This might be useful when expanding a flat object fetched from\r\n     *  a database.\r\n     *  @alias Notation#aggregate\r\n     *  @chainable\r\n     *\r\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\r\n     *  const expanded = Notation.create(obj).expand().value;\r\n     *  console.log(expanded); // { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     */\r\n    expand() {\r\n        this._source = Notation.create({}).merge(this._source).value;\r\n        return this;\r\n    }\r\n    /**\r\n     *  Alias for `#expand`\r\n     *  @private\r\n     */\r\n    aggregate() {\r\n        return this.expand();\r\n    }\r\n\r\n    /**\r\n     *  Inspects the given notation on the source object by checking\r\n     *  if the source object actually has the notated property;\r\n     *  and getting its value if exists.\r\n     *\r\n     *  @param {String} notation - The notation string to be inspected.\r\n     *\r\n     *  @returns {InspectResult} - The result object.\r\n     *\r\n     *  @example\r\n     *  Notation.create({ car: { year: 1970 } }).inspect(\"car.year\");\r\n     *  // { has: true, value: 1970 }\r\n     *  Notation.create({ car: { year: 1970 } }).inspect(\"car.color\");\r\n     *  // { has: false, value: undefined }\r\n     *  Notation.create({ car: { color: undefined } }).inspect(\"car.color\");\r\n     *  // { has: true, value: undefined }\r\n     */\r\n    inspect(notation) {\r\n        if (!Notation.isValid(notation)) {\r\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\r\n        }\r\n        let level = this._source,\r\n            result = { has: false, value: undefined };\r\n        Notation.eachNote(notation, (levelNotation, note, index, list) => {\r\n\r\n            let isArray = note.match(/\\[/)\r\n\r\n            if (isArray) note = Number(note.match(/[0-9]/))\r\n\r\n            if (isArray ? utils.hasMember(level, note) : utils.hasOwn(level, note)) {\r\n                level = level[note];\r\n                result = { has: true, value: level };\r\n            } else {\r\n                // level = undefined;\r\n                result = { has: false, value: undefined };\r\n                return false; // break out\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n    /**\r\n     *  Notation inspection result object.\r\n     *  @typedef Notation~InspectResult\r\n     *  @type Object\r\n     *  @property {Boolean} has - Indicates whether the source object has the given\r\n     *  notation as a (leveled) enumerable property. If the property exists but has\r\n     *  a value of `undefined`, this will still return `true`.\r\n     *  @property {*} value - The value of the notated property. If the source object\r\n     *  does not have the notation, the value will be `undefined`.\r\n     */\r\n\r\n    /**\r\n     *  Inspects and removes the given notation from the source object\r\n     *  by checking if the source object actually has the notated property;\r\n     *  and getting its value if exists, before removing the property.\r\n     *\r\n     *  @param {String} notation - The notation string to be inspected.\r\n     *\r\n     *  @returns {InspectResult} - The result object.\r\n     *\r\n     *  @example\r\n     *  const obj = { name: \"John\", car: { year: 1970 } };\r\n     *  Notation.create(obj).inspectRemove(\"car.year\"); // { has: true, value: 1970 }\r\n     *  // obj » { name: \"John\", car: {} }\r\n     *  Notation.create(obj).inspectRemove(\"car.year\", true); // { has: true, value: 1970 }\r\n     *  // obj » { name: \"John\" }\r\n     *  Notation.create({ car: { year: 1970 } }).inspectRemove(\"car.color\");\r\n     *  // { has: false, value: undefined }\r\n     *  Notation.create({ car: { color: undefined } }).inspectRemove(\"car.color\");\r\n     *  // { has: true, value: undefined }\r\n     */\r\n    inspectRemove(notation) {\r\n        if (!Notation.isValid(notation)) {\r\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\r\n        }\r\n        let o, lastNote;\r\n        if (notation.match(/\\.|\\[/) === null) {\r\n            lastNote = notation;\r\n            o = this._source;\r\n        } else {\r\n            let upToLast = Notation.parent(notation);\r\n            lastNote = Notation.last(notation);\r\n            debugger\r\n            o = this.inspect(upToLast).value;\r\n        }\r\n        let result,\r\n            isArray = utils.isArray(o);\r\n\r\n        if (isArray) lastNote = Number(lastNote.match(/[0-9]+/))\r\n\r\n        if (isArray ? utils.hasMember(o, lastNote) : utils.hasOwn(o, lastNote)) {\r\n            result = { has: true, value: o[lastNote] };\r\n            delete o[lastNote];\r\n        } else {\r\n            result = { has: false, value: undefined };\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     *  Checks whether the source object has the given notation\r\n     *  as a (leveled) enumerable property. If the property exists\r\n     *  but has a value of `undefined`, this will still return `true`.\r\n     *\r\n     *  @param {String} notation - The notation string to be checked.\r\n     *\r\n     *  @returns {Boolean}\r\n     *\r\n     *  @example\r\n     *  Notation.create({ car: { year: 1970 } }).has(\"car.year\"); // true\r\n     *  Notation.create({ car: { year: undefined } }).has(\"car.year\"); // true\r\n     *  Notation.create({}).has(\"car.color\"); // false\r\n     */\r\n    has(notation) {\r\n        return this.inspect(notation).has;\r\n    }\r\n\r\n    /**\r\n     *  Checks whether the source object has the given notation\r\n     *  as a (leveled) defined enumerable property. If the property\r\n     *  exists but has a value of `undefined`, this will return `false`.\r\n     *\r\n     *  @param {String} notation - The notation string to be checked.\r\n     *\r\n     *  @returns {Boolean}\r\n     *\r\n     *  @example\r\n     *  Notation.create({ car: { year: 1970 } }).hasDefined(\"car.year\"); // true\r\n     *  Notation.create({ car: { year: undefined } }).hasDefined(\"car.year\"); // false\r\n     *  Notation.create({}).hasDefined(\"car.color\"); // false\r\n     */\r\n    hasDefined(notation) {\r\n        return this.inspect(notation).value !== undefined;\r\n    }\r\n\r\n    /**\r\n     *  Gets the value of the corresponding property at the given\r\n     *  notation.\r\n     *\r\n     *  @param {String} notation - The notation string to be processed.\r\n     *  @param {String} [defaultValue] - The default value to be returned if\r\n     *  the property is not found or enumerable.\r\n     *\r\n     *  @returns {*} - The value of the notated property.\r\n     *\r\n     *  @example\r\n     *  Notation.create({ car: { brand: \"Dodge\" } }).get(\"car.brand\"); // \"Dodge\"\r\n     *  Notation.create({ car: {} }).get(\"car.model\"); // undefined\r\n     *  Notation.create({ car: {} }).get(\"car.model\", \"Challenger\"); // \"Challenger\"\r\n     *  Notation.create({ car: { model: undefined } }).get(\"car.model\", \"Challenger\"); // undefined\r\n     */\r\n    get(notation, defaultValue) {\r\n        let result = this.inspect(notation);\r\n        return !result.has ? defaultValue : result.value;\r\n    }\r\n\r\n    /**\r\n     *  Sets the value of the corresponding property at the given\r\n     *  notation. If the property does not exist, it will be created\r\n     *  and nested at the calculated level. If it exists; its value\r\n     *  will be overwritten by default.\r\n     *  @chainable\r\n     *\r\n     *  @param {String} notation - The notation string to be processed.\r\n     *  @param {*} value - The value to be set for the notated property.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property\r\n     *  if exists.\r\n     *\r\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 } };\r\n     *  Notation.create(obj)\r\n     *      .set(\"car.brand\", \"Ford\")\r\n     *      .set(\"car.model\", \"Mustang\")\r\n     *      .set(\"car.year\", 1965, false)\r\n     *      .set(\"car.color\", \"red\")\r\n     *      .set(\"boat\", \"none\");\r\n     *  console.log(obj);\r\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\r\n     */\r\n    set(notation, value, overwrite = true) {\r\n        if (!Notation.isValid(notation)) {\r\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\r\n        }\r\n        let level = this._source,\r\n            last,\r\n            isArray,\r\n            isArrayMember;\r\n        Notation.eachNote(notation, (levelNotation, note, index, list) => {\r\n            // check next note to see if this level is an array.\r\n            isArray = list[index + 1] && list[index + 1].match(/\\[([0-9]+|\\*)]/) !== null;\r\n            // check note to see if this is an array member.\r\n            isArrayMember = levelNotation.match(/\\[([0-9]+|\\*)]/) !== null;\r\n\r\n            last = index === list.length - 1;\r\n\r\n            if (isArrayMember) {\r\n                // if array note, make it numerical\r\n                note = Number(levelNotation.match(/[0-9]+/))\r\n            }\r\n            // check if the property is at this level\r\n            if ((isArrayMember && utils.hasMember(level, note)) || utils.hasOwn(level, note)) {\r\n                // check if we're at the last level\r\n                if (last) {\r\n                    // if overwrite is set, assign the value.\r\n                    if (overwrite) level[note] = value;\r\n                } else {\r\n                    // if not, just re-reference the current level.\r\n                    level = level[note];\r\n                }\r\n            } else {\r\n                // we don't have this property at this level\r\n                // so; if this is the last level, we set the value\r\n                // if not, we set an empty object for the next level\r\n                level = level[note] = (last ? value : isArray ? [] : {});\r\n            }\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Just like the `.set()` method but instead of a single notation\r\n     *  string, an object of notations and values can be passed.\r\n     *  Sets the value of each corresponding property at the given\r\n     *  notation. If a property does not exist, it will be created\r\n     *  and nested at the calculated level. If it exists; its value\r\n     *  will be overwritten by default.\r\n     *  @chainable\r\n     *\r\n     *  @param {Object} notationsObject - The notations object to be processed.\r\n     *  This can either be a regular object with non-dotted keys\r\n     *  (which will be merged to the first/root level of the source object);\r\n     *  or a flattened object with notated (dotted) keys.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite a property if\r\n     *  exists.\r\n     *\r\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 } };\r\n     *  Notation.create(obj).merge({\r\n     *      \"car.brand\": \"Ford\",\r\n     *      \"car.model\": \"Mustang\",\r\n     *      \"car.year\": 1965,\r\n     *      \"car.color\": \"red\",\r\n     *      \"boat\": \"none\"\r\n     *  });\r\n     *  console.log(obj);\r\n     *  // { car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\r\n     */\r\n    merge(notationsObject, overwrite = true) {\r\n        if (!utils.isObject(notationsObject)) {\r\n            throw new NotationError(ERR.NOTA_OBJ + '`' + notationsObject + '`');\r\n        }\r\n        let value;\r\n        utils.each(Object.keys(notationsObject), (notation, index, obj) => {\r\n            // this is preserved in arrow functions\r\n            value = notationsObject[notation];\r\n            this.set(notation, value, overwrite);\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Removes the properties by the given list of notations from the source\r\n     *  object and returns a new object with the removed properties.\r\n     *  Opposite of `merge()` method.\r\n     *\r\n     *  @param {Array} notations - The notations array to be processed.\r\n     *\r\n     *  @returns {Object} - An object with the removed properties.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 }, notebook: \"Mac\" };\r\n     *  const separated = Notation.create(obj).separate([\"car.brand\", \"boat\" ]);\r\n     *  console.log(separated);\r\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\" } };\r\n     *  console.log(obj);\r\n     *  // { car: { year: 1970 } };\r\n     */\r\n    separate(notations) {\r\n        if (!utils.isArray(notations)) {\r\n            throw new NotationError(ERR.NOTA_OBJ + '`' + notations + '`');\r\n        }\r\n        let o = new Notation({});\r\n        utils.each(notations, (notation, index, obj) => {\r\n            let result = this.inspectRemove(notation);\r\n            o.set(notation, result.value);\r\n        });\r\n        this._source = o._source;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Deep clones the source object while filtering its properties\r\n     *  by the given glob notations. Includes all matched properties\r\n     *  and removes the rest.\r\n     *\r\n     *  @param {Array|String} globNotations - The glob notation(s) to\r\n     *  be processed. The difference between normal notations and\r\n     *  glob-notations is that you can use wildcard stars (*) and\r\n     *  negate the notation by prepending a bang (!). A negated\r\n     *  notation will be excluded. Order of the globs do not matter,\r\n     *  they will be logically sorted. Loose globs will be processed\r\n     *  first and verbose globs or normal notations will be processed\r\n     *  last. e.g. `[ \"car.model\", \"*\", \"!car.*\" ]` will be sorted as\r\n     *  `[ \"*\", \"!car.*\", \"car.model\" ]`.\r\n     *  Passing no parameters or passing an empty string (`\"\"` or `[\"\"]`)\r\n     *  will empty the source object.\r\n     *  @chainable\r\n     *\r\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" } };\r\n     *  const notation = Notation.create(obj);\r\n     *  notation.filter([ \"*\", \"!car.*\", \"car.model\" ]);\r\n     *  console.log(obj);       // { notebook: \"Mac\", car: { model: \"Mustang\" } }\r\n     *  notation.filter(\"*\");   // re-filtering the current contents\r\n     *  console.log(obj);       // { notebook: \"Mac\", car: { model: \"Mustang\" } }\r\n     *  notation.filter();      // or notation.filter(\"\");\r\n     *  console.log(obj);       // {}\r\n     */\r\n    filter(globNotations) {\r\n        let original = this.value;\r\n        let copy = utils.deepCopy(original);\r\n\r\n        // ensure array, normalize and sort the globs in logical order. we also\r\n        // concat the array first (to prevent mutating the original) bec. we'll\r\n        // change it's content via `.shift()`\r\n        let globs = NotationGlob.normalize(globNotations).concat();\r\n        // if globs only consist of \"*\"; set the \"copy\" as source and return.\r\n        if (utils.stringOrArrayOf(globs, '*')) {\r\n            this._source = copy;\r\n            return this;\r\n        }\r\n        // if globs is \"\" or [\"\"] set source to `{}` and return.\r\n        if (arguments.length === 0\r\n                || utils.stringOrArrayOf(globs, '')\r\n                || utils.stringOrArrayOf(globs, '!*')) {\r\n            this._source = {};\r\n            return this;\r\n        }\r\n\r\n        let filtered;\r\n        // if the first item of sorted globs is \"*\" we set the source to the\r\n        // (full) \"copy\" and remove the \"*\" from globs (not to re-process).\r\n        if (globs[0] === '*') {\r\n            filtered = new Notation(copy);\r\n            globs.shift();\r\n        } else {\r\n            // otherwise we set an empty object as the source so that we can\r\n            // add notations/properties to it.\r\n            filtered = new Notation({});\r\n        }\r\n\r\n        let g, endStar, endArrStar, normalized;\r\n        // iterate through globs\r\n        utils.each(globs, (globNotation, index, array) => {\r\n            // console.log('--->', globNotation);\r\n            g = new NotationGlob(globNotation);\r\n            // set flag that indicates whether the glob ends with `.*`\r\n            endStar = g.absGlob.slice(-2) === '.*';\r\n            // set flag that indicates whether the glob ends with `[*]`\r\n            endArrStar = g.absGlob.slice(-3) === '[*]';\r\n            // get the remaining part as the (extra) normalized glob\r\n            // remove either `.*` or `[*]` if present at end of glob string\r\n            normalized = g.absGlob.replace(/(\\.\\*$)|(\\[\\*]$)/, '');\r\n            // normalized = endStar ? g.absGlob.slice(0, -2) : endArrStar ?  g.absGlob.slice(0, -3) : g.absGlob;\r\n            // normalized = endStar ? g.absGlob.replace(/(\\.\\*)+$/, '') : g.absGlob;\r\n            // check if normalized glob has no wildcard stars e.g. \"a.b\" or\r\n            // \"!a.b.c\" etc..\r\n            if (normalized.indexOf('*') < 0) {\r\n                if (g.isNegated) {\r\n                    // directly remove the notation if negated\r\n                    filtered.remove(normalized);\r\n                    // if original glob had `.*` or `[*]` at the end, it means remove\r\n                    // contents (not itself). so we'll set an empty object/array.\r\n                    // meaning `some.prop` (prop) is removed completely but\r\n                    // `some.prop.*` (prop) results in `{}`\r\n                    // and `some.prop[*]` results in `[]`.\r\n                    if (endStar) {\r\n                        filtered.set(normalized, {}, true);\r\n                    } else if (endArrStar) {\r\n                        filtered.set(normalized, [], true);\r\n                    }\r\n                } else {\r\n                    // directly copy the same notation from the original\r\n                    filtered.copyFrom(original, normalized, null, true);\r\n                }\r\n                // move to the next\r\n                return true;\r\n            }\r\n            // if glob has wildcard star(s), we'll iterate through keys of the\r\n            // source object and see if (full) notation of each key matches\r\n            // the current glob.\r\n\r\n            // TODO: Optimize the loop below. Instead of checking each key's\r\n            // notation, get the non-star left part of the glob and iterate\r\n            // that property of the source object.\r\n            this.each((originalNotation, key, value, obj) => {\r\n                // console.log('>>', originalNotation);\r\n\r\n                // iterating each note of original notation. i.e.:\r\n                // note1.note2.note3 is iterated from left to right, as:\r\n                // 'note1', 'note1.note2', 'note1.note2.note3' — in order.\r\n                Notation.eachNote(originalNotation, (levelNotation, note, index, list) => {\r\n                    if (g.test(levelNotation)) {\r\n                        debugger\r\n\r\n                        if (g.isNegated) {\r\n                            // console.log('removing', levelNotation, 'of', originalNotation);\r\n                            filtered.remove(levelNotation);\r\n                            // we break and return early if removed bec. deeper\r\n                            // level props are also removed with this parent.\r\n                            // e.g. when 'note1.note2' of 'note1.note2.note3' is\r\n                            // removed, we no more have 'note3'.\r\n                            return false;\r\n                        }\r\n                        filtered.set(levelNotation, value, true);\r\n                    }\r\n                });\r\n            });\r\n        });\r\n        // finally set the filtered's value as the source of our instance and\r\n        // return.\r\n        this._source = filtered.value;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Removes the property from the source object, at the given notation.\r\n     *  @alias Notation#delete\r\n     *  @chainable\r\n     *\r\n     *  @param {String} notation - The notation to be inspected.\r\n     *\r\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { notebook: \"Mac\", car: { model: \"Mustang\" } };\r\n     *  Notation.create(obj).remove(\"car.model\");\r\n     *  console.log(obj); // { notebook: \"Mac\", car: { } }\r\n     */\r\n    remove(notation) {\r\n        this.inspectRemove(notation);\r\n        return this;\r\n    }\r\n    /**\r\n     *  Alias of `Notation#remove`\r\n     *  @private\r\n     */\r\n    delete(notation) {\r\n        this.remove(notation);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Clones the `Notation` instance to a new one.\r\n     *\r\n     *  @returns {Notation} - A new copy of the instance.\r\n     */\r\n    clone() {\r\n        let o = utils.deepCopy(this.value);\r\n        return new Notation(o);\r\n    }\r\n\r\n    /**\r\n     *  Copies the notated property from the source object and adds it to the\r\n     *  destination — only if the source object actually has that property.\r\n     *  This is different than a property with a value of `undefined`.\r\n     *  @chainable\r\n     *\r\n     *  @param {Object} destination - The destination object that the notated\r\n     *  properties will be copied to.\r\n     *  @param {String} notation - The notation to get the corresponding property\r\n     *  from the source object.\r\n     *  @param {String} [newNotation=null] - The notation to set the source property\r\n     *  on the destination object. In other words, the copied property will be\r\n     *  renamed to this value before set on the destination object. If not set,\r\n     *  `notation` argument will be used.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\r\n     *  the destination object if it exists.\r\n     *\r\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  const models = { dodge: \"Charger\" };\r\n     *  Notation.create(obj).copyTo(models, \"car.model\", \"ford\");\r\n     *  console.log(models);\r\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\r\n     *  // source object (obj) is not modified\r\n     */\r\n    copyTo(destination, notation, newNotation = null, overwrite = true) {\r\n        if (!utils.isObject(destination)) throw new NotationError(ERR.DEST);\r\n        let result = this.inspect(notation);\r\n        if (result.has) {\r\n            new Notation(destination).set(newNotation || notation, result.value, overwrite);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Copies the notated property from the destination object and adds it to the\r\n     *  source object — only if the destination object actually has that property.\r\n     *  This is different than a property with a value of `undefined`.\r\n     *  @chainable\r\n     *\r\n     *  @param {Object} destination - The destination object that the notated\r\n     *  properties will be copied from.\r\n     *  @param {String} notation - The notation to get the corresponding property\r\n     *  from the destination object.\r\n     *  @param {String} [newNotation=null] - The notation to set the destination\r\n     *  property on the source object. In other words, the copied property\r\n     *  will be renamed to this value before set on the source object.\r\n     *  If not set, `notation` argument will be used.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property\r\n     *  on the source object if it exists.\r\n     *\r\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  const models = { dodge: \"Charger\" };\r\n     *  Notation.create(obj).copyFrom(models, \"dodge\", \"car.model\", true);\r\n     *  console.log(obj);\r\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\r\n     *  // models object is not modified\r\n     */\r\n    copyFrom(destination, notation, newNotation = null, overwrite = true) {\r\n        if (!utils.isObject(destination)) throw new NotationError(ERR.DEST);\r\n        let result = new Notation(destination).inspect(notation);\r\n        if (result.has) {\r\n            this.set(newNotation || notation, result.value, overwrite);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Removes the notated property from the source object and adds it to the\r\n     *  destination — only if the source object actually has that property.\r\n     *  This is different than a property with a value of `undefined`.\r\n     *  @chainable\r\n     *\r\n     *  @param {Object} destination - The destination object that the notated\r\n     *  properties will be moved to.\r\n     *  @param {String} notation - The notation to get the corresponding\r\n     *  property from the source object.\r\n     *  @param {String} [newNotation=null] - The notation to set the source property\r\n     *  on the destination object. In other words, the moved property will be\r\n     *  renamed to this value before set on the destination object. If not set,\r\n     *  `notation` argument will be used.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\r\n     *  the destination object if it exists.\r\n     *\r\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  const models = { dodge: \"Charger\" };\r\n     *  Notation.create(obj).moveTo(models, \"car.model\", \"ford\");\r\n     *  console.log(obj);\r\n     *  // { car: { brand: \"Ford\" } }\r\n     *  console.log(models);\r\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\r\n     */\r\n    moveTo(destination, notation, newNotation = null, overwrite = true) {\r\n        if (!utils.isObject(destination)) throw new NotationError(ERR.DEST);\r\n        let result = this.inspectRemove(notation);\r\n        if (result.has) {\r\n            new Notation(destination).set(newNotation || notation, result.value, overwrite);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Removes the notated property from the destination object and adds it to the\r\n     *  source object — only if the destination object actually has that property.\r\n     *  This is different than a property with a value of `undefined`.\r\n     *  @chainable\r\n     *\r\n     *  @param {Object} destination - The destination object that the notated\r\n     *  properties will be moved from.\r\n     *  @param {String} notation - The notation to get the corresponding property\r\n     *  from the destination object.\r\n     *  @param {String} [newNotation=null] - The notation to set the destination\r\n     *  property on the source object. In other words, the moved property\r\n     *  will be renamed to this value before set on the source object.\r\n     *  If not set, `notation` argument will be used.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\r\n     *  the source object if it exists.\r\n     *\r\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  const models = { dodge: \"Charger\" };\r\n     *  Notation.create(obj).moveFrom(models, \"dodge\", \"car.model\", true);\r\n     *  console.log(obj);\r\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\r\n     *  console.log(models);\r\n     *  // {}\r\n     */\r\n    moveFrom(destination, notation, newNotation = null, overwrite = true) {\r\n        if (!utils.isObject(destination)) throw new NotationError(ERR.DEST);\r\n        let result = new Notation(destination).inspectRemove(notation);\r\n        if (result.has) {\r\n            this.set(newNotation || notation, result.value, overwrite);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Renames the notated property of the source object by the new notation.\r\n     *  @alias Notation#renote\r\n     *  @chainable\r\n     *\r\n     *  @param {String} notation - The notation to get the corresponding\r\n     *  property (value) from the source object.\r\n     *  @param {String} newNotation - The new notation for the targeted\r\n     *  property value. If not set, the source object will not be modified.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property at\r\n     *  the new notation, if it exists.\r\n     *\r\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  Notation.create(obj)\r\n     *      .rename(\"car.brand\", \"carBrand\")\r\n     *      .rename(\"car.model\", \"carModel\");\r\n     *  console.log(obj);\r\n     *  // { carBrand: \"Ford\", carModel: \"Mustang\" }\r\n     */\r\n    rename(notation, newNotation, overwrite) {\r\n        if (!newNotation) return this;\r\n        return this.moveTo(this._source, notation, newNotation, overwrite);\r\n    }\r\n    /**\r\n     *  Alias for `#rename`\r\n     *  @private\r\n     */\r\n    renote(notation, newNotation, overwrite) {\r\n        return this.rename(notation, newNotation, overwrite);\r\n    }\r\n\r\n    /**\r\n     *  Extracts the property at the given notation to a new object by copying\r\n     *  it from the source object. This is equivalent to `.copyTo({}, notation, newNotation)`.\r\n     *  @alias Notation#copyToNew\r\n     *\r\n     *  @param {String} notation - The notation to get the corresponding\r\n     *  property (value) from the source object.\r\n     *  @param {String} newNotation - The new notation to be set on the new\r\n     *  object for the targeted property value. If not set, `notation` argument\r\n     *  will be used.\r\n     *\r\n     *  @returns {Object} - Returns a new object with the notated property.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  const extracted = Notation.create(obj).extract(\"car.brand\", \"carBrand\");\r\n     *  console.log(extracted);\r\n     *  // { carBrand: \"Ford\" }\r\n     *  // obj is not modified\r\n     */\r\n    extract(notation, newNotation) {\r\n        let o = {};\r\n        this.copyTo(o, notation, newNotation);\r\n        return o;\r\n    }\r\n    /**\r\n     *  Alias for `#extract`\r\n     *  @private\r\n     */\r\n    copyToNew(notation, newNotation) {\r\n        return this.extract(notation, newNotation);\r\n    }\r\n\r\n    /**\r\n     *  Extrudes the property at the given notation to a new object by moving\r\n     *  it from the source object. This is equivalent to `.moveTo({}, notation, newNotation)`.\r\n     *  @alias Notation#moveToNew\r\n     *\r\n     *  @param {String} notation - The notation to get the corresponding\r\n     *  property (value) from the source object.\r\n     *  @param {String} newNotation - The new notation to be set on the new\r\n     *  object for the targeted property value. If not set, `notation` argument\r\n     *  will be used.\r\n     *\r\n     *  @returns {Object} - Returns a new object with the notated property.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  const extruded = Notation.create(obj).extrude(\"car.brand\", \"carBrand\");\r\n     *  console.log(obj);\r\n     *  // { car: { model: \"Mustang\" } }\r\n     *  console.log(extruded);\r\n     *  // { carBrand: \"Ford\" }\r\n     */\r\n    extrude(notation, newNotation) {\r\n        let o = {};\r\n        this.moveTo(o, notation, newNotation);\r\n        return o;\r\n    }\r\n    /**\r\n     *  Alias for `#extrude`\r\n     *  @private\r\n     */\r\n    moveToNew(notation, newNotation) {\r\n        return this.extrude(notation, newNotation);\r\n    }\r\n\r\n    // --------------------------------\r\n    // Notation Static Methods\r\n    // --------------------------------\r\n\r\n    /**\r\n     *  Basically constructs a new `Notation` instance with the given object.\r\n     *  @chainable\r\n     *\r\n     *  @param {Object} [object={}] - The object to be notated.\r\n     *\r\n     *  @returns {Notation} - The created instance.\r\n     *\r\n     *  @example\r\n     *  const notation = Notation.create(obj);\r\n     *  // equivalent to:\r\n     *  const notation = new Notation(obj);\r\n     */\r\n    static create(object = {}) {\r\n        return new Notation(object);\r\n    }\r\n\r\n    /**\r\n     *  Checks whether the given notation string is valid. Note that the star\r\n     *  (`*`) (which is a valid character, even if irregular) is NOT treated as\r\n     *  wildcard here. This checks for normal dot-notation, not a glob-notation.\r\n     *  For glob notation validation, use `Notation.Glob.isValid()` method. Same\r\n     *  goes for the negation character/prefix (`!`).\r\n     *\r\n     *  Note that, even though `obj['some.name']` is possible in JS, dot (`.`) is\r\n     *  always treated as a level (property) separator in Notation strings.\r\n     *\r\n     *  @param {String} notation - The notation string to be checked.\r\n     *\r\n     *  @returns {Boolean}\r\n     *\r\n     *  @example\r\n     *  Notation.isValid('prop1.prop2.prop3'); // true\r\n     *  Notation.isValid('prop1'); // true\r\n     *  Notation.isValid('prop.*'); // true (but star is not treated as wildcard)\r\n     *  Notation.isValid('@1'); // true (bec. obj['@1'] is possible in JS.)\r\n     *  Notation.isValid(null); // false\r\n     */\r\n    static isValid(notation) {\r\n        return (typeof notation === 'string') &&\r\n            (/^[^\\s.!]+((\\.[^\\s.!]+)|(\\[([0-9]+|\\*)\\]))*$/).test(notation);\r\n    }\r\n\r\n    /**\r\n     *  Counts the number of notes/levels in the given notation.\r\n     *  @alias Notation.countLevels\r\n     *\r\n     *  @param {*} notation - The notation string to be processed.\r\n     *\r\n     *  @returns {Number}\r\n     */\r\n    static countNotes(notation) {\r\n        if (!Notation.isValid(notation)) {\r\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\r\n        }\r\n        return notation.split(/\\.|(?=\\[)/).length;\r\n    }\r\n    /**\r\n     *  Alias of `Notation.countNotes`.\r\n     *  @private\r\n     */\r\n    static countLevels(notation) {\r\n        return Notation.countNotes(notation);\r\n    }\r\n\r\n    /**\r\n     *  Gets the first (root) note of the notation string.\r\n     *\r\n     *  @param {String} notation - The notation string to be processed.\r\n     *\r\n     *  @returns {String}\r\n     *\r\n     *  @example\r\n     *  Notation.first('first.prop2.last'); // \"first\"\r\n     */\r\n    static first(notation) {\r\n        if (!Notation.isValid(notation)) {\r\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\r\n        }\r\n        // return notation.replace(/.*\\.([^\\.]*$)/, '$1');\r\n        return notation.split(/\\.|(?=\\[)/)[0];\r\n    }\r\n\r\n    /**\r\n     *  Gets the last note of the notation string.\r\n     *\r\n     *  @param {String} notation - The notation string to be processed.\r\n     *\r\n     *  @returns {String}\r\n     *\r\n     *  @example\r\n     *  Notation.last('first.prop2.last'); // \"last\"\r\n     */\r\n    static last(notation) {\r\n        if (!Notation.isValid(notation)) {\r\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\r\n        }\r\n        // return notation.replace(/.*\\.([^\\.]*$)/, '$1');\r\n        return notation.split(/\\.|(?=\\[)/).reverse()[0];\r\n    }\r\n\r\n    /**\r\n     *  Gets the parent notation (up to but excluding the last note)\r\n     *  from the notation string.\r\n     *\r\n     *  @param {String} notation - The notation string to be processed.\r\n     *\r\n     *  @returns {String}\r\n     *\r\n     *  @example\r\n     *  Notation.parent('first.prop2.last'); // \"first.prop2\"\r\n     *  Notation.parent('single'); // null\r\n     */\r\n    static parent(notation) {\r\n        if (!Notation.isValid(notation)) {\r\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\r\n        }\r\n        return notation.match(/\\.|\\[/) !== null\r\n            ? notation.replace(/(\\.|.\\[)[^.[]*$/, '')\r\n            : null;\r\n    }\r\n\r\n    /**\r\n     *  Iterates through each note/level of the given notation string.\r\n     *  @alias Notation.eachLevel\r\n     *\r\n     *  @param {String} notation - The notation string to be iterated through.\r\n     *  @param {Function} callback - The callback function to be invoked on\r\n     *  each iteration. To break out of the loop, return `false` from within the\r\n     *  callback.\r\n     *  Callback signature: `callback(levelNotation, note, index, list) { ... }`\r\n     *\r\n     *  @returns {void}\r\n     *\r\n     *  @example\r\n     *  const notation = 'first.prop2.last';\r\n     *  Notation.eachNote(notation, function (levelNotation, note, index, list) {\r\n     *      console.log(index, note, levelNotation);\r\n     *  });\r\n     *  // 0  \"first\"             \"first\"\r\n     *  // 1  \"first.prop2\"       \"prop2\"\r\n     *  // 2  \"first.prop2.last\"  \"last\"\r\n     */\r\n    static eachNote(notation, callback) {\r\n        if (!Notation.isValid(notation)) {\r\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\r\n        }\r\n        let notes = notation.split(/\\.|(?=\\[)/),\r\n            levelNotes = [],\r\n            levelNotation;\r\n        utils.each(notes, (note, index, list) => {\r\n            levelNotes.push(note);\r\n\r\n            levelNotation = levelNotes.join('.').replace(/\\.\\[/, '[');\r\n\r\n            if (callback(levelNotation, note, index, notes) === false) return false;\r\n        }, Notation);\r\n    }\r\n    /**\r\n     *  Alias of `Notation.eachNote`.\r\n     *  @private\r\n     */\r\n    static eachLevel(notation, callback) {\r\n        Notation.eachNote(notation, callback);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n *  Error class specific to `Notation`.\r\n *  @private\r\n *\r\n *  @class\r\n *  @see `{@link #Notation.Error}`\r\n */\r\nNotation.Error = NotationError;\r\n\r\n/**\r\n *  Utility for validating, comparing and sorting dot-notation globs.\r\n *  This is internally used by `Notation` class.\r\n *  @private\r\n *\r\n *  @class\r\n *  @see `{@link #Notation.Glob}`\r\n */\r\nNotation.Glob = NotationGlob;\r\n\r\n// --------------------------------\r\n// EXPORT\r\n// --------------------------------\r\n\r\nexport default Notation;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/notation.js","import utils from '../utils';\r\nimport NotationError from './notation.error';\r\n\r\n// http://www.linfo.org/wildcard.html\r\n// http://en.wikipedia.org/wiki/Glob_%28programming%29\r\n// http://en.wikipedia.org/wiki/Wildcard_character#Computing\r\n\r\n/**\r\n *  `Notation.Glob` is a utility for validating, comparing and sorting\r\n *  dot-notation globs.\r\n *\r\n *  You can use {@link http://www.linfo.org/wildcard.html|wildcard} stars `*`\r\n *  and negate the notation by prepending a bang `!`. A star will include all\r\n *  the properties at that level and a negated notation will be excluded.\r\n *  @name Notation.Glob\r\n *  @memberof! Notation\r\n *  @class\r\n *\r\n *  @example\r\n *  // for the following object;\r\n *  { name: 'John', billing: { account: { id: 1, active: true } } };\r\n *\r\n *  'billing.account.*'  // represents value `{ id: 1, active: true }`\r\n *  'billing.account.id' // represents value `1`\r\n *  '!billing.account.*' // represents value `{ name: 'John' }`\r\n *  'name' // represents `'John'`\r\n *  '*' // represents the whole object\r\n *\r\n *  @example\r\n *  var glob = new Notation.Glob('billing.account.*');\r\n *  glob.test('billing.account.id'); // true\r\n */\r\nclass NotationGlob {\r\n\r\n    /**\r\n     *  Constructs a `Notation.Glob` object with the given glob string.\r\n     *  @constructs Notation.Glob\r\n     *\r\n     *  @param {String} glob - The glob string.\r\n     */\r\n    constructor(glob) {\r\n        if (!NotationGlob.isValid(glob)) {\r\n            throw new NotationError('Invalid notation glob: \"' + glob + '\"');\r\n        }\r\n\r\n        let ng = NotationGlob.inspect(glob);\r\n        this._ = {\r\n            glob,\r\n            absGlob: ng.absGlob,\r\n            isNegated: ng.isNegated,\r\n            regexp: NotationGlob.toRegExp(ng.absGlob),\r\n            levels: ng.absGlob.split(/\\.|(?=\\[)/)\r\n        };\r\n    }\r\n\r\n    // --------------------------------\r\n    // NotationGlob Instance Properties\r\n    // --------------------------------\r\n\r\n    /**\r\n     *  Gets the original glob notation string.\r\n     *  @name Notation.Glob#glob\r\n     *  @type {String}\r\n     */\r\n    get glob() {\r\n        return this._.glob;\r\n    }\r\n\r\n    /**\r\n     *  Gets the absolute glob notation (without the preceeding bang `!`).\r\n     *  @name Notation.Glob#absGlob\r\n     *  @type {String}\r\n     */\r\n    get absGlob() {\r\n        return this._.absGlob;\r\n    }\r\n\r\n    /**\r\n     *  Specifies whether this glob is negated with a `!` prefix.\r\n     *  @name Notation.Glob#isNegated\r\n     *  @type {Boolean}\r\n     */\r\n    get isNegated() {\r\n        return this._.isNegated;\r\n    }\r\n\r\n    /**\r\n     *  Represents this glob in regular expressions.\r\n     *  Note that the negation (`!`) is ignored, if any.\r\n     *  @name Notation.Glob#regexp\r\n     *  @type {RegExp}\r\n     */\r\n    get regexp() {\r\n        return this._.regexp;\r\n    }\r\n\r\n    /**\r\n     *  List of notes/levels of this glob notation.\r\n     *  @name Notation.Glob#notes\r\n     *  @alias Notation.Glob#levels\r\n     *  @type {Array}\r\n     */\r\n    get notes() {\r\n        return this._.levels;\r\n    }\r\n    /**\r\n     *  Alias of `Notation.Glob#notes`.\r\n     *  @private\r\n     */\r\n    get levels() {\r\n        return this._.levels;\r\n    }\r\n\r\n    // --------------------------------\r\n    // NotationGlob Instance Methods\r\n    // --------------------------------\r\n\r\n    /**\r\n     *  Checks whether the given notation value matches the source notation glob.\r\n     *  @name Notation.Glob#test\r\n     *  @function\r\n     *\r\n     *  @param {String} notation - The notation string to be tested.\r\n     *\r\n     *  @returns {Boolean}\r\n     *\r\n     *  @example\r\n     *  const glob = new Notation.Glob('!prop.*.name');\r\n     *  glob.test(\"prop.account.name\"); // true\r\n     */\r\n    test(notation) {\r\n        // we allow '*' to match everything. We check for this here\r\n        // instead of the regexp bec. we care for dots (.) within the glob.\r\n        return this.absGlob === '*'\r\n            || (this.absGlob !== '' && notation !== '' && this.regexp.test(notation));\r\n    }\r\n\r\n    // --------------------------------\r\n    // NotationGlob Static Members\r\n    // --------------------------------\r\n\r\n    /**\r\n     *  Basically constructs a new `NotationGlob` instance\r\n     *  with the given glob string.\r\n     *  @name Notation.Glob.create\r\n     *  @function\r\n     *\r\n     *  @param {String} glob - The source notation glob.\r\n     *\r\n     *  @returns {NotationGlob}\r\n     *\r\n     *  @example\r\n     *  const glob = Notation.Glob.create(strGlob);\r\n     *  // equivalent to:\r\n     *  const glob = new Notation.Glob(strGlob);\r\n     */\r\n    static create(glob) {\r\n        return new NotationGlob(glob);\r\n    }\r\n\r\n    /**\r\n     *  Gets a regular expressions instance from the given glob notation.\r\n     *  Note that the bang `!` prefix will be ignored if the given glob is negated.\r\n     *  @name Notation.Glob.toRegExp\r\n     *  @function\r\n     *\r\n     *  @param {String} glob - Glob notation to be converted.\r\n     *\r\n     *  @returns {RegExp}\r\n     */\r\n    static toRegExp(glob) {\r\n        if (glob.indexOf('!') === 0) glob = glob.slice(1);\r\n        // Modified from http://stackoverflow.com/a/13818704/112731\r\n        glob = utils.pregQuote(glob)\r\n            .replace(/\\\\\\*/g, '[^\\\\s\\\\.[\\\\]]+')\r\n            .replace(/\\\\\\?/g, '.');\r\n        return new RegExp('^' + glob + '((\\\\.|\\\\[).+|$)');\r\n        // it should either end ($) or continue with a dot or a square bracket. So for example,\r\n        // `company.*` will produce `/^company\\.[^\\s\\.]*/` which will match both\r\n        // `company.name` and `company.address.street` but will not match\r\n        // `some.company.name`. Also `!password` will not match `!password_reset`.\r\n        //\r\n    }\r\n\r\n    /**\r\n     *  @private\r\n     */\r\n    static inspect(glob) {\r\n        let bang = glob.slice(0, 1) === '!';\r\n        glob = bang ? glob.slice(1) : glob;\r\n        return {\r\n            absGlob: glob,\r\n            isNegated: bang\r\n        };\r\n    }\r\n\r\n    // Created test at: https://regex101.com/r/tJ7yI9/4\r\n    /**\r\n     *  Validates the given notation glob.\r\n     *  @name Notation.Glob.isValid\r\n     *  @function\r\n     *\r\n     *  @param {String} glob - Notation glob to be validated.\r\n     *  @returns {Boolean}\r\n     */\r\n    static isValid(glob) {\r\n        return (typeof glob === 'string')\r\n            && (/^(!?([^\\s.!*\\[\\]]+|\\*)((\\.([^\\s.!*\\[\\]]+|\\*))|(\\[([0-9]+|\\*)\\]))*)$/).test(glob);\r\n    }\r\n\r\n    /**\r\n     *  Compares two given notation globs and returns an integer value as a\r\n     *  result. This is generally used to sort glob arrays. Loose globs (with\r\n     *  stars especially closer to beginning of the glob string) and globs\r\n     *  representing the parent/root of the compared property glob come first.\r\n     *  Verbose/detailed/exact globs come last. (`* < *abc < abc`).\r\n     *\r\n     *  For instance; `store.address` comes before `store.address.street`. So\r\n     *  this works both for `*, store.address.street, !store.address` and `*,\r\n     *  store.address, !store.address.street`. For cases such as `prop.id` vs\r\n     *  `!prop.id` which represent the same property; the negated glob wins\r\n     *  (comes last).\r\n     *  @name Notation.Glob.compare\r\n     *  @function\r\n     *\r\n     *  @param {String} a - First notation glob to be compared.\r\n     *  @param {String} b - Second notation glob to be compared.\r\n     *\r\n     *  @returns {Number} - Returns `-1` if `a` comes first, `1` if `b` comes\r\n     *  first and `0` if equivalent priority.\r\n     *\r\n     *  @example\r\n     *  let result = Notation.Glob.compare('prop.*.name', 'prop.*');\r\n     *  console.log(result); // 1\r\n     */\r\n    static compare(a, b) {\r\n        // trivial case, both are exactly the same!\r\n        if (a === b) return 0;\r\n        let levelsA = a.split(/\\.|(?=\\[)/),\r\n            levelsB = b.split(/\\.|(?=\\[)/);\r\n        // Check depth (number of levels)\r\n        if (levelsA.length === levelsB.length) {\r\n            // count wildcards (assuming more wildcards comes first)\r\n            let wild = /(?:^|\\.)\\*(?:$|\\.)|\\[\\*\\]/g,\r\n                mA = a.match(wild),\r\n                mB = b.match(wild),\r\n                wildA = mA ? mA.length : 0,\r\n                wildB = mB ? mB.length : 0;\r\n            if (wildA === wildB) {\r\n                // check for negation\r\n                let negA = a.indexOf('!') === 0,\r\n                    negB = b.indexOf('!') === 0;\r\n                if (negA === negB) {\r\n                    // both are negated or neither are, just return alphabetical\r\n                    return a < b ? -1 : 1;\r\n                }\r\n                // compare without the negatation\r\n                let nonNegA = negA ? a.slice(1) : a,\r\n                    nonNegB = negB ? b.slice(1) : b;\r\n                if (nonNegA === nonNegB) {\r\n                    return negA ? 1 : -1;\r\n                }\r\n                return nonNegA < nonNegB ? -1 : 1;\r\n            }\r\n            return wildA > wildB ? -1 : 1;\r\n        }\r\n\r\n        return levelsA.length < levelsB.length ? -1 : 1;\r\n    }\r\n\r\n    /**\r\n     *  Sorts the notation globs in the given array by their priorities. Loose\r\n     *  globs (with stars especially closer to beginning of the glob string);\r\n     *  globs representing the parent/root of the compared property glob come\r\n     *  first. Verbose/detailed/exact globs come last. (`* < *abc < abc`).\r\n     *\r\n     *  For instance; `store.address` comes before `store.address.street`. For\r\n     *  cases such as `prop.id` vs `!prop.id` which represent the same property;\r\n     *  the negated glob wins (comes last).\r\n     *  @name Notation.Glob.sort\r\n     *  @function\r\n     *\r\n     *  @param {Array} globsArray - The notation globs array to be sorted. The\r\n     *  passed array reference is modified.\r\n     *\r\n     *  @returns {Array}\r\n     *\r\n     *  @example\r\n     *  const globs = ['!prop.*.name', 'prop.*', 'prop.id'];\r\n     *  const sorted = Notation.Glob.sort(globs);\r\n     *  console.log(sorted);\r\n     *  // ['prop.*', 'prop.id', '!prop.*.name'];\r\n     */\r\n    static sort(globsArray) {\r\n        return globsArray.sort(NotationGlob.compare);\r\n        // return _mergeSortArray(globsArray, NotationGlob.compare);\r\n    }\r\n\r\n    /**\r\n     *  Normalizes the given notation globs array by removing duplicate or\r\n     *  redundant items and returns a priority-sorted globs array.\r\n     *\r\n     *  <ul>\r\n     *  <li>If any exact duplicates found, all except first is removed.</li>\r\n     *  <li>If both normal and negated versions of a glob are found, negated wins.\r\n     *  <br />example: `['id', '!id']` normalizes to `['!id']`.</li>\r\n     *  <li>If a glob is covered by another, it's removed.\r\n     *  <br />example: `['car.*', 'car.model']` normalizes to `['car.*']`.</li>\r\n     *  <li>If a glob is covered by another negated glob, it's kept.\r\n     *  <br />example: `['*', '!car.*', 'car.model']` normalizes as is.</li>\r\n     *  <li>If a negated glob is covered by another glob, it's also kept.\r\n     *  <br />example: `['car.*', '!car.model']` normalizes as is.</li>\r\n     *  </ul>\r\n     *  @name Notation.Glob.normalize\r\n     *  @function\r\n     *\r\n     *  @param {Array} globsArray - Notation globs array to be normalized.\r\n     *\r\n     *  @returns {Array}\r\n     *\r\n     *  @example\r\n     *  const globs = ['*', '!id', 'name', 'car.model', '!car.*', 'id', 'name', 'age'];\r\n     *  const normalized = Notation.Glob.normalize(globs);\r\n     *  console.log(normalized);\r\n     *  // ['*', '!car.*', '!id', 'car.model']\r\n     */\r\n    static normalize(globsArray) {\r\n        debugger\r\n        globsArray = utils.ensureArray(globsArray).map(item => item.trim());\r\n        globsArray = NotationGlob.sort(globsArray);\r\n\r\n        utils.eachRight(globsArray, (globA, indexA) => {\r\n\r\n            // example #1:\r\n            // ['*', '!id', 'name', 'car.model', '!car.*', 'id', 'name']\r\n            // => ['*', '!id', '!car.*', 'car.model']\r\n\r\n            // example #2:\r\n            // ['!id', 'name', 'car.model', '!car.*', 'id', '!email']\r\n            // => ['!car.*', 'car.model', 'name']\r\n\r\n            let insA = NotationGlob.inspect(globA);\r\n            // console.log(' • ', globA, '=>', globsArray);\r\n\r\n            let duplicate = false;\r\n            let hasExactNegative = false;\r\n            let negCoversNeg = false;\r\n            let noPosCoversNeg = true;\r\n            let posCoversPos = false;\r\n            let noNegCoversPos = true;\r\n\r\n            // inspect/compare the current glob with the rest of the array\r\n            utils.eachRight(globsArray, (globB, indexB) => {\r\n                // don't inspect glob with itself\r\n                if (indexB === indexA) return; // no break, move to next\r\n\r\n                let insB = NotationGlob.inspect(globB);\r\n                let reB = NotationGlob.toRegExp(insB.absGlob);\r\n\r\n                // console.log(globA, 'vs', globB);\r\n\r\n                // (A) remove if duplicate\r\n                if (globA === globB) {\r\n                    duplicate = true;\r\n                    return false; // break\r\n                }\r\n\r\n                // (B) remove if positive has an exact negative\r\n                // e.g. ['prop', '!prop'] => ['!prop']\r\n                // negated wins when normalized\r\n                if (insB.isNegated && globA === insB.absGlob) {\r\n                    hasExactNegative = true;\r\n                    return false; // break\r\n                }\r\n\r\n                // (C) remove negated if:\r\n                //    1) any negative covers it\r\n                //       ['!a.b', '!a.*']  => '!a.b' is removed\r\n                //    2) no positive covers it\r\n                //       ['!a.b', 'a.c']   => '!a.b' is removed\r\n\r\n                // (D) remove positive if:\r\n                //    1) any positive covers it AND no negative covers it\r\n                //       ['*', 'a.b']            => 'a.b' is removed\r\n                //       ['*', 'a.b', '!a.*']    => 'a.b' is kept\r\n\r\n                if (insA.isNegated) {\r\n                    if (insB.isNegated && reB.test(insA.absGlob)) {\r\n                        negCoversNeg = true;\r\n                        return false; // break\r\n                    } else if (noPosCoversNeg && reB.test(insA.absGlob)) {\r\n                        noPosCoversNeg = false;\r\n                    }\r\n                } else { // if (!insA.isNegated)\r\n                    if (!insB.isNegated && reB.test(insA.absGlob)) {\r\n                        posCoversPos = true;\r\n                    } else if (noNegCoversPos && reB.test(insA.absGlob)) {\r\n                        noNegCoversPos = false;\r\n                    }\r\n                }\r\n\r\n            });\r\n\r\n            let redundant = insA.isNegated\r\n                ? (negCoversNeg || noPosCoversNeg)\r\n                : (posCoversPos && noNegCoversPos);\r\n\r\n            if (duplicate || hasExactNegative || redundant) {\r\n                // remove the current (at the end)\r\n                debugger\r\n                globsArray.splice(indexA, 1);\r\n            }\r\n\r\n        });\r\n\r\n        // since negated wins in the same array, ['*', '!*'] is already reduced\r\n        // to ['!*'] so we can safely remove !* if found, since it's redundant.\r\n        // e.g. ['!*', 'name'] => ['name']\r\n        let i = globsArray.indexOf('!*');\r\n        if (i >= 0) globsArray.splice(i, 1);\r\n\r\n        return globsArray;\r\n    }\r\n\r\n    /**\r\n     *  Gets the union from the given couple of glob arrays and returns\r\n     *  a new array of globs.\r\n     *  <ul>\r\n     *  <li>If the exact same element is found in both\r\n     *  arrays, one of them is removed to prevent duplicates.\r\n     *  <br />example: `['!id', 'name'] ∪ ['!id']` unites to `['!id', 'name']`</li>\r\n     *  <li>If any non-negated item is covered by a glob in the same\r\n     *  or other array, the redundant item is removed.\r\n     *  <br />example: `['*', 'name'] ∪ ['email']` unites to `['*']`</li>\r\n     *  <li>If one of the arrays contains a negated equivalent of an\r\n     *  item in the other array, the negated item is removed.\r\n     *  <br />example: `['!id'] ∪ ['id']` unites to `['id']`</li>\r\n     *  <li>If any item covers/matches a negated item in the other array,\r\n     *  the negated item is removed.\r\n     *  <br />example #1: `['!user.id'] ∪ ['user.*']` unites to `['user.*']`\r\n     *  <br />example #2: `['*'] ∪ ['!password']` unites to `['*']`\r\n     *  </li>\r\n     *  <li>So on... For a better understanding read the inline code\r\n     *  documentation.</li>\r\n     *  </ul>\r\n     *  @name Notation.Glob.union\r\n     *  @function\r\n     *\r\n     *  @param {Array} globsA - First array of glob strings.\r\n     *  @param {Array} globsB - Second array of glob strings.\r\n     *\r\n     *  @returns {Array}\r\n     *\r\n     *  @example\r\n     *  const a = ['foo.bar', 'bar.baz', '!*.qux'];\r\n     *  const b = ['!foo.bar', 'bar.qux', 'bar.baz'];\r\n     *  const union = Notation.Glob.union(a, b);\r\n     *  console.log(union);\r\n     *  // ['!*.qux', 'foo.bar', 'bar.baz', 'bar.qux']\r\n     */\r\n    static union(globsA, globsB) {\r\n        // NOTE: The logic here is quite complex. For making this easier to\r\n        // understand; below code is written a bit verbose. Do not modify this\r\n        // only to make it shorter. This will already get minified.\r\n\r\n        // -----------------------\r\n\r\n        // if any of the arrays has a single glob item of only a wildcard (e.g.\r\n        // `['*']`); this covers all, so...\r\n        if (utils.hasSingleItemOf(globsA, '*') || utils.hasSingleItemOf(globsB, '*')) {\r\n            return ['*'];\r\n        }\r\n\r\n        // clone arrays so we don't mutate the originals.\r\n        const arrA = globsA.concat();\r\n        const arrB = globsB.concat();\r\n        // no need to normalize. we'll do it at the end.\r\n\r\n        let reA, reB, insA, insB;\r\n\r\n        // storage for tracking (winner) negated globs that are compared with\r\n        // another negated in the other array. For example:\r\n        // ['*', '!user.*'] ∪ ['*', '!user.id']\r\n        // '!user.id' should be kept in the union when compared with '!user.*'.\r\n        // but later, '!user.id' will be unioned with '*' in the other array\r\n        // which will cover and remove '!user.id'. so we'll keep a storage for\r\n        // to prevent this.\r\n        let keepNegated = [];\r\n\r\n        // iterate through array A\r\n        utils.eachRight(arrA, (a, aIndex) => {\r\n            insA = NotationGlob.inspect(a);\r\n            reA = NotationGlob.toRegExp(insA.absGlob);\r\n\r\n            // iterate through array B for each item in A\r\n            utils.eachRight(arrB, (b, bIndex) => {\r\n                insB = NotationGlob.inspect(b);\r\n                reB = NotationGlob.toRegExp(insB.absGlob);\r\n\r\n                // console.log(a, 'vs', b);\r\n\r\n                if (insA.isNegated && !insB.isNegated) {\r\n                    // if we have the non-negated version of the same glob in B,\r\n                    // we'll remove item in A. In union, non-negated wins\r\n                    // (unlike normalize — in normalize, negated wins within the\r\n                    // same array).\r\n                    if (insA.absGlob === insB.absGlob) {\r\n                        arrA.splice(aIndex, 1);\r\n                        // console.log(`${a} removed: ${a} reverses ${b}`);\r\n                        // console.log(arrA, '∪', arrB);\r\n                        return false; // break from B\r\n                    }\r\n\r\n                    // remove the negated from A only if the same value is not in B.\r\n                    // e.g. 1)  ['!x.y'] ∪ ['x.*'] => ['x.*']\r\n                    // e.g. 2)  ['!x.y'] ∪ ['x.*', '!x.y'] => ['x.*', '!x.y']\r\n                    if (reB.test(insA.absGlob) && arrB.indexOf(a) === -1 && keepNegated.indexOf(a) === -1) {\r\n                        arrA.splice(aIndex, 1);\r\n                        // console.log(`${a} removed: ${b} covers ${a}`);\r\n                        // console.log(arrA, '∪', arrB);\r\n                        return false; // break from B\r\n                    }\r\n                }\r\n\r\n                if (!insA.isNegated && insB.isNegated) {\r\n                    // if we have the non-negated version of the same glob in A,\r\n                    // we'll remove item in B.\r\n                    if (insA.absGlob === insB.absGlob) {\r\n                        arrB.splice(bIndex, 1);\r\n                        // console.log(`${b} removed: ${b} reverses ${a}`);\r\n                        // console.log(arrA, '∪', arrB);\r\n                        return; // move to next in B\r\n                    }\r\n\r\n                    // remove the negated from B only if the same value is not in A.\r\n                    // e.g. 1)  ['!x.y'] ∪ ['x.*'] => ['x.*']\r\n                    // e.g. 2)  ['!x.y'] ∪ ['x.*', '!x.y'] => ['x.*', '!x.y']\r\n                    if (reA.test(insB.absGlob) && arrA.indexOf(b) === -1 && keepNegated.indexOf(b) === -1) {\r\n                        arrB.splice(bIndex, 1);\r\n                        // console.log(`${b} removed: ${a} covers ${b}`);\r\n                        // console.log(arrA, '∪', arrB);\r\n                        return; // move to next in B\r\n                    }\r\n                }\r\n\r\n                if (insA.isNegated && insB.isNegated) {\r\n                    // if both A and B are negated and NOT equal, we'll check\r\n                    // for coverage over one or the other.\r\n                    if (a !== b) {\r\n                        // if B covers A, we'll remove from B.\r\n                        // e.g. '!user.*' covers '!user.id'\r\n                        if (reB.test(insA.absGlob)) {\r\n                            arrB.splice(bIndex, 1);\r\n                            keepNegated.push(a);\r\n                            // console.log(`${b} removed: ${a} neg-covers ${b}`);\r\n                            // console.log(arrA, '∪', arrB);\r\n                            return; // move to next in B\r\n                        }\r\n                        // if A covers B, we'll remove from A.\r\n                        if (reA.test(insB.absGlob)) {\r\n                            arrA.splice(aIndex, 1);\r\n                            keepNegated.push(b);\r\n                            // console.log(`${a} removed: ${b} neg-covers ${a}`);\r\n                            // console.log(arrA, '∪', arrB);\r\n                            return false; // break from B\r\n                        }\r\n                    }\r\n                    // else, if they are equal, we'll not remove any bec. it\r\n                    // means both arrays disalow that glob.\r\n                }\r\n\r\n                if (!insA.isNegated && !insB.isNegated) {\r\n                    // if both A and B are NOT negated and equal, we'll remove\r\n                    // from A.\r\n                    if (a === b) {\r\n                        arrA.splice(aIndex, 1);\r\n                        // console.log(`${a} removed: ${a} === ${b}`);\r\n                        // console.log(arrA, '∪', arrB);\r\n                        return false;\r\n                    }\r\n\r\n                    // else -> (a !== b)\r\n\r\n                    // Leave the rest to the normalizing process\r\n                    // (Notation.Glob.normalize) bec. when both A and B are\r\n                    // non-negated, the one which is covered by the other will\r\n                    // be removed incorrectly.\r\n\r\n                    // For example:\r\n                    // ['!x.y'] ∪ ['x.*'] => ['x.*']\r\n                    // ['*', '!x.*'] ∪ ['*', '!x.*', 'x.o']\r\n                    // '*' in A will cover and remove 'x.o' in B incorrectly bec.\r\n                    // 'x.o' is a remainder from '!x.*' which is both in A and B.\r\n\r\n                    // So when this is left as is; the final union before\r\n                    // normalizing is: ['*', '!x.*', '*', 'x.o']\r\n                    // normalized to:  ['*', '!x.*', 'x.o']\r\n\r\n                    // if (reB.test(insA.absGlob)) {\r\n                    //     arrA.splice(aIndex, 1);\r\n                    //     console.log(`${a} removed: ${b} covers ${a}`);\r\n                    //     console.log(arrA, '∪', arrB);\r\n                    //     return false;\r\n                    // }\r\n                    // if (reA.test(insB.absGlob)) {\r\n                    //     arrB.splice(bIndex, 1);\r\n                    //     console.log(`${b} removed: ${a} covers ${b}`);\r\n                    //     console.log(arrA, '∪', arrB);\r\n                    //     return;\r\n                    // }\r\n                }\r\n\r\n            });\r\n        });\r\n\r\n        // concat both arrays, normalize and sort so we get a nice union array.\r\n        const result = arrA.concat(arrB);\r\n        return NotationGlob.normalize(result);\r\n    }\r\n\r\n}\r\n\r\nexport default NotationGlob;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/notation.glob.js"],"sourceRoot":""}