{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///notation.min.js","webpack:///webpack/bootstrap b219c3cad2bff364ab90","webpack:///./src/utils.js","webpack:///./src/core/notation.error.js","webpack:///./src/index.js","webpack:///./src/core/notation.js","webpack:///./src/core/notation.glob.js"],"names":["root","factory","exports","module","define","amd","self","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","value","toString","isArray","Array","utils","isObject","a","ensureArray","undefined","hasOwn","prop","hasMember","index","deepCopy","copy","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","push","err","return","k","each","array","callback","thisArg","length","eachRight","pregQuote","str","delimiter","String","replace","RegExp","stringOrArrayOf","hasSingleItemOf","arr","itemValue","arguments","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","create","constructor","writable","setPrototypeOf","__proto__","NotationError","_Error","message","_this","getPrototypeOf","Error","captureStackTrace","stack","_notation","_notation2","obj","Notation","_interopRequireDefault","_createClass","defineProperties","target","props","descriptor","key","protoProps","staticProps","_utils","_utils2","_notation3","_notation4","ERR","SOURCE","DEST","NOTATION","NOTA_OBJ","_source","keys","list","keyglob","N","notation","nKey","subKey","isValid","level","eachNote","levelNotation","note","merge","expand","result","has","match","Number","lastNote","upToLast","parent","last","inspect","defaultValue","overwrite","isArrayMember","notationsObject","_this2","set","notations","_this3","inspectRemove","globNotations","_this4","original","globs","NotationGlob","normalize","concat","filtered","shift","g","endStar","endArrStar","normalized","globNotation","absGlob","slice","indexOf","isNegated","remove","copyFrom","originalNotation","test","destination","newNotation","moveTo","rename","copyTo","extract","extrude","split","countNotes","reverse","notes","levelNotes","join","Glob","glob","ng","_","regexp","toRegExp","levels","bang","b","levelsA","levelsB","wild","mA","mB","wildA","wildB","negA","negB","nonNegA","nonNegB","globsArray","sort","compare","map","item","trim","globA","indexA","insA","duplicate","hasExactNegative","negCoversNeg","noPosCoversNeg","posCoversPos","noNegCoversPos","globB","indexB","insB","reB","redundant","splice","globsA","globsB","arrA","arrB","reA","keepNegated","aIndex","bIndex"],"mappings":"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","file":"notation.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Notation\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Notation\"] = factory();\n\telse\n\t\troot[\"Notation\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Notation\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Notation\"] = factory();\n\telse\n\t\troot[\"Notation\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"lib/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar toString = Object.prototype.toString;\nvar _isArray = Array.isArray;\n\nvar utils = {\n    isObject: function isObject(o) {\n        return toString.call(o) === '[object Object]';\n    },\n    isArray: function isArray(a) {\n        return _isArray(a);\n    },\n    ensureArray: function ensureArray(o) {\n        if (utils.isArray(o)) return o;\n        return o === null || o === undefined ? [] : [o];\n    },\n    hasOwn: function hasOwn(o, prop) {\n        return o && typeof o.hasOwnProperty === 'function' && o.hasOwnProperty(prop);\n    },\n    hasMember: function hasMember(a, index) {\n        return a && a[index] !== undefined;\n    },\n    deepCopy: function deepCopy(object) {\n        if (utils.isArray(object)) {\n            var a = void 0,\n                i = void 0,\n                copy = [];\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = object[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    i = _step.value;\n\n                    copy.push(utils.deepCopy(i));\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            return copy;\n        } else if (utils.isObject(object)) {\n            var k = void 0,\n                o = void 0,\n                _copy = {};\n            for (k in object) {\n                if (utils.hasOwn(object, k)) {\n                    o = object[k];\n                    _copy[k] = utils.deepCopy(o);\n                }\n            }\n            return _copy;\n        } else {\n            return object;\n        }\n    },\n\n\n    // iterates over elements of an array, executing the callback for each\n    // element.\n    each: function each(array, callback, thisArg) {\n        var length = array.length,\n            index = -1;\n        while (++index < length) {\n            if (callback.call(thisArg, array[index], index, array) === false) break;\n        }\n    },\n    eachRight: function eachRight(array, callback) {\n        var index = array.length;\n        while (index--) {\n            if (callback(array[index], index, array) === false) break;\n        }\n    },\n\n\n    // Borrowed from http://phpjs.org/functions/preg_quote\n    pregQuote: function pregQuote(str, delimiter) {\n        return String(str).replace(new RegExp('[.\\\\\\\\+*?\\\\[\\\\^\\\\]$(){}=!<>|:\\\\' + (delimiter || '') + '-]', 'g'), '\\\\$&');\n    },\n    stringOrArrayOf: function stringOrArrayOf(o, value) {\n        return typeof o === 'string' && o === value || utils.isArray(o) && o.length === 1 && o[0] === value;\n    },\n    hasSingleItemOf: function hasSingleItemOf(arr, itemValue) {\n        return arr.length === 1 && (arguments.length === 2 ? arr[0] === itemValue : true);\n    }\n};\n\nexports.default = utils;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// TODO: instanceof return false.\n\n/**\r\n *  Error class specific to `Notation`.\r\n *  @name Notation.Error\r\n *  @memberof! Notation\r\n *  @class\r\n *\r\n */\nvar NotationError = function (_Error) {\n    _inherits(NotationError, _Error);\n\n    /**\r\n     *  Initializes a new `Notation.Error` instance.\r\n     *  @constructs Notation.Error\r\n     *  @param {String} message - The error message.\r\n     */\n    function NotationError() {\n        var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n        _classCallCheck(this, NotationError);\n\n        var _this = _possibleConstructorReturn(this, (NotationError.__proto__ || Object.getPrototypeOf(NotationError)).call(this, message));\n\n        _this.name = _this.constructor.name;\n\n        Object.defineProperty(_this, 'name', {\n            enumerable: false,\n            writable: false,\n            value: 'NotationError'\n        });\n\n        Object.defineProperty(_this, 'message', {\n            enumerable: false,\n            writable: true,\n            value: message\n        });\n\n        if (Error.hasOwnProperty('captureStackTrace')) {\n            // V8\n            Error.captureStackTrace(_this, _this.constructor);\n        } else {\n            Object.defineProperty(_this, 'stack', {\n                enumerable: false,\n                writable: false,\n                value: new Error(message).stack\n            });\n        }\n        return _this;\n    }\n\n    return NotationError;\n}(Error);\n\nexports.default = NotationError;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _notation = __webpack_require__(3);\n\nvar _notation2 = _interopRequireDefault(_notation);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// export default Notation;\n// http://stackoverflow.com/a/33683495/112731\nmodule.exports = _notation2.default;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = __webpack_require__(0);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _notation = __webpack_require__(4);\n\nvar _notation2 = _interopRequireDefault(_notation);\n\nvar _notation3 = __webpack_require__(1);\n\nvar _notation4 = _interopRequireDefault(_notation3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ERR = {\n    SOURCE: 'Invalid source object.',\n    DEST: 'Invalid destination object.',\n    NOTATION: 'Invalid notation: ',\n    NOTA_OBJ: 'Invalid notations object: '\n};\n\n/**\r\n *  Notation.js for Node and Browser.\r\n *\r\n *  Like in most programming languages, JavaScript makes use of dot-notation to\r\n *  access the value of a member of an object (or class). `Notation` class\r\n *  provides various methods for modifying / processing the contents of the\r\n *  given object; by parsing object notation strings or globs.\r\n *\r\n *  Note that this class will only deal with enumerable properties of the source\r\n *  object; so it should be used to manipulate data objects. It will not deal\r\n *  with preserving the prototype-chain of the given object.\r\n *\r\n *  @author   Onur Yıldırım <onur@cutepilot.com>\r\n *  @license  MIT\r\n */\n\nvar Notation = function () {\n\n    /**\r\n     *  Initializes a new instance of `Notation`.\r\n     *\r\n     *  @param {Object} [object={}] - The source object to be notated.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     *  const notation = new Notation(obj);\r\n     *  notation.get('car.model'); // \"Charger\"\r\n     */\n    function Notation() {\n        var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Notation);\n\n        // if defined, it should be an object or an array.\n        if (!_utils2.default.isObject(object) && !_utils2.default.isArray(object)) {\n            throw new _notation4.default(ERR.SOURCE);\n        }\n        this._source = object;\n    }\n\n    // --------------------------------\n    // Notation Instance Properties\n    // --------------------------------\n\n    /**\r\n     *  Gets the value of the source object.\r\n     *  @type {Object}\r\n     *\r\n     *  @example\r\n     *  const person = { name: \"Onur\" };\r\n     *  const me = Notation.create(person)\r\n     *      .set(\"age\", 36)\r\n     *      .set(\"car.brand\", \"Ford\")\r\n     *      .set(\"car.model\", \"Mustang\")\r\n     *      .value;\r\n     *  console.log(me); // { name: \"Onur\", age: 36, car: { brand: \"Ford\", model: \"Mustang\" } }\r\n     *  console.log(person === me); // true\r\n     */\n\n\n    _createClass(Notation, [{\n        key: 'each',\n\n\n        // --------------------------------\n        // Notation Instance Methods\n        // --------------------------------\n\n        /**\r\n         *  Recursively iterates through each key of the source object and invokes\r\n         *  the given callback function with parameters, on each non-object value.\r\n         *  @alias Notation#eachKey\r\n         *\r\n         *  @param {Function} callback - The callback function to be invoked on\r\n         *  each on each non-object value. To break out of the loop, return `false`\r\n         *  from within the callback.\r\n         *  Callback signature: `callback(notation, key, value, object) { ... }`\r\n         *\r\n         *  @returns {void}\r\n         *\r\n         *  @example\r\n         *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n         *  Notation.create(obj).each(function (notation, key, value, object) {\r\n         *      console.log(notation, value);\r\n         *  });\r\n         *  // \"car.brand\"  \"Dodge\"\r\n         *  // \"car.model\"  \"Charger\"\r\n         *  // \"car.year\"  1970\r\n         */\n        value: function each(callback) {\n            var _this = this;\n\n            var isArray = _utils2.default.isArray(this._source);\n            var o = this._source;\n            var keys = isArray ? o : Object.keys(o);\n            _utils2.default.each(keys, function (key, index, list) {\n\n                // this is preserved in arrow functions\n                var prop = isArray ? key : o[key],\n                    keyglob = isArray ? '[' + index + ']' : key,\n                    N = void 0;\n                if (_utils2.default.isObject(prop) || _utils2.default.isArray(prop)) {\n                    N = new Notation(prop);\n                    N.each(function (notation, nKey, value, prop) {\n                        var subKey = _utils2.default.isArray(prop) ? keyglob + notation : keyglob + '.' + notation;\n                        callback.call(N, subKey, nKey, value, o);\n                    });\n                } else {\n                    callback.call(_this, keyglob, keyglob, prop, o);\n                }\n            });\n        }\n        /**\r\n         *  Alias for `#each`\r\n         *  @private\r\n         */\n\n    }, {\n        key: 'eachKey',\n        value: function eachKey(callback) {\n            return this.each(callback);\n        }\n\n        /**\r\n         *  Iterates through each note of the given notation string by evaluating\r\n         *  it on the source object.\r\n         *\r\n         *  @param {String} notation - The notation string to be iterated through.\r\n         *  @param {Function} callback - The callback function to be invoked on\r\n         *  each iteration. To break out of the loop, return `false` from within\r\n         *  the callback.\r\n         *  Callback signature: `callback(levelValue, note, index, list) { ... }`\r\n         *\r\n         *  @returns {void}\r\n         *\r\n         *  @example\r\n         *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n         *  Notation.create(obj)\r\n         *      .eachValue(\"car.brand\", function (levelValue, note, index, list) {\r\n         *          console.log(note, levelValue); // \"car.brand\" \"Dodge\"\r\n         *      });\r\n         */\n\n    }, {\n        key: 'eachValue',\n        value: function eachValue(notation, callback) {\n            if (!Notation.isValid(notation)) {\n                throw new _notation4.default(ERR.NOTATION + '`' + notation + '`');\n            }\n            var level = this._source;\n            Notation.eachNote(notation, function (levelNotation, note, index, list) {\n                level = _utils2.default.hasOwn(level, note) ? level[note] : undefined;\n                if (callback(level, levelNotation, note, index, list) === false) return false;\n            });\n        }\n\n        /**\r\n         *  Gets the list of notations from the source object (keys).\r\n         *\r\n         *  @returns {Array} - An array of notation strings.\r\n         *\r\n         *  @example\r\n         *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n         *  const notations = Notation.create(obj).getNotations();\r\n         *  console.log(notations); // [ \"car.brand\", \"car.model\", \"car.year\" ]\r\n         */\n\n    }, {\n        key: 'getNotations',\n        value: function getNotations() {\n            var list = [];\n            this.each(function (notation, key, value, obj) {\n                list.push(notation);\n            });\n            return list;\n        }\n\n        /**\r\n         *  Flattens the source object to a single-level object with notated keys.\r\n         *\r\n         *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n         *\r\n         *  @example\r\n         *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n         *  const flat = Notation.create(obj).flatten().value;\r\n         *  console.log(flat);\r\n         *  // { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\r\n         */\n\n    }, {\n        key: 'flatten',\n        value: function flatten() {\n            var o = {};\n            this.each(function (notation, key, value, obj) {\n                o[notation] = value;\n            });\n            // return o;\n            this._source = o;\n            return this;\n        }\n\n        /**\r\n         *  Aggregates notated keys of a (single-level) object, and nests them under\r\n         *  their corresponding properties. This is the opposite of `Notation#flatten`\r\n         *  method. This might be useful when expanding a flat object fetched from\r\n         *  a database.\r\n         *  @alias Notation#aggregate\r\n         *  @chainable\r\n         *\r\n         *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n         *\r\n         *  @example\r\n         *  const obj = { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\r\n         *  const expanded = Notation.create(obj).expand().value;\r\n         *  console.log(expanded); // { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n         */\n\n    }, {\n        key: 'expand',\n        value: function expand() {\n            this._source = Notation.create({}).merge(this._source).value;\n            return this;\n        }\n        /**\r\n         *  Alias for `#expand`\r\n         *  @private\r\n         */\n\n    }, {\n        key: 'aggregate',\n        value: function aggregate() {\n            return this.expand();\n        }\n\n        /**\r\n         *  Inspects the given notation on the source object by checking\r\n         *  if the source object actually has the notated property;\r\n         *  and getting its value if exists.\r\n         *\r\n         *  @param {String} notation - The notation string to be inspected.\r\n         *\r\n         *  @returns {InspectResult} - The result object.\r\n         *\r\n         *  @example\r\n         *  Notation.create({ car: { year: 1970 } }).inspect(\"car.year\");\r\n         *  // { has: true, value: 1970 }\r\n         *  Notation.create({ car: { year: 1970 } }).inspect(\"car.color\");\r\n         *  // { has: false, value: undefined }\r\n         *  Notation.create({ car: { color: undefined } }).inspect(\"car.color\");\r\n         *  // { has: true, value: undefined }\r\n         */\n\n    }, {\n        key: 'inspect',\n        value: function inspect(notation) {\n            if (!Notation.isValid(notation)) {\n                throw new _notation4.default(ERR.NOTATION + '`' + notation + '`');\n            }\n            var level = this._source,\n                result = { has: false, value: undefined };\n            Notation.eachNote(notation, function (levelNotation, note, index, list) {\n\n                var isArray = note.match(/\\[/);\n\n                if (isArray) note = Number(note.match(/[0-9]/));\n\n                if (isArray ? _utils2.default.hasMember(level, note) : _utils2.default.hasOwn(level, note)) {\n                    level = level[note];\n                    result = { has: true, value: level };\n                } else {\n                    // level = undefined;\n                    result = { has: false, value: undefined };\n                    return false; // break out\n                }\n            });\n            return result;\n        }\n        /**\r\n         *  Notation inspection result object.\r\n         *  @typedef Notation~InspectResult\r\n         *  @type Object\r\n         *  @property {Boolean} has - Indicates whether the source object has the given\r\n         *  notation as a (leveled) enumerable property. If the property exists but has\r\n         *  a value of `undefined`, this will still return `true`.\r\n         *  @property {*} value - The value of the notated property. If the source object\r\n         *  does not have the notation, the value will be `undefined`.\r\n         */\n\n        /**\r\n         *  Inspects and removes the given notation from the source object\r\n         *  by checking if the source object actually has the notated property;\r\n         *  and getting its value if exists, before removing the property.\r\n         *\r\n         *  @param {String} notation - The notation string to be inspected.\r\n         *\r\n         *  @returns {InspectResult} - The result object.\r\n         *\r\n         *  @example\r\n         *  const obj = { name: \"John\", car: { year: 1970 } };\r\n         *  Notation.create(obj).inspectRemove(\"car.year\"); // { has: true, value: 1970 }\r\n         *  // obj » { name: \"John\", car: {} }\r\n         *  Notation.create(obj).inspectRemove(\"car.year\", true); // { has: true, value: 1970 }\r\n         *  // obj » { name: \"John\" }\r\n         *  Notation.create({ car: { year: 1970 } }).inspectRemove(\"car.color\");\r\n         *  // { has: false, value: undefined }\r\n         *  Notation.create({ car: { color: undefined } }).inspectRemove(\"car.color\");\r\n         *  // { has: true, value: undefined }\r\n         */\n\n    }, {\n        key: 'inspectRemove',\n        value: function inspectRemove(notation) {\n            if (!Notation.isValid(notation)) {\n                throw new _notation4.default(ERR.NOTATION + '`' + notation + '`');\n            }\n            var o = void 0,\n                lastNote = void 0;\n            if (notation.match(/\\.|\\[/) === null) {\n                lastNote = notation;\n                o = this._source;\n            } else {\n                var upToLast = Notation.parent(notation);\n                lastNote = Notation.last(notation);\n                debugger;\n                o = this.inspect(upToLast).value;\n            }\n            var result = void 0,\n                isArray = _utils2.default.isArray(o);\n\n            if (isArray) lastNote = Number(lastNote.match(/[0-9]+/));\n\n            if (isArray ? _utils2.default.hasMember(o, lastNote) : _utils2.default.hasOwn(o, lastNote)) {\n                result = { has: true, value: o[lastNote] };\n                delete o[lastNote];\n            } else {\n                result = { has: false, value: undefined };\n            }\n\n            return result;\n        }\n\n        /**\r\n         *  Checks whether the source object has the given notation\r\n         *  as a (leveled) enumerable property. If the property exists\r\n         *  but has a value of `undefined`, this will still return `true`.\r\n         *\r\n         *  @param {String} notation - The notation string to be checked.\r\n         *\r\n         *  @returns {Boolean}\r\n         *\r\n         *  @example\r\n         *  Notation.create({ car: { year: 1970 } }).has(\"car.year\"); // true\r\n         *  Notation.create({ car: { year: undefined } }).has(\"car.year\"); // true\r\n         *  Notation.create({}).has(\"car.color\"); // false\r\n         */\n\n    }, {\n        key: 'has',\n        value: function has(notation) {\n            return this.inspect(notation).has;\n        }\n\n        /**\r\n         *  Checks whether the source object has the given notation\r\n         *  as a (leveled) defined enumerable property. If the property\r\n         *  exists but has a value of `undefined`, this will return `false`.\r\n         *\r\n         *  @param {String} notation - The notation string to be checked.\r\n         *\r\n         *  @returns {Boolean}\r\n         *\r\n         *  @example\r\n         *  Notation.create({ car: { year: 1970 } }).hasDefined(\"car.year\"); // true\r\n         *  Notation.create({ car: { year: undefined } }).hasDefined(\"car.year\"); // false\r\n         *  Notation.create({}).hasDefined(\"car.color\"); // false\r\n         */\n\n    }, {\n        key: 'hasDefined',\n        value: function hasDefined(notation) {\n            return this.inspect(notation).value !== undefined;\n        }\n\n        /**\r\n         *  Gets the value of the corresponding property at the given\r\n         *  notation.\r\n         *\r\n         *  @param {String} notation - The notation string to be processed.\r\n         *  @param {String} [defaultValue] - The default value to be returned if\r\n         *  the property is not found or enumerable.\r\n         *\r\n         *  @returns {*} - The value of the notated property.\r\n         *\r\n         *  @example\r\n         *  Notation.create({ car: { brand: \"Dodge\" } }).get(\"car.brand\"); // \"Dodge\"\r\n         *  Notation.create({ car: {} }).get(\"car.model\"); // undefined\r\n         *  Notation.create({ car: {} }).get(\"car.model\", \"Challenger\"); // \"Challenger\"\r\n         *  Notation.create({ car: { model: undefined } }).get(\"car.model\", \"Challenger\"); // undefined\r\n         */\n\n    }, {\n        key: 'get',\n        value: function get(notation, defaultValue) {\n            var result = this.inspect(notation);\n            return !result.has ? defaultValue : result.value;\n        }\n\n        /**\r\n         *  Sets the value of the corresponding property at the given\r\n         *  notation. If the property does not exist, it will be created\r\n         *  and nested at the calculated level. If it exists; its value\r\n         *  will be overwritten by default.\r\n         *  @chainable\r\n         *\r\n         *  @param {String} notation - The notation string to be processed.\r\n         *  @param {*} value - The value to be set for the notated property.\r\n         *  @param {Boolean} [overwrite=true] - Whether to overwrite the property\r\n         *  if exists.\r\n         *\r\n         *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n         *\r\n         *  @example\r\n         *  const obj = { car: { brand: \"Dodge\", year: 1970 } };\r\n         *  Notation.create(obj)\r\n         *      .set(\"car.brand\", \"Ford\")\r\n         *      .set(\"car.model\", \"Mustang\")\r\n         *      .set(\"car.year\", 1965, false)\r\n         *      .set(\"car.color\", \"red\")\r\n         *      .set(\"boat\", \"none\");\r\n         *  console.log(obj);\r\n         *  // { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\r\n         */\n\n    }, {\n        key: 'set',\n        value: function set(notation, value) {\n            var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n            if (!Notation.isValid(notation)) {\n                throw new _notation4.default(ERR.NOTATION + '`' + notation + '`');\n            }\n            var level = this._source,\n                last = void 0,\n                isArray = void 0,\n                isArrayMember = void 0;\n            Notation.eachNote(notation, function (levelNotation, note, index, list) {\n                // check next note to see if this level is an array.\n                isArray = list[index + 1] && list[index + 1].match(/\\[([0-9]+|\\*)]/) !== null;\n                // check note to see if this is an array member.\n                isArrayMember = levelNotation.match(/\\[([0-9]+|\\*)]/) !== null;\n\n                last = index === list.length - 1;\n\n                if (isArrayMember) {\n                    // if array note, make it numerical\n                    note = Number(levelNotation.match(/[0-9]+/));\n                }\n                // check if the property is at this level\n                if (isArrayMember && _utils2.default.hasMember(level, note) || _utils2.default.hasOwn(level, note)) {\n                    // check if we're at the last level\n                    if (last) {\n                        // if overwrite is set, assign the value.\n                        if (overwrite) level[note] = value;\n                    } else {\n                        // if not, just re-reference the current level.\n                        level = level[note];\n                    }\n                } else {\n                    // we don't have this property at this level\n                    // so; if this is the last level, we set the value\n                    // if not, we set an empty object for the next level\n                    level = level[note] = last ? value : isArray ? [] : {};\n                }\n            });\n            return this;\n        }\n\n        /**\r\n         *  Just like the `.set()` method but instead of a single notation\r\n         *  string, an object of notations and values can be passed.\r\n         *  Sets the value of each corresponding property at the given\r\n         *  notation. If a property does not exist, it will be created\r\n         *  and nested at the calculated level. If it exists; its value\r\n         *  will be overwritten by default.\r\n         *  @chainable\r\n         *\r\n         *  @param {Object} notationsObject - The notations object to be processed.\r\n         *  This can either be a regular object with non-dotted keys\r\n         *  (which will be merged to the first/root level of the source object);\r\n         *  or a flattened object with notated (dotted) keys.\r\n         *  @param {Boolean} [overwrite=true] - Whether to overwrite a property if\r\n         *  exists.\r\n         *\r\n         *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n         *\r\n         *  @example\r\n         *  const obj = { car: { brand: \"Dodge\", year: 1970 } };\r\n         *  Notation.create(obj).merge({\r\n         *      \"car.brand\": \"Ford\",\r\n         *      \"car.model\": \"Mustang\",\r\n         *      \"car.year\": 1965,\r\n         *      \"car.color\": \"red\",\r\n         *      \"boat\": \"none\"\r\n         *  });\r\n         *  console.log(obj);\r\n         *  // { car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\r\n         */\n\n    }, {\n        key: 'merge',\n        value: function merge(notationsObject) {\n            var _this2 = this;\n\n            var overwrite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n            if (!_utils2.default.isObject(notationsObject)) {\n                throw new _notation4.default(ERR.NOTA_OBJ + '`' + notationsObject + '`');\n            }\n            var value = void 0;\n            _utils2.default.each(Object.keys(notationsObject), function (notation, index, obj) {\n                // this is preserved in arrow functions\n                value = notationsObject[notation];\n                _this2.set(notation, value, overwrite);\n            });\n            return this;\n        }\n\n        /**\r\n         *  Removes the properties by the given list of notations from the source\r\n         *  object and returns a new object with the removed properties.\r\n         *  Opposite of `merge()` method.\r\n         *\r\n         *  @param {Array} notations - The notations array to be processed.\r\n         *\r\n         *  @returns {Object} - An object with the removed properties.\r\n         *\r\n         *  @example\r\n         *  const obj = { car: { brand: \"Dodge\", year: 1970 }, notebook: \"Mac\" };\r\n         *  const separated = Notation.create(obj).separate([\"car.brand\", \"boat\" ]);\r\n         *  console.log(separated);\r\n         *  // { notebook: \"Mac\", car: { brand: \"Ford\" } };\r\n         *  console.log(obj);\r\n         *  // { car: { year: 1970 } };\r\n         */\n\n    }, {\n        key: 'separate',\n        value: function separate(notations) {\n            var _this3 = this;\n\n            if (!_utils2.default.isArray(notations)) {\n                throw new _notation4.default(ERR.NOTA_OBJ + '`' + notations + '`');\n            }\n            var o = new Notation({});\n            _utils2.default.each(notations, function (notation, index, obj) {\n                var result = _this3.inspectRemove(notation);\n                o.set(notation, result.value);\n            });\n            this._source = o._source;\n            return this;\n        }\n\n        /**\r\n         *  Deep clones the source object while filtering its properties\r\n         *  by the given glob notations. Includes all matched properties\r\n         *  and removes the rest.\r\n         *\r\n         *  @param {Array|String} globNotations - The glob notation(s) to\r\n         *  be processed. The difference between normal notations and\r\n         *  glob-notations is that you can use wildcard stars (*) and\r\n         *  negate the notation by prepending a bang (!). A negated\r\n         *  notation will be excluded. Order of the globs do not matter,\r\n         *  they will be logically sorted. Loose globs will be processed\r\n         *  first and verbose globs or normal notations will be processed\r\n         *  last. e.g. `[ \"car.model\", \"*\", \"!car.*\" ]` will be sorted as\r\n         *  `[ \"*\", \"!car.*\", \"car.model\" ]`.\r\n         *  Passing no parameters or passing an empty string (`\"\"` or `[\"\"]`)\r\n         *  will empty the source object.\r\n         *  @chainable\r\n         *\r\n         *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n         *\r\n         *  @example\r\n         *  const obj = { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" } };\r\n         *  const notation = Notation.create(obj);\r\n         *  notation.filter([ \"*\", \"!car.*\", \"car.model\" ]);\r\n         *  console.log(obj);       // { notebook: \"Mac\", car: { model: \"Mustang\" } }\r\n         *  notation.filter(\"*\");   // re-filtering the current contents\r\n         *  console.log(obj);       // { notebook: \"Mac\", car: { model: \"Mustang\" } }\r\n         *  notation.filter();      // or notation.filter(\"\");\r\n         *  console.log(obj);       // {}\r\n         */\n\n    }, {\n        key: 'filter',\n        value: function filter(globNotations) {\n            var _this4 = this;\n\n            var original = this.value;\n            var copy = _utils2.default.deepCopy(original);\n\n            // ensure array, normalize and sort the globs in logical order. we also\n            // concat the array first (to prevent mutating the original) bec. we'll\n            // change it's content via `.shift()`\n            var globs = _notation2.default.normalize(globNotations).concat();\n            // if globs only consist of \"*\"; set the \"copy\" as source and return.\n            if (_utils2.default.stringOrArrayOf(globs, '*')) {\n                this._source = copy;\n                return this;\n            }\n            // if globs is \"\" or [\"\"] set source to `{}` and return.\n            if (arguments.length === 0 || _utils2.default.stringOrArrayOf(globs, '') || _utils2.default.stringOrArrayOf(globs, '!*')) {\n                this._source = {};\n                return this;\n            }\n\n            var filtered = void 0;\n            // if the first item of sorted globs is \"*\" we set the source to the\n            // (full) \"copy\" and remove the \"*\" from globs (not to re-process).\n            if (globs[0] === '*') {\n                filtered = new Notation(copy);\n                globs.shift();\n            } else {\n                // otherwise we set an empty object as the source so that we can\n                // add notations/properties to it.\n                filtered = new Notation({});\n            }\n\n            var g = void 0,\n                endStar = void 0,\n                endArrStar = void 0,\n                normalized = void 0;\n            // iterate through globs\n            _utils2.default.each(globs, function (globNotation, index, array) {\n                // console.log('--->', globNotation);\n                g = new _notation2.default(globNotation);\n                // set flag that indicates whether the glob ends with `.*`\n                endStar = g.absGlob.slice(-2) === '.*';\n                // set flag that indicates whether the glob ends with `[*]`\n                endArrStar = g.absGlob.slice(-3) === '[*]';\n                // get the remaining part as the (extra) normalized glob\n                // remove either `.*` or `[*]` if present at end of glob string\n                normalized = g.absGlob.replace(/(\\.\\*$)|(\\[\\*]$)/, '');\n                // normalized = endStar ? g.absGlob.slice(0, -2) : endArrStar ?  g.absGlob.slice(0, -3) : g.absGlob;\n                // normalized = endStar ? g.absGlob.replace(/(\\.\\*)+$/, '') : g.absGlob;\n                // check if normalized glob has no wildcard stars e.g. \"a.b\" or\n                // \"!a.b.c\" etc..\n                if (normalized.indexOf('*') < 0) {\n                    if (g.isNegated) {\n                        // directly remove the notation if negated\n                        filtered.remove(normalized);\n                        // if original glob had `.*` or `[*]` at the end, it means remove\n                        // contents (not itself). so we'll set an empty object/array.\n                        // meaning `some.prop` (prop) is removed completely but\n                        // `some.prop.*` (prop) results in `{}`\n                        // and `some.prop[*]` results in `[]`.\n                        if (endStar) {\n                            filtered.set(normalized, {}, true);\n                        } else if (endArrStar) {\n                            filtered.set(normalized, [], true);\n                        }\n                    } else {\n                        // directly copy the same notation from the original\n                        filtered.copyFrom(original, normalized, null, true);\n                    }\n                    // move to the next\n                    return true;\n                }\n                // if glob has wildcard star(s), we'll iterate through keys of the\n                // source object and see if (full) notation of each key matches\n                // the current glob.\n\n                // TODO: Optimize the loop below. Instead of checking each key's\n                // notation, get the non-star left part of the glob and iterate\n                // that property of the source object.\n                _this4.each(function (originalNotation, key, value, obj) {\n                    // console.log('>>', originalNotation);\n\n                    // iterating each note of original notation. i.e.:\n                    // note1.note2.note3 is iterated from left to right, as:\n                    // 'note1', 'note1.note2', 'note1.note2.note3' — in order.\n                    Notation.eachNote(originalNotation, function (levelNotation, note, index, list) {\n                        if (g.test(levelNotation)) {\n                            debugger;\n\n                            if (g.isNegated) {\n                                // console.log('removing', levelNotation, 'of', originalNotation);\n                                filtered.remove(levelNotation);\n                                // we break and return early if removed bec. deeper\n                                // level props are also removed with this parent.\n                                // e.g. when 'note1.note2' of 'note1.note2.note3' is\n                                // removed, we no more have 'note3'.\n                                return false;\n                            }\n                            filtered.set(levelNotation, value, true);\n                        }\n                    });\n                });\n            });\n            // finally set the filtered's value as the source of our instance and\n            // return.\n            this._source = filtered.value;\n            return this;\n        }\n\n        /**\r\n         *  Removes the property from the source object, at the given notation.\r\n         *  @alias Notation#delete\r\n         *  @chainable\r\n         *\r\n         *  @param {String} notation - The notation to be inspected.\r\n         *\r\n         *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n         *\r\n         *  @example\r\n         *  const obj = { notebook: \"Mac\", car: { model: \"Mustang\" } };\r\n         *  Notation.create(obj).remove(\"car.model\");\r\n         *  console.log(obj); // { notebook: \"Mac\", car: { } }\r\n         */\n\n    }, {\n        key: 'remove',\n        value: function remove(notation) {\n            this.inspectRemove(notation);\n            return this;\n        }\n        /**\r\n         *  Alias of `Notation#remove`\r\n         *  @private\r\n         */\n\n    }, {\n        key: 'delete',\n        value: function _delete(notation) {\n            this.remove(notation);\n            return this;\n        }\n\n        /**\r\n         *  Clones the `Notation` instance to a new one.\r\n         *\r\n         *  @returns {Notation} - A new copy of the instance.\r\n         */\n\n    }, {\n        key: 'clone',\n        value: function clone() {\n            var o = _utils2.default.deepCopy(this.value);\n            return new Notation(o);\n        }\n\n        /**\r\n         *  Copies the notated property from the source object and adds it to the\r\n         *  destination — only if the source object actually has that property.\r\n         *  This is different than a property with a value of `undefined`.\r\n         *  @chainable\r\n         *\r\n         *  @param {Object} destination - The destination object that the notated\r\n         *  properties will be copied to.\r\n         *  @param {String} notation - The notation to get the corresponding property\r\n         *  from the source object.\r\n         *  @param {String} [newNotation=null] - The notation to set the source property\r\n         *  on the destination object. In other words, the copied property will be\r\n         *  renamed to this value before set on the destination object. If not set,\r\n         *  `notation` argument will be used.\r\n         *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\r\n         *  the destination object if it exists.\r\n         *\r\n         *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n         *\r\n         *  @example\r\n         *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n         *  const models = { dodge: \"Charger\" };\r\n         *  Notation.create(obj).copyTo(models, \"car.model\", \"ford\");\r\n         *  console.log(models);\r\n         *  // { dodge: \"Charger\", ford: \"Mustang\" }\r\n         *  // source object (obj) is not modified\r\n         */\n\n    }, {\n        key: 'copyTo',\n        value: function copyTo(destination, notation) {\n            var newNotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n            var overwrite = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n            if (!_utils2.default.isObject(destination)) throw new _notation4.default(ERR.DEST);\n            var result = this.inspect(notation);\n            if (result.has) {\n                new Notation(destination).set(newNotation || notation, result.value, overwrite);\n            }\n            return this;\n        }\n\n        /**\r\n         *  Copies the notated property from the destination object and adds it to the\r\n         *  source object — only if the destination object actually has that property.\r\n         *  This is different than a property with a value of `undefined`.\r\n         *  @chainable\r\n         *\r\n         *  @param {Object} destination - The destination object that the notated\r\n         *  properties will be copied from.\r\n         *  @param {String} notation - The notation to get the corresponding property\r\n         *  from the destination object.\r\n         *  @param {String} [newNotation=null] - The notation to set the destination\r\n         *  property on the source object. In other words, the copied property\r\n         *  will be renamed to this value before set on the source object.\r\n         *  If not set, `notation` argument will be used.\r\n         *  @param {Boolean} [overwrite=true] - Whether to overwrite the property\r\n         *  on the source object if it exists.\r\n         *\r\n         *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n         *\r\n         *  @example\r\n         *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n         *  const models = { dodge: \"Charger\" };\r\n         *  Notation.create(obj).copyFrom(models, \"dodge\", \"car.model\", true);\r\n         *  console.log(obj);\r\n         *  // { car: { brand: \"Ford\", model: \"Charger\" } }\r\n         *  // models object is not modified\r\n         */\n\n    }, {\n        key: 'copyFrom',\n        value: function copyFrom(destination, notation) {\n            var newNotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n            var overwrite = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n            if (!_utils2.default.isObject(destination)) throw new _notation4.default(ERR.DEST);\n            var result = new Notation(destination).inspect(notation);\n            if (result.has) {\n                this.set(newNotation || notation, result.value, overwrite);\n            }\n            return this;\n        }\n\n        /**\r\n         *  Removes the notated property from the source object and adds it to the\r\n         *  destination — only if the source object actually has that property.\r\n         *  This is different than a property with a value of `undefined`.\r\n         *  @chainable\r\n         *\r\n         *  @param {Object} destination - The destination object that the notated\r\n         *  properties will be moved to.\r\n         *  @param {String} notation - The notation to get the corresponding\r\n         *  property from the source object.\r\n         *  @param {String} [newNotation=null] - The notation to set the source property\r\n         *  on the destination object. In other words, the moved property will be\r\n         *  renamed to this value before set on the destination object. If not set,\r\n         *  `notation` argument will be used.\r\n         *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\r\n         *  the destination object if it exists.\r\n         *\r\n         *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n         *\r\n         *  @example\r\n         *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n         *  const models = { dodge: \"Charger\" };\r\n         *  Notation.create(obj).moveTo(models, \"car.model\", \"ford\");\r\n         *  console.log(obj);\r\n         *  // { car: { brand: \"Ford\" } }\r\n         *  console.log(models);\r\n         *  // { dodge: \"Charger\", ford: \"Mustang\" }\r\n         */\n\n    }, {\n        key: 'moveTo',\n        value: function moveTo(destination, notation) {\n            var newNotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n            var overwrite = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n            if (!_utils2.default.isObject(destination)) throw new _notation4.default(ERR.DEST);\n            var result = this.inspectRemove(notation);\n            if (result.has) {\n                new Notation(destination).set(newNotation || notation, result.value, overwrite);\n            }\n            return this;\n        }\n\n        /**\r\n         *  Removes the notated property from the destination object and adds it to the\r\n         *  source object — only if the destination object actually has that property.\r\n         *  This is different than a property with a value of `undefined`.\r\n         *  @chainable\r\n         *\r\n         *  @param {Object} destination - The destination object that the notated\r\n         *  properties will be moved from.\r\n         *  @param {String} notation - The notation to get the corresponding property\r\n         *  from the destination object.\r\n         *  @param {String} [newNotation=null] - The notation to set the destination\r\n         *  property on the source object. In other words, the moved property\r\n         *  will be renamed to this value before set on the source object.\r\n         *  If not set, `notation` argument will be used.\r\n         *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\r\n         *  the source object if it exists.\r\n         *\r\n         *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n         *\r\n         *  @example\r\n         *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n         *  const models = { dodge: \"Charger\" };\r\n         *  Notation.create(obj).moveFrom(models, \"dodge\", \"car.model\", true);\r\n         *  console.log(obj);\r\n         *  // { car: { brand: \"Ford\", model: \"Charger\" } }\r\n         *  console.log(models);\r\n         *  // {}\r\n         */\n\n    }, {\n        key: 'moveFrom',\n        value: function moveFrom(destination, notation) {\n            var newNotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n            var overwrite = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n            if (!_utils2.default.isObject(destination)) throw new _notation4.default(ERR.DEST);\n            var result = new Notation(destination).inspectRemove(notation);\n            if (result.has) {\n                this.set(newNotation || notation, result.value, overwrite);\n            }\n            return this;\n        }\n\n        /**\r\n         *  Renames the notated property of the source object by the new notation.\r\n         *  @alias Notation#renote\r\n         *  @chainable\r\n         *\r\n         *  @param {String} notation - The notation to get the corresponding\r\n         *  property (value) from the source object.\r\n         *  @param {String} newNotation - The new notation for the targeted\r\n         *  property value. If not set, the source object will not be modified.\r\n         *  @param {Boolean} [overwrite=true] - Whether to overwrite the property at\r\n         *  the new notation, if it exists.\r\n         *\r\n         *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n         *\r\n         *  @example\r\n         *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n         *  Notation.create(obj)\r\n         *      .rename(\"car.brand\", \"carBrand\")\r\n         *      .rename(\"car.model\", \"carModel\");\r\n         *  console.log(obj);\r\n         *  // { carBrand: \"Ford\", carModel: \"Mustang\" }\r\n         */\n\n    }, {\n        key: 'rename',\n        value: function rename(notation, newNotation, overwrite) {\n            if (!newNotation) return this;\n            return this.moveTo(this._source, notation, newNotation, overwrite);\n        }\n        /**\r\n         *  Alias for `#rename`\r\n         *  @private\r\n         */\n\n    }, {\n        key: 'renote',\n        value: function renote(notation, newNotation, overwrite) {\n            return this.rename(notation, newNotation, overwrite);\n        }\n\n        /**\r\n         *  Extracts the property at the given notation to a new object by copying\r\n         *  it from the source object. This is equivalent to `.copyTo({}, notation, newNotation)`.\r\n         *  @alias Notation#copyToNew\r\n         *\r\n         *  @param {String} notation - The notation to get the corresponding\r\n         *  property (value) from the source object.\r\n         *  @param {String} newNotation - The new notation to be set on the new\r\n         *  object for the targeted property value. If not set, `notation` argument\r\n         *  will be used.\r\n         *\r\n         *  @returns {Object} - Returns a new object with the notated property.\r\n         *\r\n         *  @example\r\n         *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n         *  const extracted = Notation.create(obj).extract(\"car.brand\", \"carBrand\");\r\n         *  console.log(extracted);\r\n         *  // { carBrand: \"Ford\" }\r\n         *  // obj is not modified\r\n         */\n\n    }, {\n        key: 'extract',\n        value: function extract(notation, newNotation) {\n            var o = {};\n            this.copyTo(o, notation, newNotation);\n            return o;\n        }\n        /**\r\n         *  Alias for `#extract`\r\n         *  @private\r\n         */\n\n    }, {\n        key: 'copyToNew',\n        value: function copyToNew(notation, newNotation) {\n            return this.extract(notation, newNotation);\n        }\n\n        /**\r\n         *  Extrudes the property at the given notation to a new object by moving\r\n         *  it from the source object. This is equivalent to `.moveTo({}, notation, newNotation)`.\r\n         *  @alias Notation#moveToNew\r\n         *\r\n         *  @param {String} notation - The notation to get the corresponding\r\n         *  property (value) from the source object.\r\n         *  @param {String} newNotation - The new notation to be set on the new\r\n         *  object for the targeted property value. If not set, `notation` argument\r\n         *  will be used.\r\n         *\r\n         *  @returns {Object} - Returns a new object with the notated property.\r\n         *\r\n         *  @example\r\n         *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n         *  const extruded = Notation.create(obj).extrude(\"car.brand\", \"carBrand\");\r\n         *  console.log(obj);\r\n         *  // { car: { model: \"Mustang\" } }\r\n         *  console.log(extruded);\r\n         *  // { carBrand: \"Ford\" }\r\n         */\n\n    }, {\n        key: 'extrude',\n        value: function extrude(notation, newNotation) {\n            var o = {};\n            this.moveTo(o, notation, newNotation);\n            return o;\n        }\n        /**\r\n         *  Alias for `#extrude`\r\n         *  @private\r\n         */\n\n    }, {\n        key: 'moveToNew',\n        value: function moveToNew(notation, newNotation) {\n            return this.extrude(notation, newNotation);\n        }\n\n        // --------------------------------\n        // Notation Static Methods\n        // --------------------------------\n\n        /**\r\n         *  Basically constructs a new `Notation` instance with the given object.\r\n         *  @chainable\r\n         *\r\n         *  @param {Object} [object={}] - The object to be notated.\r\n         *\r\n         *  @returns {Notation} - The created instance.\r\n         *\r\n         *  @example\r\n         *  const notation = Notation.create(obj);\r\n         *  // equivalent to:\r\n         *  const notation = new Notation(obj);\r\n         */\n\n    }, {\n        key: 'value',\n        get: function get() {\n            return this._source;\n        }\n    }], [{\n        key: 'create',\n        value: function create() {\n            var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            return new Notation(object);\n        }\n\n        /**\r\n         *  Checks whether the given notation string is valid. Note that the star\r\n         *  (`*`) (which is a valid character, even if irregular) is NOT treated as\r\n         *  wildcard here. This checks for normal dot-notation, not a glob-notation.\r\n         *  For glob notation validation, use `Notation.Glob.isValid()` method. Same\r\n         *  goes for the negation character/prefix (`!`).\r\n         *\r\n         *  Note that, even though `obj['some.name']` is possible in JS, dot (`.`) is\r\n         *  always treated as a level (property) separator in Notation strings.\r\n         *\r\n         *  @param {String} notation - The notation string to be checked.\r\n         *\r\n         *  @returns {Boolean}\r\n         *\r\n         *  @example\r\n         *  Notation.isValid('prop1.prop2.prop3'); // true\r\n         *  Notation.isValid('prop1'); // true\r\n         *  Notation.isValid('prop.*'); // true (but star is not treated as wildcard)\r\n         *  Notation.isValid('@1'); // true (bec. obj['@1'] is possible in JS.)\r\n         *  Notation.isValid(null); // false\r\n         */\n\n    }, {\n        key: 'isValid',\n        value: function isValid(notation) {\n            return typeof notation === 'string' && /^[^\\s.!]+((\\.[^\\s.!]+)|(\\[([0-9]+|\\*)\\]))*$/.test(notation);\n        }\n\n        /**\r\n         *  Counts the number of notes/levels in the given notation.\r\n         *  @alias Notation.countLevels\r\n         *\r\n         *  @param {*} notation - The notation string to be processed.\r\n         *\r\n         *  @returns {Number}\r\n         */\n\n    }, {\n        key: 'countNotes',\n        value: function countNotes(notation) {\n            if (!Notation.isValid(notation)) {\n                throw new _notation4.default(ERR.NOTATION + '`' + notation + '`');\n            }\n            return notation.split(/\\.|(?=\\[)/).length;\n        }\n        /**\r\n         *  Alias of `Notation.countNotes`.\r\n         *  @private\r\n         */\n\n    }, {\n        key: 'countLevels',\n        value: function countLevels(notation) {\n            return Notation.countNotes(notation);\n        }\n\n        /**\r\n         *  Gets the first (root) note of the notation string.\r\n         *\r\n         *  @param {String} notation - The notation string to be processed.\r\n         *\r\n         *  @returns {String}\r\n         *\r\n         *  @example\r\n         *  Notation.first('first.prop2.last'); // \"first\"\r\n         */\n\n    }, {\n        key: 'first',\n        value: function first(notation) {\n            if (!Notation.isValid(notation)) {\n                throw new _notation4.default(ERR.NOTATION + '`' + notation + '`');\n            }\n            // return notation.replace(/.*\\.([^\\.]*$)/, '$1');\n            return notation.split(/\\.|(?=\\[)/)[0];\n        }\n\n        /**\r\n         *  Gets the last note of the notation string.\r\n         *\r\n         *  @param {String} notation - The notation string to be processed.\r\n         *\r\n         *  @returns {String}\r\n         *\r\n         *  @example\r\n         *  Notation.last('first.prop2.last'); // \"last\"\r\n         */\n\n    }, {\n        key: 'last',\n        value: function last(notation) {\n            if (!Notation.isValid(notation)) {\n                throw new _notation4.default(ERR.NOTATION + '`' + notation + '`');\n            }\n            // return notation.replace(/.*\\.([^\\.]*$)/, '$1');\n            return notation.split(/\\.|(?=\\[)/).reverse()[0];\n        }\n\n        /**\r\n         *  Gets the parent notation (up to but excluding the last note)\r\n         *  from the notation string.\r\n         *\r\n         *  @param {String} notation - The notation string to be processed.\r\n         *\r\n         *  @returns {String}\r\n         *\r\n         *  @example\r\n         *  Notation.parent('first.prop2.last'); // \"first.prop2\"\r\n         *  Notation.parent('single'); // null\r\n         */\n\n    }, {\n        key: 'parent',\n        value: function parent(notation) {\n            if (!Notation.isValid(notation)) {\n                throw new _notation4.default(ERR.NOTATION + '`' + notation + '`');\n            }\n            return notation.match(/\\.|\\[/) !== null ? notation.replace(/(\\.|.\\[)[^.[]*$/, '') : null;\n        }\n\n        /**\r\n         *  Iterates through each note/level of the given notation string.\r\n         *  @alias Notation.eachLevel\r\n         *\r\n         *  @param {String} notation - The notation string to be iterated through.\r\n         *  @param {Function} callback - The callback function to be invoked on\r\n         *  each iteration. To break out of the loop, return `false` from within the\r\n         *  callback.\r\n         *  Callback signature: `callback(levelNotation, note, index, list) { ... }`\r\n         *\r\n         *  @returns {void}\r\n         *\r\n         *  @example\r\n         *  const notation = 'first.prop2.last';\r\n         *  Notation.eachNote(notation, function (levelNotation, note, index, list) {\r\n         *      console.log(index, note, levelNotation);\r\n         *  });\r\n         *  // 0  \"first\"             \"first\"\r\n         *  // 1  \"first.prop2\"       \"prop2\"\r\n         *  // 2  \"first.prop2.last\"  \"last\"\r\n         */\n\n    }, {\n        key: 'eachNote',\n        value: function eachNote(notation, callback) {\n            if (!Notation.isValid(notation)) {\n                throw new _notation4.default(ERR.NOTATION + '`' + notation + '`');\n            }\n            var notes = notation.split(/\\.|(?=\\[)/),\n                levelNotes = [],\n                levelNotation = void 0;\n            _utils2.default.each(notes, function (note, index, list) {\n                levelNotes.push(note);\n\n                levelNotation = levelNotes.join('.').replace(/\\.\\[/, '[');\n\n                if (callback(levelNotation, note, index, notes) === false) return false;\n            }, Notation);\n        }\n        /**\r\n         *  Alias of `Notation.eachNote`.\r\n         *  @private\r\n         */\n\n    }, {\n        key: 'eachLevel',\n        value: function eachLevel(notation, callback) {\n            Notation.eachNote(notation, callback);\n        }\n    }]);\n\n    return Notation;\n}();\n\n/**\r\n *  Error class specific to `Notation`.\r\n *  @private\r\n *\r\n *  @class\r\n *  @see `{@link #Notation.Error}`\r\n */\n\n\nNotation.Error = _notation4.default;\n\n/**\r\n *  Utility for validating, comparing and sorting dot-notation globs.\r\n *  This is internally used by `Notation` class.\r\n *  @private\r\n *\r\n *  @class\r\n *  @see `{@link #Notation.Glob}`\r\n */\nNotation.Glob = _notation2.default;\n\n// --------------------------------\n// EXPORT\n// --------------------------------\n\nexports.default = Notation;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = __webpack_require__(0);\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nvar _notation = __webpack_require__(1);\n\nvar _notation2 = _interopRequireDefault(_notation);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// http://www.linfo.org/wildcard.html\n// http://en.wikipedia.org/wiki/Glob_%28programming%29\n// http://en.wikipedia.org/wiki/Wildcard_character#Computing\n\n/**\r\n *  `Notation.Glob` is a utility for validating, comparing and sorting\r\n *  dot-notation globs.\r\n *\r\n *  You can use {@link http://www.linfo.org/wildcard.html|wildcard} stars `*`\r\n *  and negate the notation by prepending a bang `!`. A star will include all\r\n *  the properties at that level and a negated notation will be excluded.\r\n *  @name Notation.Glob\r\n *  @memberof! Notation\r\n *  @class\r\n *\r\n *  @example\r\n *  // for the following object;\r\n *  { name: 'John', billing: { account: { id: 1, active: true } } };\r\n *\r\n *  'billing.account.*'  // represents value `{ id: 1, active: true }`\r\n *  'billing.account.id' // represents value `1`\r\n *  '!billing.account.*' // represents value `{ name: 'John' }`\r\n *  'name' // represents `'John'`\r\n *  '*' // represents the whole object\r\n *\r\n *  @example\r\n *  var glob = new Notation.Glob('billing.account.*');\r\n *  glob.test('billing.account.id'); // true\r\n */\nvar NotationGlob = function () {\n\n    /**\r\n     *  Constructs a `Notation.Glob` object with the given glob string.\r\n     *  @constructs Notation.Glob\r\n     *\r\n     *  @param {String} glob - The glob string.\r\n     */\n    function NotationGlob(glob) {\n        _classCallCheck(this, NotationGlob);\n\n        if (!NotationGlob.isValid(glob)) {\n            throw new _notation2.default('Invalid notation glob: \"' + glob + '\"');\n        }\n\n        var ng = NotationGlob.inspect(glob);\n        this._ = {\n            glob: glob,\n            absGlob: ng.absGlob,\n            isNegated: ng.isNegated,\n            regexp: NotationGlob.toRegExp(ng.absGlob),\n            levels: ng.absGlob.split(/\\.|(?=\\[)/)\n        };\n    }\n\n    // --------------------------------\n    // NotationGlob Instance Properties\n    // --------------------------------\n\n    /**\r\n     *  Gets the original glob notation string.\r\n     *  @name Notation.Glob#glob\r\n     *  @type {String}\r\n     */\n\n\n    _createClass(NotationGlob, [{\n        key: 'test',\n\n\n        // --------------------------------\n        // NotationGlob Instance Methods\n        // --------------------------------\n\n        /**\r\n         *  Checks whether the given notation value matches the source notation glob.\r\n         *  @name Notation.Glob#test\r\n         *  @function\r\n         *\r\n         *  @param {String} notation - The notation string to be tested.\r\n         *\r\n         *  @returns {Boolean}\r\n         *\r\n         *  @example\r\n         *  const glob = new Notation.Glob('!prop.*.name');\r\n         *  glob.test(\"prop.account.name\"); // true\r\n         */\n        value: function test(notation) {\n            // we allow '*' to match everything. We check for this here\n            // instead of the regexp bec. we care for dots (.) within the glob.\n            return this.absGlob === '*' || this.absGlob !== '' && notation !== '' && this.regexp.test(notation);\n        }\n\n        // --------------------------------\n        // NotationGlob Static Members\n        // --------------------------------\n\n        /**\r\n         *  Basically constructs a new `NotationGlob` instance\r\n         *  with the given glob string.\r\n         *  @name Notation.Glob.create\r\n         *  @function\r\n         *\r\n         *  @param {String} glob - The source notation glob.\r\n         *\r\n         *  @returns {NotationGlob}\r\n         *\r\n         *  @example\r\n         *  const glob = Notation.Glob.create(strGlob);\r\n         *  // equivalent to:\r\n         *  const glob = new Notation.Glob(strGlob);\r\n         */\n\n    }, {\n        key: 'glob',\n        get: function get() {\n            return this._.glob;\n        }\n\n        /**\r\n         *  Gets the absolute glob notation (without the preceeding bang `!`).\r\n         *  @name Notation.Glob#absGlob\r\n         *  @type {String}\r\n         */\n\n    }, {\n        key: 'absGlob',\n        get: function get() {\n            return this._.absGlob;\n        }\n\n        /**\r\n         *  Specifies whether this glob is negated with a `!` prefix.\r\n         *  @name Notation.Glob#isNegated\r\n         *  @type {Boolean}\r\n         */\n\n    }, {\n        key: 'isNegated',\n        get: function get() {\n            return this._.isNegated;\n        }\n\n        /**\r\n         *  Represents this glob in regular expressions.\r\n         *  Note that the negation (`!`) is ignored, if any.\r\n         *  @name Notation.Glob#regexp\r\n         *  @type {RegExp}\r\n         */\n\n    }, {\n        key: 'regexp',\n        get: function get() {\n            return this._.regexp;\n        }\n\n        /**\r\n         *  List of notes/levels of this glob notation.\r\n         *  @name Notation.Glob#notes\r\n         *  @alias Notation.Glob#levels\r\n         *  @type {Array}\r\n         */\n\n    }, {\n        key: 'notes',\n        get: function get() {\n            return this._.levels;\n        }\n        /**\r\n         *  Alias of `Notation.Glob#notes`.\r\n         *  @private\r\n         */\n\n    }, {\n        key: 'levels',\n        get: function get() {\n            return this._.levels;\n        }\n    }], [{\n        key: 'create',\n        value: function create(glob) {\n            return new NotationGlob(glob);\n        }\n\n        /**\r\n         *  Gets a regular expressions instance from the given glob notation.\r\n         *  Note that the bang `!` prefix will be ignored if the given glob is negated.\r\n         *  @name Notation.Glob.toRegExp\r\n         *  @function\r\n         *\r\n         *  @param {String} glob - Glob notation to be converted.\r\n         *\r\n         *  @returns {RegExp}\r\n         */\n\n    }, {\n        key: 'toRegExp',\n        value: function toRegExp(glob) {\n            if (glob.indexOf('!') === 0) glob = glob.slice(1);\n            // Modified from http://stackoverflow.com/a/13818704/112731\n            glob = _utils2.default.pregQuote(glob).replace(/\\\\\\*/g, '[^\\\\s\\\\.[\\\\]]+').replace(/\\\\\\?/g, '.');\n            return new RegExp('^' + glob + '((\\\\.|\\\\[).+|$)');\n            // it should either end ($) or continue with a dot or a square bracket. So for example,\n            // `company.*` will produce `/^company\\.[^\\s\\.]*/` which will match both\n            // `company.name` and `company.address.street` but will not match\n            // `some.company.name`. Also `!password` will not match `!password_reset`.\n            //\n        }\n\n        /**\r\n         *  @private\r\n         */\n\n    }, {\n        key: 'inspect',\n        value: function inspect(glob) {\n            var bang = glob.slice(0, 1) === '!';\n            glob = bang ? glob.slice(1) : glob;\n            return {\n                absGlob: glob,\n                isNegated: bang\n            };\n        }\n\n        // Created test at: https://regex101.com/r/tJ7yI9/4\n        /**\r\n         *  Validates the given notation glob.\r\n         *  @name Notation.Glob.isValid\r\n         *  @function\r\n         *\r\n         *  @param {String} glob - Notation glob to be validated.\r\n         *  @returns {Boolean}\r\n         */\n\n    }, {\n        key: 'isValid',\n        value: function isValid(glob) {\n            return typeof glob === 'string' && /^(!?([^\\s.!*\\[\\]]+|\\*)((\\.([^\\s.!*\\[\\]]+|\\*))|(\\[([0-9]+|\\*)\\]))*)$/.test(glob);\n        }\n\n        /**\r\n         *  Compares two given notation globs and returns an integer value as a\r\n         *  result. This is generally used to sort glob arrays. Loose globs (with\r\n         *  stars especially closer to beginning of the glob string) and globs\r\n         *  representing the parent/root of the compared property glob come first.\r\n         *  Verbose/detailed/exact globs come last. (`* < *abc < abc`).\r\n         *\r\n         *  For instance; `store.address` comes before `store.address.street`. So\r\n         *  this works both for `*, store.address.street, !store.address` and `*,\r\n         *  store.address, !store.address.street`. For cases such as `prop.id` vs\r\n         *  `!prop.id` which represent the same property; the negated glob wins\r\n         *  (comes last).\r\n         *  @name Notation.Glob.compare\r\n         *  @function\r\n         *\r\n         *  @param {String} a - First notation glob to be compared.\r\n         *  @param {String} b - Second notation glob to be compared.\r\n         *\r\n         *  @returns {Number} - Returns `-1` if `a` comes first, `1` if `b` comes\r\n         *  first and `0` if equivalent priority.\r\n         *\r\n         *  @example\r\n         *  let result = Notation.Glob.compare('prop.*.name', 'prop.*');\r\n         *  console.log(result); // 1\r\n         */\n\n    }, {\n        key: 'compare',\n        value: function compare(a, b) {\n            // trivial case, both are exactly the same!\n            if (a === b) return 0;\n            var levelsA = a.split(/\\.|(?=\\[)/),\n                levelsB = b.split(/\\.|(?=\\[)/);\n            // Check depth (number of levels)\n            if (levelsA.length === levelsB.length) {\n                // count wildcards (assuming more wildcards comes first)\n                var wild = /(?:^|\\.)\\*(?:$|\\.)|\\[\\*\\]/g,\n                    mA = a.match(wild),\n                    mB = b.match(wild),\n                    wildA = mA ? mA.length : 0,\n                    wildB = mB ? mB.length : 0;\n                if (wildA === wildB) {\n                    // check for negation\n                    var negA = a.indexOf('!') === 0,\n                        negB = b.indexOf('!') === 0;\n                    if (negA === negB) {\n                        // both are negated or neither are, just return alphabetical\n                        return a < b ? -1 : 1;\n                    }\n                    // compare without the negatation\n                    var nonNegA = negA ? a.slice(1) : a,\n                        nonNegB = negB ? b.slice(1) : b;\n                    if (nonNegA === nonNegB) {\n                        return negA ? 1 : -1;\n                    }\n                    return nonNegA < nonNegB ? -1 : 1;\n                }\n                return wildA > wildB ? -1 : 1;\n            }\n\n            return levelsA.length < levelsB.length ? -1 : 1;\n        }\n\n        /**\r\n         *  Sorts the notation globs in the given array by their priorities. Loose\r\n         *  globs (with stars especially closer to beginning of the glob string);\r\n         *  globs representing the parent/root of the compared property glob come\r\n         *  first. Verbose/detailed/exact globs come last. (`* < *abc < abc`).\r\n         *\r\n         *  For instance; `store.address` comes before `store.address.street`. For\r\n         *  cases such as `prop.id` vs `!prop.id` which represent the same property;\r\n         *  the negated glob wins (comes last).\r\n         *  @name Notation.Glob.sort\r\n         *  @function\r\n         *\r\n         *  @param {Array} globsArray - The notation globs array to be sorted. The\r\n         *  passed array reference is modified.\r\n         *\r\n         *  @returns {Array}\r\n         *\r\n         *  @example\r\n         *  const globs = ['!prop.*.name', 'prop.*', 'prop.id'];\r\n         *  const sorted = Notation.Glob.sort(globs);\r\n         *  console.log(sorted);\r\n         *  // ['prop.*', 'prop.id', '!prop.*.name'];\r\n         */\n\n    }, {\n        key: 'sort',\n        value: function sort(globsArray) {\n            return globsArray.sort(NotationGlob.compare);\n            // return _mergeSortArray(globsArray, NotationGlob.compare);\n        }\n\n        /**\r\n         *  Normalizes the given notation globs array by removing duplicate or\r\n         *  redundant items and returns a priority-sorted globs array.\r\n         *\r\n         *  <ul>\r\n         *  <li>If any exact duplicates found, all except first is removed.</li>\r\n         *  <li>If both normal and negated versions of a glob are found, negated wins.\r\n         *  <br />example: `['id', '!id']` normalizes to `['!id']`.</li>\r\n         *  <li>If a glob is covered by another, it's removed.\r\n         *  <br />example: `['car.*', 'car.model']` normalizes to `['car.*']`.</li>\r\n         *  <li>If a glob is covered by another negated glob, it's kept.\r\n         *  <br />example: `['*', '!car.*', 'car.model']` normalizes as is.</li>\r\n         *  <li>If a negated glob is covered by another glob, it's also kept.\r\n         *  <br />example: `['car.*', '!car.model']` normalizes as is.</li>\r\n         *  </ul>\r\n         *  @name Notation.Glob.normalize\r\n         *  @function\r\n         *\r\n         *  @param {Array} globsArray - Notation globs array to be normalized.\r\n         *\r\n         *  @returns {Array}\r\n         *\r\n         *  @example\r\n         *  const globs = ['*', '!id', 'name', 'car.model', '!car.*', 'id', 'name', 'age'];\r\n         *  const normalized = Notation.Glob.normalize(globs);\r\n         *  console.log(normalized);\r\n         *  // ['*', '!car.*', '!id', 'car.model']\r\n         */\n\n    }, {\n        key: 'normalize',\n        value: function normalize(globsArray) {\n            debugger;\n            globsArray = _utils2.default.ensureArray(globsArray).map(function (item) {\n                return item.trim();\n            });\n            globsArray = NotationGlob.sort(globsArray);\n\n            _utils2.default.eachRight(globsArray, function (globA, indexA) {\n\n                // example #1:\n                // ['*', '!id', 'name', 'car.model', '!car.*', 'id', 'name']\n                // => ['*', '!id', '!car.*', 'car.model']\n\n                // example #2:\n                // ['!id', 'name', 'car.model', '!car.*', 'id', '!email']\n                // => ['!car.*', 'car.model', 'name']\n\n                var insA = NotationGlob.inspect(globA);\n                // console.log(' • ', globA, '=>', globsArray);\n\n                var duplicate = false;\n                var hasExactNegative = false;\n                var negCoversNeg = false;\n                var noPosCoversNeg = true;\n                var posCoversPos = false;\n                var noNegCoversPos = true;\n\n                // inspect/compare the current glob with the rest of the array\n                _utils2.default.eachRight(globsArray, function (globB, indexB) {\n                    // don't inspect glob with itself\n                    if (indexB === indexA) return; // no break, move to next\n\n                    var insB = NotationGlob.inspect(globB);\n                    var reB = NotationGlob.toRegExp(insB.absGlob);\n\n                    // console.log(globA, 'vs', globB);\n\n                    // (A) remove if duplicate\n                    if (globA === globB) {\n                        duplicate = true;\n                        return false; // break\n                    }\n\n                    // (B) remove if positive has an exact negative\n                    // e.g. ['prop', '!prop'] => ['!prop']\n                    // negated wins when normalized\n                    if (insB.isNegated && globA === insB.absGlob) {\n                        hasExactNegative = true;\n                        return false; // break\n                    }\n\n                    // (C) remove negated if:\n                    //    1) any negative covers it\n                    //       ['!a.b', '!a.*']  => '!a.b' is removed\n                    //    2) no positive covers it\n                    //       ['!a.b', 'a.c']   => '!a.b' is removed\n\n                    // (D) remove positive if:\n                    //    1) any positive covers it AND no negative covers it\n                    //       ['*', 'a.b']            => 'a.b' is removed\n                    //       ['*', 'a.b', '!a.*']    => 'a.b' is kept\n\n                    if (insA.isNegated) {\n                        if (insB.isNegated && reB.test(insA.absGlob)) {\n                            negCoversNeg = true;\n                            return false; // break\n                        } else if (noPosCoversNeg && reB.test(insA.absGlob)) {\n                            noPosCoversNeg = false;\n                        }\n                    } else {\n                        // if (!insA.isNegated)\n                        if (!insB.isNegated && reB.test(insA.absGlob)) {\n                            posCoversPos = true;\n                        } else if (noNegCoversPos && reB.test(insA.absGlob)) {\n                            noNegCoversPos = false;\n                        }\n                    }\n                });\n\n                var redundant = insA.isNegated ? negCoversNeg || noPosCoversNeg : posCoversPos && noNegCoversPos;\n\n                if (duplicate || hasExactNegative || redundant) {\n                    // remove the current (at the end)\n                    debugger;\n                    globsArray.splice(indexA, 1);\n                }\n            });\n\n            // since negated wins in the same array, ['*', '!*'] is already reduced\n            // to ['!*'] so we can safely remove !* if found, since it's redundant.\n            // e.g. ['!*', 'name'] => ['name']\n            var i = globsArray.indexOf('!*');\n            if (i >= 0) globsArray.splice(i, 1);\n\n            return globsArray;\n        }\n\n        /**\r\n         *  Gets the union from the given couple of glob arrays and returns\r\n         *  a new array of globs.\r\n         *  <ul>\r\n         *  <li>If the exact same element is found in both\r\n         *  arrays, one of them is removed to prevent duplicates.\r\n         *  <br />example: `['!id', 'name'] ∪ ['!id']` unites to `['!id', 'name']`</li>\r\n         *  <li>If any non-negated item is covered by a glob in the same\r\n         *  or other array, the redundant item is removed.\r\n         *  <br />example: `['*', 'name'] ∪ ['email']` unites to `['*']`</li>\r\n         *  <li>If one of the arrays contains a negated equivalent of an\r\n         *  item in the other array, the negated item is removed.\r\n         *  <br />example: `['!id'] ∪ ['id']` unites to `['id']`</li>\r\n         *  <li>If any item covers/matches a negated item in the other array,\r\n         *  the negated item is removed.\r\n         *  <br />example #1: `['!user.id'] ∪ ['user.*']` unites to `['user.*']`\r\n         *  <br />example #2: `['*'] ∪ ['!password']` unites to `['*']`\r\n         *  </li>\r\n         *  <li>So on... For a better understanding read the inline code\r\n         *  documentation.</li>\r\n         *  </ul>\r\n         *  @name Notation.Glob.union\r\n         *  @function\r\n         *\r\n         *  @param {Array} globsA - First array of glob strings.\r\n         *  @param {Array} globsB - Second array of glob strings.\r\n         *\r\n         *  @returns {Array}\r\n         *\r\n         *  @example\r\n         *  const a = ['foo.bar', 'bar.baz', '!*.qux'];\r\n         *  const b = ['!foo.bar', 'bar.qux', 'bar.baz'];\r\n         *  const union = Notation.Glob.union(a, b);\r\n         *  console.log(union);\r\n         *  // ['!*.qux', 'foo.bar', 'bar.baz', 'bar.qux']\r\n         */\n\n    }, {\n        key: 'union',\n        value: function union(globsA, globsB) {\n            // NOTE: The logic here is quite complex. For making this easier to\n            // understand; below code is written a bit verbose. Do not modify this\n            // only to make it shorter. This will already get minified.\n\n            // -----------------------\n\n            // if any of the arrays has a single glob item of only a wildcard (e.g.\n            // `['*']`); this covers all, so...\n            if (_utils2.default.hasSingleItemOf(globsA, '*') || _utils2.default.hasSingleItemOf(globsB, '*')) {\n                return ['*'];\n            }\n\n            // clone arrays so we don't mutate the originals.\n            var arrA = globsA.concat();\n            var arrB = globsB.concat();\n            // no need to normalize. we'll do it at the end.\n\n            var reA = void 0,\n                reB = void 0,\n                insA = void 0,\n                insB = void 0;\n\n            // storage for tracking (winner) negated globs that are compared with\n            // another negated in the other array. For example:\n            // ['*', '!user.*'] ∪ ['*', '!user.id']\n            // '!user.id' should be kept in the union when compared with '!user.*'.\n            // but later, '!user.id' will be unioned with '*' in the other array\n            // which will cover and remove '!user.id'. so we'll keep a storage for\n            // to prevent this.\n            var keepNegated = [];\n\n            // iterate through array A\n            _utils2.default.eachRight(arrA, function (a, aIndex) {\n                insA = NotationGlob.inspect(a);\n                reA = NotationGlob.toRegExp(insA.absGlob);\n\n                // iterate through array B for each item in A\n                _utils2.default.eachRight(arrB, function (b, bIndex) {\n                    insB = NotationGlob.inspect(b);\n                    reB = NotationGlob.toRegExp(insB.absGlob);\n\n                    // console.log(a, 'vs', b);\n\n                    if (insA.isNegated && !insB.isNegated) {\n                        // if we have the non-negated version of the same glob in B,\n                        // we'll remove item in A. In union, non-negated wins\n                        // (unlike normalize — in normalize, negated wins within the\n                        // same array).\n                        if (insA.absGlob === insB.absGlob) {\n                            arrA.splice(aIndex, 1);\n                            // console.log(`${a} removed: ${a} reverses ${b}`);\n                            // console.log(arrA, '∪', arrB);\n                            return false; // break from B\n                        }\n\n                        // remove the negated from A only if the same value is not in B.\n                        // e.g. 1)  ['!x.y'] ∪ ['x.*'] => ['x.*']\n                        // e.g. 2)  ['!x.y'] ∪ ['x.*', '!x.y'] => ['x.*', '!x.y']\n                        if (reB.test(insA.absGlob) && arrB.indexOf(a) === -1 && keepNegated.indexOf(a) === -1) {\n                            arrA.splice(aIndex, 1);\n                            // console.log(`${a} removed: ${b} covers ${a}`);\n                            // console.log(arrA, '∪', arrB);\n                            return false; // break from B\n                        }\n                    }\n\n                    if (!insA.isNegated && insB.isNegated) {\n                        // if we have the non-negated version of the same glob in A,\n                        // we'll remove item in B.\n                        if (insA.absGlob === insB.absGlob) {\n                            arrB.splice(bIndex, 1);\n                            // console.log(`${b} removed: ${b} reverses ${a}`);\n                            // console.log(arrA, '∪', arrB);\n                            return; // move to next in B\n                        }\n\n                        // remove the negated from B only if the same value is not in A.\n                        // e.g. 1)  ['!x.y'] ∪ ['x.*'] => ['x.*']\n                        // e.g. 2)  ['!x.y'] ∪ ['x.*', '!x.y'] => ['x.*', '!x.y']\n                        if (reA.test(insB.absGlob) && arrA.indexOf(b) === -1 && keepNegated.indexOf(b) === -1) {\n                            arrB.splice(bIndex, 1);\n                            // console.log(`${b} removed: ${a} covers ${b}`);\n                            // console.log(arrA, '∪', arrB);\n                            return; // move to next in B\n                        }\n                    }\n\n                    if (insA.isNegated && insB.isNegated) {\n                        // if both A and B are negated and NOT equal, we'll check\n                        // for coverage over one or the other.\n                        if (a !== b) {\n                            // if B covers A, we'll remove from B.\n                            // e.g. '!user.*' covers '!user.id'\n                            if (reB.test(insA.absGlob)) {\n                                arrB.splice(bIndex, 1);\n                                keepNegated.push(a);\n                                // console.log(`${b} removed: ${a} neg-covers ${b}`);\n                                // console.log(arrA, '∪', arrB);\n                                return; // move to next in B\n                            }\n                            // if A covers B, we'll remove from A.\n                            if (reA.test(insB.absGlob)) {\n                                arrA.splice(aIndex, 1);\n                                keepNegated.push(b);\n                                // console.log(`${a} removed: ${b} neg-covers ${a}`);\n                                // console.log(arrA, '∪', arrB);\n                                return false; // break from B\n                            }\n                        }\n                        // else, if they are equal, we'll not remove any bec. it\n                        // means both arrays disalow that glob.\n                    }\n\n                    if (!insA.isNegated && !insB.isNegated) {\n                        // if both A and B are NOT negated and equal, we'll remove\n                        // from A.\n                        if (a === b) {\n                            arrA.splice(aIndex, 1);\n                            // console.log(`${a} removed: ${a} === ${b}`);\n                            // console.log(arrA, '∪', arrB);\n                            return false;\n                        }\n\n                        // else -> (a !== b)\n\n                        // Leave the rest to the normalizing process\n                        // (Notation.Glob.normalize) bec. when both A and B are\n                        // non-negated, the one which is covered by the other will\n                        // be removed incorrectly.\n\n                        // For example:\n                        // ['!x.y'] ∪ ['x.*'] => ['x.*']\n                        // ['*', '!x.*'] ∪ ['*', '!x.*', 'x.o']\n                        // '*' in A will cover and remove 'x.o' in B incorrectly bec.\n                        // 'x.o' is a remainder from '!x.*' which is both in A and B.\n\n                        // So when this is left as is; the final union before\n                        // normalizing is: ['*', '!x.*', '*', 'x.o']\n                        // normalized to:  ['*', '!x.*', 'x.o']\n\n                        // if (reB.test(insA.absGlob)) {\n                        //     arrA.splice(aIndex, 1);\n                        //     console.log(`${a} removed: ${b} covers ${a}`);\n                        //     console.log(arrA, '∪', arrB);\n                        //     return false;\n                        // }\n                        // if (reA.test(insB.absGlob)) {\n                        //     arrB.splice(bIndex, 1);\n                        //     console.log(`${b} removed: ${a} covers ${b}`);\n                        //     console.log(arrA, '∪', arrB);\n                        //     return;\n                        // }\n                    }\n                });\n            });\n\n            // concat both arrays, normalize and sort so we get a nice union array.\n            var result = arrA.concat(arrB);\n            return NotationGlob.normalize(result);\n        }\n    }]);\n\n    return NotationGlob;\n}();\n\nexports.default = NotationGlob;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// notation.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"lib/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b219c3cad2bff364ab90","\r\nlet toString = Object.prototype.toString;\r\nlet isArray = Array.isArray;\r\n\r\nconst utils = {\r\n\r\n    isObject(o) {\r\n        return toString.call(o) === '[object Object]';\r\n    },\r\n\r\n    isArray(a) {\r\n        return isArray(a);\r\n    },\r\n\r\n    ensureArray(o) {\r\n        if (utils.isArray(o)) return o;\r\n        return o === null || o === undefined ? [] : [o];\r\n    },\r\n\r\n    hasOwn(o, prop) {\r\n        return o && typeof o.hasOwnProperty === 'function' && o.hasOwnProperty(prop);\r\n    },\r\n\r\n    hasMember(a, index) {\r\n        return a && a[index] !== undefined\r\n    },\r\n\r\n    deepCopy(object) {\r\n        if (utils.isArray(object)) {\r\n            let a, i,\r\n                copy = [];\r\n            for (i of object) {\r\n                copy.push(utils.deepCopy(i))\r\n            }\r\n            return copy;\r\n        } else if (utils.isObject(object)) {\r\n            let k, o,\r\n                copy = {};\r\n            for (k in object) {\r\n                if (utils.hasOwn(object, k)) {\r\n                    o = object[k];\r\n                    copy[k] = utils.deepCopy(o);\r\n                }\r\n            }\r\n            return copy;\r\n        } else {\r\n            return object;\r\n        }\r\n    },\r\n\r\n    // iterates over elements of an array, executing the callback for each\r\n    // element.\r\n    each(array, callback, thisArg) {\r\n        let length = array.length,\r\n            index = -1;\r\n        while (++index < length) {\r\n            if (callback.call(thisArg, array[index], index, array) === false) break;\r\n        }\r\n    },\r\n\r\n    eachRight(array, callback) {\r\n        let index = array.length;\r\n        while (index--) {\r\n            if (callback(array[index], index, array) === false) break;\r\n        }\r\n    },\r\n\r\n    // Borrowed from http://phpjs.org/functions/preg_quote\r\n    pregQuote(str, delimiter) {\r\n        return String(str)\r\n            .replace(new RegExp('[.\\\\\\\\+*?\\\\[\\\\^\\\\]$(){}=!<>|:\\\\' + (delimiter || '') + '-]', 'g'), '\\\\$&');\r\n    },\r\n\r\n    stringOrArrayOf(o, value) {\r\n        return (typeof o === 'string' && o === value)\r\n            || (utils.isArray(o) && o.length === 1 && o[0] === value);\r\n    },\r\n\r\n    hasSingleItemOf(arr, itemValue) {\r\n        return arr.length === 1\r\n            && (arguments.length === 2 ? arr[0] === itemValue : true);\r\n    }\r\n\r\n};\r\n\r\nexport default utils;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js","\r\n// TODO: instanceof return false.\r\n\r\n/**\r\n *  Error class specific to `Notation`.\r\n *  @name Notation.Error\r\n *  @memberof! Notation\r\n *  @class\r\n *\r\n */\r\nclass NotationError extends Error {\r\n\r\n    /**\r\n     *  Initializes a new `Notation.Error` instance.\r\n     *  @constructs Notation.Error\r\n     *  @param {String} message - The error message.\r\n     */\r\n    constructor(message = '') {\r\n        super(message);\r\n        this.name = this.constructor.name;\r\n\r\n        Object.defineProperty(this, 'name', {\r\n            enumerable: false,\r\n            writable: false,\r\n            value: 'NotationError'\r\n        });\r\n\r\n        Object.defineProperty(this, 'message', {\r\n            enumerable: false,\r\n            writable: true,\r\n            value: message\r\n        });\r\n\r\n        if (Error.hasOwnProperty('captureStackTrace')) { // V8\r\n            Error.captureStackTrace(this, this.constructor);\r\n        } else {\r\n            Object.defineProperty(this, 'stack', {\r\n                enumerable: false,\r\n                writable: false,\r\n                value: (new Error(message)).stack\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nexport default NotationError;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/notation.error.js","import Notation from './core/notation';\r\n// export default Notation;\r\n// http://stackoverflow.com/a/33683495/112731\r\nmodule.exports = Notation;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import utils from '../utils';\r\nimport NotationGlob from './notation.glob';\r\nimport NotationError from './notation.error';\r\n\r\nconst ERR = {\r\n    SOURCE: 'Invalid source object.',\r\n    DEST: 'Invalid destination object.',\r\n    NOTATION: 'Invalid notation: ',\r\n    NOTA_OBJ: 'Invalid notations object: '\r\n};\r\n\r\n/**\r\n *  Notation.js for Node and Browser.\r\n *\r\n *  Like in most programming languages, JavaScript makes use of dot-notation to\r\n *  access the value of a member of an object (or class). `Notation` class\r\n *  provides various methods for modifying / processing the contents of the\r\n *  given object; by parsing object notation strings or globs.\r\n *\r\n *  Note that this class will only deal with enumerable properties of the source\r\n *  object; so it should be used to manipulate data objects. It will not deal\r\n *  with preserving the prototype-chain of the given object.\r\n *\r\n *  @author   Onur Yıldırım <onur@cutepilot.com>\r\n *  @license  MIT\r\n */\r\nclass Notation {\r\n\r\n    /**\r\n     *  Initializes a new instance of `Notation`.\r\n     *\r\n     *  @param {Object} [object={}] - The source object to be notated.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     *  const notation = new Notation(obj);\r\n     *  notation.get('car.model'); // \"Charger\"\r\n     */\r\n    constructor(object = {}) {\r\n        // if defined, it should be an object or an array.\r\n        if (!utils.isObject(object) && !utils.isArray(object)) {\r\n            throw new NotationError(ERR.SOURCE);\r\n        }\r\n        this._source = object;\r\n    }\r\n\r\n    // --------------------------------\r\n    // Notation Instance Properties\r\n    // --------------------------------\r\n\r\n    /**\r\n     *  Gets the value of the source object.\r\n     *  @type {Object}\r\n     *\r\n     *  @example\r\n     *  const person = { name: \"Onur\" };\r\n     *  const me = Notation.create(person)\r\n     *      .set(\"age\", 36)\r\n     *      .set(\"car.brand\", \"Ford\")\r\n     *      .set(\"car.model\", \"Mustang\")\r\n     *      .value;\r\n     *  console.log(me); // { name: \"Onur\", age: 36, car: { brand: \"Ford\", model: \"Mustang\" } }\r\n     *  console.log(person === me); // true\r\n     */\r\n    get value() {\r\n        return this._source;\r\n    }\r\n\r\n    // --------------------------------\r\n    // Notation Instance Methods\r\n    // --------------------------------\r\n\r\n    /**\r\n     *  Recursively iterates through each key of the source object and invokes\r\n     *  the given callback function with parameters, on each non-object value.\r\n     *  @alias Notation#eachKey\r\n     *\r\n     *  @param {Function} callback - The callback function to be invoked on\r\n     *  each on each non-object value. To break out of the loop, return `false`\r\n     *  from within the callback.\r\n     *  Callback signature: `callback(notation, key, value, object) { ... }`\r\n     *\r\n     *  @returns {void}\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     *  Notation.create(obj).each(function (notation, key, value, object) {\r\n     *      console.log(notation, value);\r\n     *  });\r\n     *  // \"car.brand\"  \"Dodge\"\r\n     *  // \"car.model\"  \"Charger\"\r\n     *  // \"car.year\"  1970\r\n     */\r\n    each(callback) {\r\n        let isArray = utils.isArray(this._source)\r\n        let o = this._source;\r\n        let keys = isArray ? o : Object.keys(o);\r\n        utils.each(keys, (key, index, list) => {\r\n            \r\n            // this is preserved in arrow functions\r\n            let prop = isArray ? key : o[key],\r\n                keyglob = isArray ? '[' + index + ']' : key,\r\n                N;\r\n            if (utils.isObject(prop) || utils.isArray(prop)) {\r\n                N = new Notation(prop);\r\n                N.each((notation, nKey, value, prop) => {\r\n                    let subKey = utils.isArray(prop)\r\n                    ? keyglob + notation\r\n                    : keyglob + '.' + notation;\r\n                    callback.call(N, subKey, nKey, value, o);\r\n                });\r\n            } else {\r\n                callback.call(this, keyglob, keyglob, prop, o);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     *  Alias for `#each`\r\n     *  @private\r\n     */\r\n    eachKey(callback) {\r\n        return this.each(callback);\r\n    }\r\n\r\n    /**\r\n     *  Iterates through each note of the given notation string by evaluating\r\n     *  it on the source object.\r\n     *\r\n     *  @param {String} notation - The notation string to be iterated through.\r\n     *  @param {Function} callback - The callback function to be invoked on\r\n     *  each iteration. To break out of the loop, return `false` from within\r\n     *  the callback.\r\n     *  Callback signature: `callback(levelValue, note, index, list) { ... }`\r\n     *\r\n     *  @returns {void}\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     *  Notation.create(obj)\r\n     *      .eachValue(\"car.brand\", function (levelValue, note, index, list) {\r\n     *          console.log(note, levelValue); // \"car.brand\" \"Dodge\"\r\n     *      });\r\n     */\r\n    eachValue(notation, callback) {\r\n        if (!Notation.isValid(notation)) {\r\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\r\n        }\r\n        var level = this._source;\r\n        Notation.eachNote(notation, (levelNotation, note, index, list) => {\r\n            level = utils.hasOwn(level, note) ? level[note] : undefined;\r\n            if (callback(level, levelNotation, note, index, list) === false) return false;\r\n\r\n        });\r\n    }\r\n\r\n    /**\r\n     *  Gets the list of notations from the source object (keys).\r\n     *\r\n     *  @returns {Array} - An array of notation strings.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     *  const notations = Notation.create(obj).getNotations();\r\n     *  console.log(notations); // [ \"car.brand\", \"car.model\", \"car.year\" ]\r\n     */\r\n    getNotations() {\r\n        let list = [];\r\n        this.each((notation, key, value, obj) => {\r\n            list.push(notation);\r\n        });\r\n        return list;\r\n    }\r\n\r\n    /**\r\n     *  Flattens the source object to a single-level object with notated keys.\r\n     *\r\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     *  const flat = Notation.create(obj).flatten().value;\r\n     *  console.log(flat);\r\n     *  // { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\r\n     */\r\n    flatten() {\r\n        let o = {};\r\n        this.each((notation, key, value, obj) => {\r\n            o[notation] = value;\r\n        });\r\n        // return o;\r\n        this._source = o;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Aggregates notated keys of a (single-level) object, and nests them under\r\n     *  their corresponding properties. This is the opposite of `Notation#flatten`\r\n     *  method. This might be useful when expanding a flat object fetched from\r\n     *  a database.\r\n     *  @alias Notation#aggregate\r\n     *  @chainable\r\n     *\r\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\r\n     *  const expanded = Notation.create(obj).expand().value;\r\n     *  console.log(expanded); // { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     */\r\n    expand() {\r\n        this._source = Notation.create({}).merge(this._source).value;\r\n        return this;\r\n    }\r\n    /**\r\n     *  Alias for `#expand`\r\n     *  @private\r\n     */\r\n    aggregate() {\r\n        return this.expand();\r\n    }\r\n\r\n    /**\r\n     *  Inspects the given notation on the source object by checking\r\n     *  if the source object actually has the notated property;\r\n     *  and getting its value if exists.\r\n     *\r\n     *  @param {String} notation - The notation string to be inspected.\r\n     *\r\n     *  @returns {InspectResult} - The result object.\r\n     *\r\n     *  @example\r\n     *  Notation.create({ car: { year: 1970 } }).inspect(\"car.year\");\r\n     *  // { has: true, value: 1970 }\r\n     *  Notation.create({ car: { year: 1970 } }).inspect(\"car.color\");\r\n     *  // { has: false, value: undefined }\r\n     *  Notation.create({ car: { color: undefined } }).inspect(\"car.color\");\r\n     *  // { has: true, value: undefined }\r\n     */\r\n    inspect(notation) {\r\n        if (!Notation.isValid(notation)) {\r\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\r\n        }\r\n        let level = this._source,\r\n            result = { has: false, value: undefined };\r\n        Notation.eachNote(notation, (levelNotation, note, index, list) => {\r\n\r\n            let isArray = note.match(/\\[/)\r\n\r\n            if (isArray) note = Number(note.match(/[0-9]/))\r\n\r\n            if (isArray ? utils.hasMember(level, note) : utils.hasOwn(level, note)) {\r\n                level = level[note];\r\n                result = { has: true, value: level };\r\n            } else {\r\n                // level = undefined;\r\n                result = { has: false, value: undefined };\r\n                return false; // break out\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n    /**\r\n     *  Notation inspection result object.\r\n     *  @typedef Notation~InspectResult\r\n     *  @type Object\r\n     *  @property {Boolean} has - Indicates whether the source object has the given\r\n     *  notation as a (leveled) enumerable property. If the property exists but has\r\n     *  a value of `undefined`, this will still return `true`.\r\n     *  @property {*} value - The value of the notated property. If the source object\r\n     *  does not have the notation, the value will be `undefined`.\r\n     */\r\n\r\n    /**\r\n     *  Inspects and removes the given notation from the source object\r\n     *  by checking if the source object actually has the notated property;\r\n     *  and getting its value if exists, before removing the property.\r\n     *\r\n     *  @param {String} notation - The notation string to be inspected.\r\n     *\r\n     *  @returns {InspectResult} - The result object.\r\n     *\r\n     *  @example\r\n     *  const obj = { name: \"John\", car: { year: 1970 } };\r\n     *  Notation.create(obj).inspectRemove(\"car.year\"); // { has: true, value: 1970 }\r\n     *  // obj » { name: \"John\", car: {} }\r\n     *  Notation.create(obj).inspectRemove(\"car.year\", true); // { has: true, value: 1970 }\r\n     *  // obj » { name: \"John\" }\r\n     *  Notation.create({ car: { year: 1970 } }).inspectRemove(\"car.color\");\r\n     *  // { has: false, value: undefined }\r\n     *  Notation.create({ car: { color: undefined } }).inspectRemove(\"car.color\");\r\n     *  // { has: true, value: undefined }\r\n     */\r\n    inspectRemove(notation) {\r\n        if (!Notation.isValid(notation)) {\r\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\r\n        }\r\n        let o, lastNote;\r\n        if (notation.match(/\\.|\\[/) === null) {\r\n            lastNote = notation;\r\n            o = this._source;\r\n        } else {\r\n            let upToLast = Notation.parent(notation);\r\n            lastNote = Notation.last(notation);\r\n            debugger\r\n            o = this.inspect(upToLast).value;\r\n        }\r\n        let result,\r\n            isArray = utils.isArray(o);\r\n\r\n        if (isArray) lastNote = Number(lastNote.match(/[0-9]+/))\r\n\r\n        if (isArray ? utils.hasMember(o, lastNote) : utils.hasOwn(o, lastNote)) {\r\n            result = { has: true, value: o[lastNote] };\r\n            delete o[lastNote];\r\n        } else {\r\n            result = { has: false, value: undefined };\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     *  Checks whether the source object has the given notation\r\n     *  as a (leveled) enumerable property. If the property exists\r\n     *  but has a value of `undefined`, this will still return `true`.\r\n     *\r\n     *  @param {String} notation - The notation string to be checked.\r\n     *\r\n     *  @returns {Boolean}\r\n     *\r\n     *  @example\r\n     *  Notation.create({ car: { year: 1970 } }).has(\"car.year\"); // true\r\n     *  Notation.create({ car: { year: undefined } }).has(\"car.year\"); // true\r\n     *  Notation.create({}).has(\"car.color\"); // false\r\n     */\r\n    has(notation) {\r\n        return this.inspect(notation).has;\r\n    }\r\n\r\n    /**\r\n     *  Checks whether the source object has the given notation\r\n     *  as a (leveled) defined enumerable property. If the property\r\n     *  exists but has a value of `undefined`, this will return `false`.\r\n     *\r\n     *  @param {String} notation - The notation string to be checked.\r\n     *\r\n     *  @returns {Boolean}\r\n     *\r\n     *  @example\r\n     *  Notation.create({ car: { year: 1970 } }).hasDefined(\"car.year\"); // true\r\n     *  Notation.create({ car: { year: undefined } }).hasDefined(\"car.year\"); // false\r\n     *  Notation.create({}).hasDefined(\"car.color\"); // false\r\n     */\r\n    hasDefined(notation) {\r\n        return this.inspect(notation).value !== undefined;\r\n    }\r\n\r\n    /**\r\n     *  Gets the value of the corresponding property at the given\r\n     *  notation.\r\n     *\r\n     *  @param {String} notation - The notation string to be processed.\r\n     *  @param {String} [defaultValue] - The default value to be returned if\r\n     *  the property is not found or enumerable.\r\n     *\r\n     *  @returns {*} - The value of the notated property.\r\n     *\r\n     *  @example\r\n     *  Notation.create({ car: { brand: \"Dodge\" } }).get(\"car.brand\"); // \"Dodge\"\r\n     *  Notation.create({ car: {} }).get(\"car.model\"); // undefined\r\n     *  Notation.create({ car: {} }).get(\"car.model\", \"Challenger\"); // \"Challenger\"\r\n     *  Notation.create({ car: { model: undefined } }).get(\"car.model\", \"Challenger\"); // undefined\r\n     */\r\n    get(notation, defaultValue) {\r\n        let result = this.inspect(notation);\r\n        return !result.has ? defaultValue : result.value;\r\n    }\r\n\r\n    /**\r\n     *  Sets the value of the corresponding property at the given\r\n     *  notation. If the property does not exist, it will be created\r\n     *  and nested at the calculated level. If it exists; its value\r\n     *  will be overwritten by default.\r\n     *  @chainable\r\n     *\r\n     *  @param {String} notation - The notation string to be processed.\r\n     *  @param {*} value - The value to be set for the notated property.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property\r\n     *  if exists.\r\n     *\r\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 } };\r\n     *  Notation.create(obj)\r\n     *      .set(\"car.brand\", \"Ford\")\r\n     *      .set(\"car.model\", \"Mustang\")\r\n     *      .set(\"car.year\", 1965, false)\r\n     *      .set(\"car.color\", \"red\")\r\n     *      .set(\"boat\", \"none\");\r\n     *  console.log(obj);\r\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\r\n     */\r\n    set(notation, value, overwrite = true) {\r\n        if (!Notation.isValid(notation)) {\r\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\r\n        }\r\n        let level = this._source,\r\n            last,\r\n            isArray,\r\n            isArrayMember;\r\n        Notation.eachNote(notation, (levelNotation, note, index, list) => {\r\n            // check next note to see if this level is an array.\r\n            isArray = list[index + 1] && list[index + 1].match(/\\[([0-9]+|\\*)]/) !== null;\r\n            // check note to see if this is an array member.\r\n            isArrayMember = levelNotation.match(/\\[([0-9]+|\\*)]/) !== null;\r\n\r\n            last = index === list.length - 1;\r\n\r\n            if (isArrayMember) {\r\n                // if array note, make it numerical\r\n                note = Number(levelNotation.match(/[0-9]+/))\r\n            }\r\n            // check if the property is at this level\r\n            if ((isArrayMember && utils.hasMember(level, note)) || utils.hasOwn(level, note)) {\r\n                // check if we're at the last level\r\n                if (last) {\r\n                    // if overwrite is set, assign the value.\r\n                    if (overwrite) level[note] = value;\r\n                } else {\r\n                    // if not, just re-reference the current level.\r\n                    level = level[note];\r\n                }\r\n            } else {\r\n                // we don't have this property at this level\r\n                // so; if this is the last level, we set the value\r\n                // if not, we set an empty object for the next level\r\n                level = level[note] = (last ? value : isArray ? [] : {});\r\n            }\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Just like the `.set()` method but instead of a single notation\r\n     *  string, an object of notations and values can be passed.\r\n     *  Sets the value of each corresponding property at the given\r\n     *  notation. If a property does not exist, it will be created\r\n     *  and nested at the calculated level. If it exists; its value\r\n     *  will be overwritten by default.\r\n     *  @chainable\r\n     *\r\n     *  @param {Object} notationsObject - The notations object to be processed.\r\n     *  This can either be a regular object with non-dotted keys\r\n     *  (which will be merged to the first/root level of the source object);\r\n     *  or a flattened object with notated (dotted) keys.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite a property if\r\n     *  exists.\r\n     *\r\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 } };\r\n     *  Notation.create(obj).merge({\r\n     *      \"car.brand\": \"Ford\",\r\n     *      \"car.model\": \"Mustang\",\r\n     *      \"car.year\": 1965,\r\n     *      \"car.color\": \"red\",\r\n     *      \"boat\": \"none\"\r\n     *  });\r\n     *  console.log(obj);\r\n     *  // { car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\r\n     */\r\n    merge(notationsObject, overwrite = true) {\r\n        if (!utils.isObject(notationsObject)) {\r\n            throw new NotationError(ERR.NOTA_OBJ + '`' + notationsObject + '`');\r\n        }\r\n        let value;\r\n        utils.each(Object.keys(notationsObject), (notation, index, obj) => {\r\n            // this is preserved in arrow functions\r\n            value = notationsObject[notation];\r\n            this.set(notation, value, overwrite);\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Removes the properties by the given list of notations from the source\r\n     *  object and returns a new object with the removed properties.\r\n     *  Opposite of `merge()` method.\r\n     *\r\n     *  @param {Array} notations - The notations array to be processed.\r\n     *\r\n     *  @returns {Object} - An object with the removed properties.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 }, notebook: \"Mac\" };\r\n     *  const separated = Notation.create(obj).separate([\"car.brand\", \"boat\" ]);\r\n     *  console.log(separated);\r\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\" } };\r\n     *  console.log(obj);\r\n     *  // { car: { year: 1970 } };\r\n     */\r\n    separate(notations) {\r\n        if (!utils.isArray(notations)) {\r\n            throw new NotationError(ERR.NOTA_OBJ + '`' + notations + '`');\r\n        }\r\n        let o = new Notation({});\r\n        utils.each(notations, (notation, index, obj) => {\r\n            let result = this.inspectRemove(notation);\r\n            o.set(notation, result.value);\r\n        });\r\n        this._source = o._source;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Deep clones the source object while filtering its properties\r\n     *  by the given glob notations. Includes all matched properties\r\n     *  and removes the rest.\r\n     *\r\n     *  @param {Array|String} globNotations - The glob notation(s) to\r\n     *  be processed. The difference between normal notations and\r\n     *  glob-notations is that you can use wildcard stars (*) and\r\n     *  negate the notation by prepending a bang (!). A negated\r\n     *  notation will be excluded. Order of the globs do not matter,\r\n     *  they will be logically sorted. Loose globs will be processed\r\n     *  first and verbose globs or normal notations will be processed\r\n     *  last. e.g. `[ \"car.model\", \"*\", \"!car.*\" ]` will be sorted as\r\n     *  `[ \"*\", \"!car.*\", \"car.model\" ]`.\r\n     *  Passing no parameters or passing an empty string (`\"\"` or `[\"\"]`)\r\n     *  will empty the source object.\r\n     *  @chainable\r\n     *\r\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" } };\r\n     *  const notation = Notation.create(obj);\r\n     *  notation.filter([ \"*\", \"!car.*\", \"car.model\" ]);\r\n     *  console.log(obj);       // { notebook: \"Mac\", car: { model: \"Mustang\" } }\r\n     *  notation.filter(\"*\");   // re-filtering the current contents\r\n     *  console.log(obj);       // { notebook: \"Mac\", car: { model: \"Mustang\" } }\r\n     *  notation.filter();      // or notation.filter(\"\");\r\n     *  console.log(obj);       // {}\r\n     */\r\n    filter(globNotations) {\r\n        let original = this.value;\r\n        let copy = utils.deepCopy(original);\r\n\r\n        // ensure array, normalize and sort the globs in logical order. we also\r\n        // concat the array first (to prevent mutating the original) bec. we'll\r\n        // change it's content via `.shift()`\r\n        let globs = NotationGlob.normalize(globNotations).concat();\r\n        // if globs only consist of \"*\"; set the \"copy\" as source and return.\r\n        if (utils.stringOrArrayOf(globs, '*')) {\r\n            this._source = copy;\r\n            return this;\r\n        }\r\n        // if globs is \"\" or [\"\"] set source to `{}` and return.\r\n        if (arguments.length === 0\r\n                || utils.stringOrArrayOf(globs, '')\r\n                || utils.stringOrArrayOf(globs, '!*')) {\r\n            this._source = {};\r\n            return this;\r\n        }\r\n\r\n        let filtered;\r\n        // if the first item of sorted globs is \"*\" we set the source to the\r\n        // (full) \"copy\" and remove the \"*\" from globs (not to re-process).\r\n        if (globs[0] === '*') {\r\n            filtered = new Notation(copy);\r\n            globs.shift();\r\n        } else {\r\n            // otherwise we set an empty object as the source so that we can\r\n            // add notations/properties to it.\r\n            filtered = new Notation({});\r\n        }\r\n\r\n        let g, endStar, endArrStar, normalized;\r\n        // iterate through globs\r\n        utils.each(globs, (globNotation, index, array) => {\r\n            // console.log('--->', globNotation);\r\n            g = new NotationGlob(globNotation);\r\n            // set flag that indicates whether the glob ends with `.*`\r\n            endStar = g.absGlob.slice(-2) === '.*';\r\n            // set flag that indicates whether the glob ends with `[*]`\r\n            endArrStar = g.absGlob.slice(-3) === '[*]';\r\n            // get the remaining part as the (extra) normalized glob\r\n            // remove either `.*` or `[*]` if present at end of glob string\r\n            normalized = g.absGlob.replace(/(\\.\\*$)|(\\[\\*]$)/, '');\r\n            // normalized = endStar ? g.absGlob.slice(0, -2) : endArrStar ?  g.absGlob.slice(0, -3) : g.absGlob;\r\n            // normalized = endStar ? g.absGlob.replace(/(\\.\\*)+$/, '') : g.absGlob;\r\n            // check if normalized glob has no wildcard stars e.g. \"a.b\" or\r\n            // \"!a.b.c\" etc..\r\n            if (normalized.indexOf('*') < 0) {\r\n                if (g.isNegated) {\r\n                    // directly remove the notation if negated\r\n                    filtered.remove(normalized);\r\n                    // if original glob had `.*` or `[*]` at the end, it means remove\r\n                    // contents (not itself). so we'll set an empty object/array.\r\n                    // meaning `some.prop` (prop) is removed completely but\r\n                    // `some.prop.*` (prop) results in `{}`\r\n                    // and `some.prop[*]` results in `[]`.\r\n                    if (endStar) {\r\n                        filtered.set(normalized, {}, true);\r\n                    } else if (endArrStar) {\r\n                        filtered.set(normalized, [], true);\r\n                    }\r\n                } else {\r\n                    // directly copy the same notation from the original\r\n                    filtered.copyFrom(original, normalized, null, true);\r\n                }\r\n                // move to the next\r\n                return true;\r\n            }\r\n            // if glob has wildcard star(s), we'll iterate through keys of the\r\n            // source object and see if (full) notation of each key matches\r\n            // the current glob.\r\n\r\n            // TODO: Optimize the loop below. Instead of checking each key's\r\n            // notation, get the non-star left part of the glob and iterate\r\n            // that property of the source object.\r\n            this.each((originalNotation, key, value, obj) => {\r\n                // console.log('>>', originalNotation);\r\n\r\n                // iterating each note of original notation. i.e.:\r\n                // note1.note2.note3 is iterated from left to right, as:\r\n                // 'note1', 'note1.note2', 'note1.note2.note3' — in order.\r\n                Notation.eachNote(originalNotation, (levelNotation, note, index, list) => {\r\n                    if (g.test(levelNotation)) {\r\n                        debugger\r\n\r\n                        if (g.isNegated) {\r\n                            // console.log('removing', levelNotation, 'of', originalNotation);\r\n                            filtered.remove(levelNotation);\r\n                            // we break and return early if removed bec. deeper\r\n                            // level props are also removed with this parent.\r\n                            // e.g. when 'note1.note2' of 'note1.note2.note3' is\r\n                            // removed, we no more have 'note3'.\r\n                            return false;\r\n                        }\r\n                        filtered.set(levelNotation, value, true);\r\n                    }\r\n                });\r\n            });\r\n        });\r\n        // finally set the filtered's value as the source of our instance and\r\n        // return.\r\n        this._source = filtered.value;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Removes the property from the source object, at the given notation.\r\n     *  @alias Notation#delete\r\n     *  @chainable\r\n     *\r\n     *  @param {String} notation - The notation to be inspected.\r\n     *\r\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { notebook: \"Mac\", car: { model: \"Mustang\" } };\r\n     *  Notation.create(obj).remove(\"car.model\");\r\n     *  console.log(obj); // { notebook: \"Mac\", car: { } }\r\n     */\r\n    remove(notation) {\r\n        this.inspectRemove(notation);\r\n        return this;\r\n    }\r\n    /**\r\n     *  Alias of `Notation#remove`\r\n     *  @private\r\n     */\r\n    delete(notation) {\r\n        this.remove(notation);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Clones the `Notation` instance to a new one.\r\n     *\r\n     *  @returns {Notation} - A new copy of the instance.\r\n     */\r\n    clone() {\r\n        let o = utils.deepCopy(this.value);\r\n        return new Notation(o);\r\n    }\r\n\r\n    /**\r\n     *  Copies the notated property from the source object and adds it to the\r\n     *  destination — only if the source object actually has that property.\r\n     *  This is different than a property with a value of `undefined`.\r\n     *  @chainable\r\n     *\r\n     *  @param {Object} destination - The destination object that the notated\r\n     *  properties will be copied to.\r\n     *  @param {String} notation - The notation to get the corresponding property\r\n     *  from the source object.\r\n     *  @param {String} [newNotation=null] - The notation to set the source property\r\n     *  on the destination object. In other words, the copied property will be\r\n     *  renamed to this value before set on the destination object. If not set,\r\n     *  `notation` argument will be used.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\r\n     *  the destination object if it exists.\r\n     *\r\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  const models = { dodge: \"Charger\" };\r\n     *  Notation.create(obj).copyTo(models, \"car.model\", \"ford\");\r\n     *  console.log(models);\r\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\r\n     *  // source object (obj) is not modified\r\n     */\r\n    copyTo(destination, notation, newNotation = null, overwrite = true) {\r\n        if (!utils.isObject(destination)) throw new NotationError(ERR.DEST);\r\n        let result = this.inspect(notation);\r\n        if (result.has) {\r\n            new Notation(destination).set(newNotation || notation, result.value, overwrite);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Copies the notated property from the destination object and adds it to the\r\n     *  source object — only if the destination object actually has that property.\r\n     *  This is different than a property with a value of `undefined`.\r\n     *  @chainable\r\n     *\r\n     *  @param {Object} destination - The destination object that the notated\r\n     *  properties will be copied from.\r\n     *  @param {String} notation - The notation to get the corresponding property\r\n     *  from the destination object.\r\n     *  @param {String} [newNotation=null] - The notation to set the destination\r\n     *  property on the source object. In other words, the copied property\r\n     *  will be renamed to this value before set on the source object.\r\n     *  If not set, `notation` argument will be used.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property\r\n     *  on the source object if it exists.\r\n     *\r\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  const models = { dodge: \"Charger\" };\r\n     *  Notation.create(obj).copyFrom(models, \"dodge\", \"car.model\", true);\r\n     *  console.log(obj);\r\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\r\n     *  // models object is not modified\r\n     */\r\n    copyFrom(destination, notation, newNotation = null, overwrite = true) {\r\n        if (!utils.isObject(destination)) throw new NotationError(ERR.DEST);\r\n        let result = new Notation(destination).inspect(notation);\r\n        if (result.has) {\r\n            this.set(newNotation || notation, result.value, overwrite);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Removes the notated property from the source object and adds it to the\r\n     *  destination — only if the source object actually has that property.\r\n     *  This is different than a property with a value of `undefined`.\r\n     *  @chainable\r\n     *\r\n     *  @param {Object} destination - The destination object that the notated\r\n     *  properties will be moved to.\r\n     *  @param {String} notation - The notation to get the corresponding\r\n     *  property from the source object.\r\n     *  @param {String} [newNotation=null] - The notation to set the source property\r\n     *  on the destination object. In other words, the moved property will be\r\n     *  renamed to this value before set on the destination object. If not set,\r\n     *  `notation` argument will be used.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\r\n     *  the destination object if it exists.\r\n     *\r\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  const models = { dodge: \"Charger\" };\r\n     *  Notation.create(obj).moveTo(models, \"car.model\", \"ford\");\r\n     *  console.log(obj);\r\n     *  // { car: { brand: \"Ford\" } }\r\n     *  console.log(models);\r\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\r\n     */\r\n    moveTo(destination, notation, newNotation = null, overwrite = true) {\r\n        if (!utils.isObject(destination)) throw new NotationError(ERR.DEST);\r\n        let result = this.inspectRemove(notation);\r\n        if (result.has) {\r\n            new Notation(destination).set(newNotation || notation, result.value, overwrite);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Removes the notated property from the destination object and adds it to the\r\n     *  source object — only if the destination object actually has that property.\r\n     *  This is different than a property with a value of `undefined`.\r\n     *  @chainable\r\n     *\r\n     *  @param {Object} destination - The destination object that the notated\r\n     *  properties will be moved from.\r\n     *  @param {String} notation - The notation to get the corresponding property\r\n     *  from the destination object.\r\n     *  @param {String} [newNotation=null] - The notation to set the destination\r\n     *  property on the source object. In other words, the moved property\r\n     *  will be renamed to this value before set on the source object.\r\n     *  If not set, `notation` argument will be used.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\r\n     *  the source object if it exists.\r\n     *\r\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  const models = { dodge: \"Charger\" };\r\n     *  Notation.create(obj).moveFrom(models, \"dodge\", \"car.model\", true);\r\n     *  console.log(obj);\r\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\r\n     *  console.log(models);\r\n     *  // {}\r\n     */\r\n    moveFrom(destination, notation, newNotation = null, overwrite = true) {\r\n        if (!utils.isObject(destination)) throw new NotationError(ERR.DEST);\r\n        let result = new Notation(destination).inspectRemove(notation);\r\n        if (result.has) {\r\n            this.set(newNotation || notation, result.value, overwrite);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Renames the notated property of the source object by the new notation.\r\n     *  @alias Notation#renote\r\n     *  @chainable\r\n     *\r\n     *  @param {String} notation - The notation to get the corresponding\r\n     *  property (value) from the source object.\r\n     *  @param {String} newNotation - The new notation for the targeted\r\n     *  property value. If not set, the source object will not be modified.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property at\r\n     *  the new notation, if it exists.\r\n     *\r\n     *  @returns {Notation} - Returns the current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  Notation.create(obj)\r\n     *      .rename(\"car.brand\", \"carBrand\")\r\n     *      .rename(\"car.model\", \"carModel\");\r\n     *  console.log(obj);\r\n     *  // { carBrand: \"Ford\", carModel: \"Mustang\" }\r\n     */\r\n    rename(notation, newNotation, overwrite) {\r\n        if (!newNotation) return this;\r\n        return this.moveTo(this._source, notation, newNotation, overwrite);\r\n    }\r\n    /**\r\n     *  Alias for `#rename`\r\n     *  @private\r\n     */\r\n    renote(notation, newNotation, overwrite) {\r\n        return this.rename(notation, newNotation, overwrite);\r\n    }\r\n\r\n    /**\r\n     *  Extracts the property at the given notation to a new object by copying\r\n     *  it from the source object. This is equivalent to `.copyTo({}, notation, newNotation)`.\r\n     *  @alias Notation#copyToNew\r\n     *\r\n     *  @param {String} notation - The notation to get the corresponding\r\n     *  property (value) from the source object.\r\n     *  @param {String} newNotation - The new notation to be set on the new\r\n     *  object for the targeted property value. If not set, `notation` argument\r\n     *  will be used.\r\n     *\r\n     *  @returns {Object} - Returns a new object with the notated property.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  const extracted = Notation.create(obj).extract(\"car.brand\", \"carBrand\");\r\n     *  console.log(extracted);\r\n     *  // { carBrand: \"Ford\" }\r\n     *  // obj is not modified\r\n     */\r\n    extract(notation, newNotation) {\r\n        let o = {};\r\n        this.copyTo(o, notation, newNotation);\r\n        return o;\r\n    }\r\n    /**\r\n     *  Alias for `#extract`\r\n     *  @private\r\n     */\r\n    copyToNew(notation, newNotation) {\r\n        return this.extract(notation, newNotation);\r\n    }\r\n\r\n    /**\r\n     *  Extrudes the property at the given notation to a new object by moving\r\n     *  it from the source object. This is equivalent to `.moveTo({}, notation, newNotation)`.\r\n     *  @alias Notation#moveToNew\r\n     *\r\n     *  @param {String} notation - The notation to get the corresponding\r\n     *  property (value) from the source object.\r\n     *  @param {String} newNotation - The new notation to be set on the new\r\n     *  object for the targeted property value. If not set, `notation` argument\r\n     *  will be used.\r\n     *\r\n     *  @returns {Object} - Returns a new object with the notated property.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  const extruded = Notation.create(obj).extrude(\"car.brand\", \"carBrand\");\r\n     *  console.log(obj);\r\n     *  // { car: { model: \"Mustang\" } }\r\n     *  console.log(extruded);\r\n     *  // { carBrand: \"Ford\" }\r\n     */\r\n    extrude(notation, newNotation) {\r\n        let o = {};\r\n        this.moveTo(o, notation, newNotation);\r\n        return o;\r\n    }\r\n    /**\r\n     *  Alias for `#extrude`\r\n     *  @private\r\n     */\r\n    moveToNew(notation, newNotation) {\r\n        return this.extrude(notation, newNotation);\r\n    }\r\n\r\n    // --------------------------------\r\n    // Notation Static Methods\r\n    // --------------------------------\r\n\r\n    /**\r\n     *  Basically constructs a new `Notation` instance with the given object.\r\n     *  @chainable\r\n     *\r\n     *  @param {Object} [object={}] - The object to be notated.\r\n     *\r\n     *  @returns {Notation} - The created instance.\r\n     *\r\n     *  @example\r\n     *  const notation = Notation.create(obj);\r\n     *  // equivalent to:\r\n     *  const notation = new Notation(obj);\r\n     */\r\n    static create(object = {}) {\r\n        return new Notation(object);\r\n    }\r\n\r\n    /**\r\n     *  Checks whether the given notation string is valid. Note that the star\r\n     *  (`*`) (which is a valid character, even if irregular) is NOT treated as\r\n     *  wildcard here. This checks for normal dot-notation, not a glob-notation.\r\n     *  For glob notation validation, use `Notation.Glob.isValid()` method. Same\r\n     *  goes for the negation character/prefix (`!`).\r\n     *\r\n     *  Note that, even though `obj['some.name']` is possible in JS, dot (`.`) is\r\n     *  always treated as a level (property) separator in Notation strings.\r\n     *\r\n     *  @param {String} notation - The notation string to be checked.\r\n     *\r\n     *  @returns {Boolean}\r\n     *\r\n     *  @example\r\n     *  Notation.isValid('prop1.prop2.prop3'); // true\r\n     *  Notation.isValid('prop1'); // true\r\n     *  Notation.isValid('prop.*'); // true (but star is not treated as wildcard)\r\n     *  Notation.isValid('@1'); // true (bec. obj['@1'] is possible in JS.)\r\n     *  Notation.isValid(null); // false\r\n     */\r\n    static isValid(notation) {\r\n        return (typeof notation === 'string') &&\r\n            (/^[^\\s.!]+((\\.[^\\s.!]+)|(\\[([0-9]+|\\*)\\]))*$/).test(notation);\r\n    }\r\n\r\n    /**\r\n     *  Counts the number of notes/levels in the given notation.\r\n     *  @alias Notation.countLevels\r\n     *\r\n     *  @param {*} notation - The notation string to be processed.\r\n     *\r\n     *  @returns {Number}\r\n     */\r\n    static countNotes(notation) {\r\n        if (!Notation.isValid(notation)) {\r\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\r\n        }\r\n        return notation.split(/\\.|(?=\\[)/).length;\r\n    }\r\n    /**\r\n     *  Alias of `Notation.countNotes`.\r\n     *  @private\r\n     */\r\n    static countLevels(notation) {\r\n        return Notation.countNotes(notation);\r\n    }\r\n\r\n    /**\r\n     *  Gets the first (root) note of the notation string.\r\n     *\r\n     *  @param {String} notation - The notation string to be processed.\r\n     *\r\n     *  @returns {String}\r\n     *\r\n     *  @example\r\n     *  Notation.first('first.prop2.last'); // \"first\"\r\n     */\r\n    static first(notation) {\r\n        if (!Notation.isValid(notation)) {\r\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\r\n        }\r\n        // return notation.replace(/.*\\.([^\\.]*$)/, '$1');\r\n        return notation.split(/\\.|(?=\\[)/)[0];\r\n    }\r\n\r\n    /**\r\n     *  Gets the last note of the notation string.\r\n     *\r\n     *  @param {String} notation - The notation string to be processed.\r\n     *\r\n     *  @returns {String}\r\n     *\r\n     *  @example\r\n     *  Notation.last('first.prop2.last'); // \"last\"\r\n     */\r\n    static last(notation) {\r\n        if (!Notation.isValid(notation)) {\r\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\r\n        }\r\n        // return notation.replace(/.*\\.([^\\.]*$)/, '$1');\r\n        return notation.split(/\\.|(?=\\[)/).reverse()[0];\r\n    }\r\n\r\n    /**\r\n     *  Gets the parent notation (up to but excluding the last note)\r\n     *  from the notation string.\r\n     *\r\n     *  @param {String} notation - The notation string to be processed.\r\n     *\r\n     *  @returns {String}\r\n     *\r\n     *  @example\r\n     *  Notation.parent('first.prop2.last'); // \"first.prop2\"\r\n     *  Notation.parent('single'); // null\r\n     */\r\n    static parent(notation) {\r\n        if (!Notation.isValid(notation)) {\r\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\r\n        }\r\n        return notation.match(/\\.|\\[/) !== null\r\n            ? notation.replace(/(\\.|.\\[)[^.[]*$/, '')\r\n            : null;\r\n    }\r\n\r\n    /**\r\n     *  Iterates through each note/level of the given notation string.\r\n     *  @alias Notation.eachLevel\r\n     *\r\n     *  @param {String} notation - The notation string to be iterated through.\r\n     *  @param {Function} callback - The callback function to be invoked on\r\n     *  each iteration. To break out of the loop, return `false` from within the\r\n     *  callback.\r\n     *  Callback signature: `callback(levelNotation, note, index, list) { ... }`\r\n     *\r\n     *  @returns {void}\r\n     *\r\n     *  @example\r\n     *  const notation = 'first.prop2.last';\r\n     *  Notation.eachNote(notation, function (levelNotation, note, index, list) {\r\n     *      console.log(index, note, levelNotation);\r\n     *  });\r\n     *  // 0  \"first\"             \"first\"\r\n     *  // 1  \"first.prop2\"       \"prop2\"\r\n     *  // 2  \"first.prop2.last\"  \"last\"\r\n     */\r\n    static eachNote(notation, callback) {\r\n        if (!Notation.isValid(notation)) {\r\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\r\n        }\r\n        let notes = notation.split(/\\.|(?=\\[)/),\r\n            levelNotes = [],\r\n            levelNotation;\r\n        utils.each(notes, (note, index, list) => {\r\n            levelNotes.push(note);\r\n\r\n            levelNotation = levelNotes.join('.').replace(/\\.\\[/, '[');\r\n\r\n            if (callback(levelNotation, note, index, notes) === false) return false;\r\n        }, Notation);\r\n    }\r\n    /**\r\n     *  Alias of `Notation.eachNote`.\r\n     *  @private\r\n     */\r\n    static eachLevel(notation, callback) {\r\n        Notation.eachNote(notation, callback);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n *  Error class specific to `Notation`.\r\n *  @private\r\n *\r\n *  @class\r\n *  @see `{@link #Notation.Error}`\r\n */\r\nNotation.Error = NotationError;\r\n\r\n/**\r\n *  Utility for validating, comparing and sorting dot-notation globs.\r\n *  This is internally used by `Notation` class.\r\n *  @private\r\n *\r\n *  @class\r\n *  @see `{@link #Notation.Glob}`\r\n */\r\nNotation.Glob = NotationGlob;\r\n\r\n// --------------------------------\r\n// EXPORT\r\n// --------------------------------\r\n\r\nexport default Notation;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/notation.js","import utils from '../utils';\r\nimport NotationError from './notation.error';\r\n\r\n// http://www.linfo.org/wildcard.html\r\n// http://en.wikipedia.org/wiki/Glob_%28programming%29\r\n// http://en.wikipedia.org/wiki/Wildcard_character#Computing\r\n\r\n/**\r\n *  `Notation.Glob` is a utility for validating, comparing and sorting\r\n *  dot-notation globs.\r\n *\r\n *  You can use {@link http://www.linfo.org/wildcard.html|wildcard} stars `*`\r\n *  and negate the notation by prepending a bang `!`. A star will include all\r\n *  the properties at that level and a negated notation will be excluded.\r\n *  @name Notation.Glob\r\n *  @memberof! Notation\r\n *  @class\r\n *\r\n *  @example\r\n *  // for the following object;\r\n *  { name: 'John', billing: { account: { id: 1, active: true } } };\r\n *\r\n *  'billing.account.*'  // represents value `{ id: 1, active: true }`\r\n *  'billing.account.id' // represents value `1`\r\n *  '!billing.account.*' // represents value `{ name: 'John' }`\r\n *  'name' // represents `'John'`\r\n *  '*' // represents the whole object\r\n *\r\n *  @example\r\n *  var glob = new Notation.Glob('billing.account.*');\r\n *  glob.test('billing.account.id'); // true\r\n */\r\nclass NotationGlob {\r\n\r\n    /**\r\n     *  Constructs a `Notation.Glob` object with the given glob string.\r\n     *  @constructs Notation.Glob\r\n     *\r\n     *  @param {String} glob - The glob string.\r\n     */\r\n    constructor(glob) {\r\n        if (!NotationGlob.isValid(glob)) {\r\n            throw new NotationError('Invalid notation glob: \"' + glob + '\"');\r\n        }\r\n\r\n        let ng = NotationGlob.inspect(glob);\r\n        this._ = {\r\n            glob,\r\n            absGlob: ng.absGlob,\r\n            isNegated: ng.isNegated,\r\n            regexp: NotationGlob.toRegExp(ng.absGlob),\r\n            levels: ng.absGlob.split(/\\.|(?=\\[)/)\r\n        };\r\n    }\r\n\r\n    // --------------------------------\r\n    // NotationGlob Instance Properties\r\n    // --------------------------------\r\n\r\n    /**\r\n     *  Gets the original glob notation string.\r\n     *  @name Notation.Glob#glob\r\n     *  @type {String}\r\n     */\r\n    get glob() {\r\n        return this._.glob;\r\n    }\r\n\r\n    /**\r\n     *  Gets the absolute glob notation (without the preceeding bang `!`).\r\n     *  @name Notation.Glob#absGlob\r\n     *  @type {String}\r\n     */\r\n    get absGlob() {\r\n        return this._.absGlob;\r\n    }\r\n\r\n    /**\r\n     *  Specifies whether this glob is negated with a `!` prefix.\r\n     *  @name Notation.Glob#isNegated\r\n     *  @type {Boolean}\r\n     */\r\n    get isNegated() {\r\n        return this._.isNegated;\r\n    }\r\n\r\n    /**\r\n     *  Represents this glob in regular expressions.\r\n     *  Note that the negation (`!`) is ignored, if any.\r\n     *  @name Notation.Glob#regexp\r\n     *  @type {RegExp}\r\n     */\r\n    get regexp() {\r\n        return this._.regexp;\r\n    }\r\n\r\n    /**\r\n     *  List of notes/levels of this glob notation.\r\n     *  @name Notation.Glob#notes\r\n     *  @alias Notation.Glob#levels\r\n     *  @type {Array}\r\n     */\r\n    get notes() {\r\n        return this._.levels;\r\n    }\r\n    /**\r\n     *  Alias of `Notation.Glob#notes`.\r\n     *  @private\r\n     */\r\n    get levels() {\r\n        return this._.levels;\r\n    }\r\n\r\n    // --------------------------------\r\n    // NotationGlob Instance Methods\r\n    // --------------------------------\r\n\r\n    /**\r\n     *  Checks whether the given notation value matches the source notation glob.\r\n     *  @name Notation.Glob#test\r\n     *  @function\r\n     *\r\n     *  @param {String} notation - The notation string to be tested.\r\n     *\r\n     *  @returns {Boolean}\r\n     *\r\n     *  @example\r\n     *  const glob = new Notation.Glob('!prop.*.name');\r\n     *  glob.test(\"prop.account.name\"); // true\r\n     */\r\n    test(notation) {\r\n        // we allow '*' to match everything. We check for this here\r\n        // instead of the regexp bec. we care for dots (.) within the glob.\r\n        return this.absGlob === '*'\r\n            || (this.absGlob !== '' && notation !== '' && this.regexp.test(notation));\r\n    }\r\n\r\n    // --------------------------------\r\n    // NotationGlob Static Members\r\n    // --------------------------------\r\n\r\n    /**\r\n     *  Basically constructs a new `NotationGlob` instance\r\n     *  with the given glob string.\r\n     *  @name Notation.Glob.create\r\n     *  @function\r\n     *\r\n     *  @param {String} glob - The source notation glob.\r\n     *\r\n     *  @returns {NotationGlob}\r\n     *\r\n     *  @example\r\n     *  const glob = Notation.Glob.create(strGlob);\r\n     *  // equivalent to:\r\n     *  const glob = new Notation.Glob(strGlob);\r\n     */\r\n    static create(glob) {\r\n        return new NotationGlob(glob);\r\n    }\r\n\r\n    /**\r\n     *  Gets a regular expressions instance from the given glob notation.\r\n     *  Note that the bang `!` prefix will be ignored if the given glob is negated.\r\n     *  @name Notation.Glob.toRegExp\r\n     *  @function\r\n     *\r\n     *  @param {String} glob - Glob notation to be converted.\r\n     *\r\n     *  @returns {RegExp}\r\n     */\r\n    static toRegExp(glob) {\r\n        if (glob.indexOf('!') === 0) glob = glob.slice(1);\r\n        // Modified from http://stackoverflow.com/a/13818704/112731\r\n        glob = utils.pregQuote(glob)\r\n            .replace(/\\\\\\*/g, '[^\\\\s\\\\.[\\\\]]+')\r\n            .replace(/\\\\\\?/g, '.');\r\n        return new RegExp('^' + glob + '((\\\\.|\\\\[).+|$)');\r\n        // it should either end ($) or continue with a dot or a square bracket. So for example,\r\n        // `company.*` will produce `/^company\\.[^\\s\\.]*/` which will match both\r\n        // `company.name` and `company.address.street` but will not match\r\n        // `some.company.name`. Also `!password` will not match `!password_reset`.\r\n        //\r\n    }\r\n\r\n    /**\r\n     *  @private\r\n     */\r\n    static inspect(glob) {\r\n        let bang = glob.slice(0, 1) === '!';\r\n        glob = bang ? glob.slice(1) : glob;\r\n        return {\r\n            absGlob: glob,\r\n            isNegated: bang\r\n        };\r\n    }\r\n\r\n    // Created test at: https://regex101.com/r/tJ7yI9/4\r\n    /**\r\n     *  Validates the given notation glob.\r\n     *  @name Notation.Glob.isValid\r\n     *  @function\r\n     *\r\n     *  @param {String} glob - Notation glob to be validated.\r\n     *  @returns {Boolean}\r\n     */\r\n    static isValid(glob) {\r\n        return (typeof glob === 'string')\r\n            && (/^(!?([^\\s.!*\\[\\]]+|\\*)((\\.([^\\s.!*\\[\\]]+|\\*))|(\\[([0-9]+|\\*)\\]))*)$/).test(glob);\r\n    }\r\n\r\n    /**\r\n     *  Compares two given notation globs and returns an integer value as a\r\n     *  result. This is generally used to sort glob arrays. Loose globs (with\r\n     *  stars especially closer to beginning of the glob string) and globs\r\n     *  representing the parent/root of the compared property glob come first.\r\n     *  Verbose/detailed/exact globs come last. (`* < *abc < abc`).\r\n     *\r\n     *  For instance; `store.address` comes before `store.address.street`. So\r\n     *  this works both for `*, store.address.street, !store.address` and `*,\r\n     *  store.address, !store.address.street`. For cases such as `prop.id` vs\r\n     *  `!prop.id` which represent the same property; the negated glob wins\r\n     *  (comes last).\r\n     *  @name Notation.Glob.compare\r\n     *  @function\r\n     *\r\n     *  @param {String} a - First notation glob to be compared.\r\n     *  @param {String} b - Second notation glob to be compared.\r\n     *\r\n     *  @returns {Number} - Returns `-1` if `a` comes first, `1` if `b` comes\r\n     *  first and `0` if equivalent priority.\r\n     *\r\n     *  @example\r\n     *  let result = Notation.Glob.compare('prop.*.name', 'prop.*');\r\n     *  console.log(result); // 1\r\n     */\r\n    static compare(a, b) {\r\n        // trivial case, both are exactly the same!\r\n        if (a === b) return 0;\r\n        let levelsA = a.split(/\\.|(?=\\[)/),\r\n            levelsB = b.split(/\\.|(?=\\[)/);\r\n        // Check depth (number of levels)\r\n        if (levelsA.length === levelsB.length) {\r\n            // count wildcards (assuming more wildcards comes first)\r\n            let wild = /(?:^|\\.)\\*(?:$|\\.)|\\[\\*\\]/g,\r\n                mA = a.match(wild),\r\n                mB = b.match(wild),\r\n                wildA = mA ? mA.length : 0,\r\n                wildB = mB ? mB.length : 0;\r\n            if (wildA === wildB) {\r\n                // check for negation\r\n                let negA = a.indexOf('!') === 0,\r\n                    negB = b.indexOf('!') === 0;\r\n                if (negA === negB) {\r\n                    // both are negated or neither are, just return alphabetical\r\n                    return a < b ? -1 : 1;\r\n                }\r\n                // compare without the negatation\r\n                let nonNegA = negA ? a.slice(1) : a,\r\n                    nonNegB = negB ? b.slice(1) : b;\r\n                if (nonNegA === nonNegB) {\r\n                    return negA ? 1 : -1;\r\n                }\r\n                return nonNegA < nonNegB ? -1 : 1;\r\n            }\r\n            return wildA > wildB ? -1 : 1;\r\n        }\r\n\r\n        return levelsA.length < levelsB.length ? -1 : 1;\r\n    }\r\n\r\n    /**\r\n     *  Sorts the notation globs in the given array by their priorities. Loose\r\n     *  globs (with stars especially closer to beginning of the glob string);\r\n     *  globs representing the parent/root of the compared property glob come\r\n     *  first. Verbose/detailed/exact globs come last. (`* < *abc < abc`).\r\n     *\r\n     *  For instance; `store.address` comes before `store.address.street`. For\r\n     *  cases such as `prop.id` vs `!prop.id` which represent the same property;\r\n     *  the negated glob wins (comes last).\r\n     *  @name Notation.Glob.sort\r\n     *  @function\r\n     *\r\n     *  @param {Array} globsArray - The notation globs array to be sorted. The\r\n     *  passed array reference is modified.\r\n     *\r\n     *  @returns {Array}\r\n     *\r\n     *  @example\r\n     *  const globs = ['!prop.*.name', 'prop.*', 'prop.id'];\r\n     *  const sorted = Notation.Glob.sort(globs);\r\n     *  console.log(sorted);\r\n     *  // ['prop.*', 'prop.id', '!prop.*.name'];\r\n     */\r\n    static sort(globsArray) {\r\n        return globsArray.sort(NotationGlob.compare);\r\n        // return _mergeSortArray(globsArray, NotationGlob.compare);\r\n    }\r\n\r\n    /**\r\n     *  Normalizes the given notation globs array by removing duplicate or\r\n     *  redundant items and returns a priority-sorted globs array.\r\n     *\r\n     *  <ul>\r\n     *  <li>If any exact duplicates found, all except first is removed.</li>\r\n     *  <li>If both normal and negated versions of a glob are found, negated wins.\r\n     *  <br />example: `['id', '!id']` normalizes to `['!id']`.</li>\r\n     *  <li>If a glob is covered by another, it's removed.\r\n     *  <br />example: `['car.*', 'car.model']` normalizes to `['car.*']`.</li>\r\n     *  <li>If a glob is covered by another negated glob, it's kept.\r\n     *  <br />example: `['*', '!car.*', 'car.model']` normalizes as is.</li>\r\n     *  <li>If a negated glob is covered by another glob, it's also kept.\r\n     *  <br />example: `['car.*', '!car.model']` normalizes as is.</li>\r\n     *  </ul>\r\n     *  @name Notation.Glob.normalize\r\n     *  @function\r\n     *\r\n     *  @param {Array} globsArray - Notation globs array to be normalized.\r\n     *\r\n     *  @returns {Array}\r\n     *\r\n     *  @example\r\n     *  const globs = ['*', '!id', 'name', 'car.model', '!car.*', 'id', 'name', 'age'];\r\n     *  const normalized = Notation.Glob.normalize(globs);\r\n     *  console.log(normalized);\r\n     *  // ['*', '!car.*', '!id', 'car.model']\r\n     */\r\n    static normalize(globsArray) {\r\n        debugger\r\n        globsArray = utils.ensureArray(globsArray).map(item => item.trim());\r\n        globsArray = NotationGlob.sort(globsArray);\r\n\r\n        utils.eachRight(globsArray, (globA, indexA) => {\r\n\r\n            // example #1:\r\n            // ['*', '!id', 'name', 'car.model', '!car.*', 'id', 'name']\r\n            // => ['*', '!id', '!car.*', 'car.model']\r\n\r\n            // example #2:\r\n            // ['!id', 'name', 'car.model', '!car.*', 'id', '!email']\r\n            // => ['!car.*', 'car.model', 'name']\r\n\r\n            let insA = NotationGlob.inspect(globA);\r\n            // console.log(' • ', globA, '=>', globsArray);\r\n\r\n            let duplicate = false;\r\n            let hasExactNegative = false;\r\n            let negCoversNeg = false;\r\n            let noPosCoversNeg = true;\r\n            let posCoversPos = false;\r\n            let noNegCoversPos = true;\r\n\r\n            // inspect/compare the current glob with the rest of the array\r\n            utils.eachRight(globsArray, (globB, indexB) => {\r\n                // don't inspect glob with itself\r\n                if (indexB === indexA) return; // no break, move to next\r\n\r\n                let insB = NotationGlob.inspect(globB);\r\n                let reB = NotationGlob.toRegExp(insB.absGlob);\r\n\r\n                // console.log(globA, 'vs', globB);\r\n\r\n                // (A) remove if duplicate\r\n                if (globA === globB) {\r\n                    duplicate = true;\r\n                    return false; // break\r\n                }\r\n\r\n                // (B) remove if positive has an exact negative\r\n                // e.g. ['prop', '!prop'] => ['!prop']\r\n                // negated wins when normalized\r\n                if (insB.isNegated && globA === insB.absGlob) {\r\n                    hasExactNegative = true;\r\n                    return false; // break\r\n                }\r\n\r\n                // (C) remove negated if:\r\n                //    1) any negative covers it\r\n                //       ['!a.b', '!a.*']  => '!a.b' is removed\r\n                //    2) no positive covers it\r\n                //       ['!a.b', 'a.c']   => '!a.b' is removed\r\n\r\n                // (D) remove positive if:\r\n                //    1) any positive covers it AND no negative covers it\r\n                //       ['*', 'a.b']            => 'a.b' is removed\r\n                //       ['*', 'a.b', '!a.*']    => 'a.b' is kept\r\n\r\n                if (insA.isNegated) {\r\n                    if (insB.isNegated && reB.test(insA.absGlob)) {\r\n                        negCoversNeg = true;\r\n                        return false; // break\r\n                    } else if (noPosCoversNeg && reB.test(insA.absGlob)) {\r\n                        noPosCoversNeg = false;\r\n                    }\r\n                } else { // if (!insA.isNegated)\r\n                    if (!insB.isNegated && reB.test(insA.absGlob)) {\r\n                        posCoversPos = true;\r\n                    } else if (noNegCoversPos && reB.test(insA.absGlob)) {\r\n                        noNegCoversPos = false;\r\n                    }\r\n                }\r\n\r\n            });\r\n\r\n            let redundant = insA.isNegated\r\n                ? (negCoversNeg || noPosCoversNeg)\r\n                : (posCoversPos && noNegCoversPos);\r\n\r\n            if (duplicate || hasExactNegative || redundant) {\r\n                // remove the current (at the end)\r\n                debugger\r\n                globsArray.splice(indexA, 1);\r\n            }\r\n\r\n        });\r\n\r\n        // since negated wins in the same array, ['*', '!*'] is already reduced\r\n        // to ['!*'] so we can safely remove !* if found, since it's redundant.\r\n        // e.g. ['!*', 'name'] => ['name']\r\n        let i = globsArray.indexOf('!*');\r\n        if (i >= 0) globsArray.splice(i, 1);\r\n\r\n        return globsArray;\r\n    }\r\n\r\n    /**\r\n     *  Gets the union from the given couple of glob arrays and returns\r\n     *  a new array of globs.\r\n     *  <ul>\r\n     *  <li>If the exact same element is found in both\r\n     *  arrays, one of them is removed to prevent duplicates.\r\n     *  <br />example: `['!id', 'name'] ∪ ['!id']` unites to `['!id', 'name']`</li>\r\n     *  <li>If any non-negated item is covered by a glob in the same\r\n     *  or other array, the redundant item is removed.\r\n     *  <br />example: `['*', 'name'] ∪ ['email']` unites to `['*']`</li>\r\n     *  <li>If one of the arrays contains a negated equivalent of an\r\n     *  item in the other array, the negated item is removed.\r\n     *  <br />example: `['!id'] ∪ ['id']` unites to `['id']`</li>\r\n     *  <li>If any item covers/matches a negated item in the other array,\r\n     *  the negated item is removed.\r\n     *  <br />example #1: `['!user.id'] ∪ ['user.*']` unites to `['user.*']`\r\n     *  <br />example #2: `['*'] ∪ ['!password']` unites to `['*']`\r\n     *  </li>\r\n     *  <li>So on... For a better understanding read the inline code\r\n     *  documentation.</li>\r\n     *  </ul>\r\n     *  @name Notation.Glob.union\r\n     *  @function\r\n     *\r\n     *  @param {Array} globsA - First array of glob strings.\r\n     *  @param {Array} globsB - Second array of glob strings.\r\n     *\r\n     *  @returns {Array}\r\n     *\r\n     *  @example\r\n     *  const a = ['foo.bar', 'bar.baz', '!*.qux'];\r\n     *  const b = ['!foo.bar', 'bar.qux', 'bar.baz'];\r\n     *  const union = Notation.Glob.union(a, b);\r\n     *  console.log(union);\r\n     *  // ['!*.qux', 'foo.bar', 'bar.baz', 'bar.qux']\r\n     */\r\n    static union(globsA, globsB) {\r\n        // NOTE: The logic here is quite complex. For making this easier to\r\n        // understand; below code is written a bit verbose. Do not modify this\r\n        // only to make it shorter. This will already get minified.\r\n\r\n        // -----------------------\r\n\r\n        // if any of the arrays has a single glob item of only a wildcard (e.g.\r\n        // `['*']`); this covers all, so...\r\n        if (utils.hasSingleItemOf(globsA, '*') || utils.hasSingleItemOf(globsB, '*')) {\r\n            return ['*'];\r\n        }\r\n\r\n        // clone arrays so we don't mutate the originals.\r\n        const arrA = globsA.concat();\r\n        const arrB = globsB.concat();\r\n        // no need to normalize. we'll do it at the end.\r\n\r\n        let reA, reB, insA, insB;\r\n\r\n        // storage for tracking (winner) negated globs that are compared with\r\n        // another negated in the other array. For example:\r\n        // ['*', '!user.*'] ∪ ['*', '!user.id']\r\n        // '!user.id' should be kept in the union when compared with '!user.*'.\r\n        // but later, '!user.id' will be unioned with '*' in the other array\r\n        // which will cover and remove '!user.id'. so we'll keep a storage for\r\n        // to prevent this.\r\n        let keepNegated = [];\r\n\r\n        // iterate through array A\r\n        utils.eachRight(arrA, (a, aIndex) => {\r\n            insA = NotationGlob.inspect(a);\r\n            reA = NotationGlob.toRegExp(insA.absGlob);\r\n\r\n            // iterate through array B for each item in A\r\n            utils.eachRight(arrB, (b, bIndex) => {\r\n                insB = NotationGlob.inspect(b);\r\n                reB = NotationGlob.toRegExp(insB.absGlob);\r\n\r\n                // console.log(a, 'vs', b);\r\n\r\n                if (insA.isNegated && !insB.isNegated) {\r\n                    // if we have the non-negated version of the same glob in B,\r\n                    // we'll remove item in A. In union, non-negated wins\r\n                    // (unlike normalize — in normalize, negated wins within the\r\n                    // same array).\r\n                    if (insA.absGlob === insB.absGlob) {\r\n                        arrA.splice(aIndex, 1);\r\n                        // console.log(`${a} removed: ${a} reverses ${b}`);\r\n                        // console.log(arrA, '∪', arrB);\r\n                        return false; // break from B\r\n                    }\r\n\r\n                    // remove the negated from A only if the same value is not in B.\r\n                    // e.g. 1)  ['!x.y'] ∪ ['x.*'] => ['x.*']\r\n                    // e.g. 2)  ['!x.y'] ∪ ['x.*', '!x.y'] => ['x.*', '!x.y']\r\n                    if (reB.test(insA.absGlob) && arrB.indexOf(a) === -1 && keepNegated.indexOf(a) === -1) {\r\n                        arrA.splice(aIndex, 1);\r\n                        // console.log(`${a} removed: ${b} covers ${a}`);\r\n                        // console.log(arrA, '∪', arrB);\r\n                        return false; // break from B\r\n                    }\r\n                }\r\n\r\n                if (!insA.isNegated && insB.isNegated) {\r\n                    // if we have the non-negated version of the same glob in A,\r\n                    // we'll remove item in B.\r\n                    if (insA.absGlob === insB.absGlob) {\r\n                        arrB.splice(bIndex, 1);\r\n                        // console.log(`${b} removed: ${b} reverses ${a}`);\r\n                        // console.log(arrA, '∪', arrB);\r\n                        return; // move to next in B\r\n                    }\r\n\r\n                    // remove the negated from B only if the same value is not in A.\r\n                    // e.g. 1)  ['!x.y'] ∪ ['x.*'] => ['x.*']\r\n                    // e.g. 2)  ['!x.y'] ∪ ['x.*', '!x.y'] => ['x.*', '!x.y']\r\n                    if (reA.test(insB.absGlob) && arrA.indexOf(b) === -1 && keepNegated.indexOf(b) === -1) {\r\n                        arrB.splice(bIndex, 1);\r\n                        // console.log(`${b} removed: ${a} covers ${b}`);\r\n                        // console.log(arrA, '∪', arrB);\r\n                        return; // move to next in B\r\n                    }\r\n                }\r\n\r\n                if (insA.isNegated && insB.isNegated) {\r\n                    // if both A and B are negated and NOT equal, we'll check\r\n                    // for coverage over one or the other.\r\n                    if (a !== b) {\r\n                        // if B covers A, we'll remove from B.\r\n                        // e.g. '!user.*' covers '!user.id'\r\n                        if (reB.test(insA.absGlob)) {\r\n                            arrB.splice(bIndex, 1);\r\n                            keepNegated.push(a);\r\n                            // console.log(`${b} removed: ${a} neg-covers ${b}`);\r\n                            // console.log(arrA, '∪', arrB);\r\n                            return; // move to next in B\r\n                        }\r\n                        // if A covers B, we'll remove from A.\r\n                        if (reA.test(insB.absGlob)) {\r\n                            arrA.splice(aIndex, 1);\r\n                            keepNegated.push(b);\r\n                            // console.log(`${a} removed: ${b} neg-covers ${a}`);\r\n                            // console.log(arrA, '∪', arrB);\r\n                            return false; // break from B\r\n                        }\r\n                    }\r\n                    // else, if they are equal, we'll not remove any bec. it\r\n                    // means both arrays disalow that glob.\r\n                }\r\n\r\n                if (!insA.isNegated && !insB.isNegated) {\r\n                    // if both A and B are NOT negated and equal, we'll remove\r\n                    // from A.\r\n                    if (a === b) {\r\n                        arrA.splice(aIndex, 1);\r\n                        // console.log(`${a} removed: ${a} === ${b}`);\r\n                        // console.log(arrA, '∪', arrB);\r\n                        return false;\r\n                    }\r\n\r\n                    // else -> (a !== b)\r\n\r\n                    // Leave the rest to the normalizing process\r\n                    // (Notation.Glob.normalize) bec. when both A and B are\r\n                    // non-negated, the one which is covered by the other will\r\n                    // be removed incorrectly.\r\n\r\n                    // For example:\r\n                    // ['!x.y'] ∪ ['x.*'] => ['x.*']\r\n                    // ['*', '!x.*'] ∪ ['*', '!x.*', 'x.o']\r\n                    // '*' in A will cover and remove 'x.o' in B incorrectly bec.\r\n                    // 'x.o' is a remainder from '!x.*' which is both in A and B.\r\n\r\n                    // So when this is left as is; the final union before\r\n                    // normalizing is: ['*', '!x.*', '*', 'x.o']\r\n                    // normalized to:  ['*', '!x.*', 'x.o']\r\n\r\n                    // if (reB.test(insA.absGlob)) {\r\n                    //     arrA.splice(aIndex, 1);\r\n                    //     console.log(`${a} removed: ${b} covers ${a}`);\r\n                    //     console.log(arrA, '∪', arrB);\r\n                    //     return false;\r\n                    // }\r\n                    // if (reA.test(insB.absGlob)) {\r\n                    //     arrB.splice(bIndex, 1);\r\n                    //     console.log(`${b} removed: ${a} covers ${b}`);\r\n                    //     console.log(arrA, '∪', arrB);\r\n                    //     return;\r\n                    // }\r\n                }\r\n\r\n            });\r\n        });\r\n\r\n        // concat both arrays, normalize and sort so we get a nice union array.\r\n        const result = arrA.concat(arrB);\r\n        return NotationGlob.normalize(result);\r\n    }\r\n\r\n}\r\n\r\nexport default NotationGlob;\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/notation.glob.js"],"sourceRoot":""}