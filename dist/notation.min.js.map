{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///notation.min.js","webpack:///webpack/bootstrap 80292894717aa3d3badd","webpack:///./src/index.js","webpack:///./src/core/Notation.js","webpack:///./src/lib/utils.js","webpack:///./src/core/notation.glob.js","webpack:///./src/core/notation.error.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_Notation","_Notation2","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_utils","_utils2","_notation","_notation2","_notation3","_notation4","ERR","SOURCE","DEST","NOTATION","NOTA_OBJ","Notation","object","undefined","isObject","source_","callback","o","keys","each","index","list","N","prop","eachKey","notation","nKey","subKey","isValid","level","eachNote","levelNotation","note","hasOwn","push","getFlat","result","has","lastNote","indexOf","upToLast","parent","last","inspect","defaultValue","overwrite","notationsObject","set","notationsArray","isArray","inspectRemove","globNotations","original","copy","deepCopy","stringOrArrayOf","arguments","filtered","globs","sort","concat","shift","g","endStar","normalized","globNotation","array","slice","isNegated","remove","copyFrom","originalNotation","test","destination","newNotation","moveTo","rename","copyTo","extract","extrude","get","split","reverse","replace","notes","levelNotes","join","Error","Glob","toString","utils","hasOwnProperty","k","thisArg","eachRight","pregQuote","str","delimiter","String","RegExp","NotationGlob","glob","ng","normalize","regexp","toRegExp","levels","opts","bang","a","b","levelsA","levelsB","wild","mA","match","mB","wildA","wildB","negA","negB","nonNegA","nonNegB","globsArray","compare","arrA","arrB","nonegA","re","bIndex","ia","splice","ib","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","NotationError","_Error","message","_this","getPrototypeOf","name","captureStackTrace","stack"],"mappings":"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","file":"notation.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"notation\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"notation\"] = factory();\n\telse\n\t\troot[\"notation\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"notation\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"notation\"] = factory();\n\telse\n\t\troot[\"notation\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _Notation = __webpack_require__(1);\n\t\n\tvar _Notation2 = _interopRequireDefault(_Notation);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// export default Notation;\n\t// http://stackoverflow.com/a/33683495/112731\n\tmodule.exports = _Notation2.default;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tvar _utils2 = _interopRequireDefault(_utils);\n\t\n\tvar _notation = __webpack_require__(3);\n\t\n\tvar _notation2 = _interopRequireDefault(_notation);\n\t\n\tvar _notation3 = __webpack_require__(4);\n\t\n\tvar _notation4 = _interopRequireDefault(_notation3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// TODO:\n\t// templates? ${some.property}\n\t// Error if source object has flattened (dotted) keys.\n\t// expand if dotted keyed object is passed to constructor?\n\t\n\tvar ERR = {\n\t    SOURCE: 'Invalid source object.',\n\t    DEST: 'Invalid destination object.',\n\t    NOTATION: 'Invalid notation: ',\n\t    NOTA_OBJ: 'Invalid notations object: '\n\t};\n\t\n\t/**\n\t *  Notation.js for Node and Browser.\n\t *\n\t *  Provides various methods for modifying / processing the contents\n\t *  of the given object; by parsing object notation strings or globs.\n\t *  Note that this class will only deal with enumerable properties of the\n\t *  source object; so it should be used to manipulate data objects. It will\n\t *  not deal with preserving the prototype-chain of the given object.\n\t *\n\t *  @version  0.7.0 (2015-05-05)\n\t *  @author   Onur Yıldırım (onur@cutepilot.com)\n\t *  @license  MIT\n\t */\n\t\n\tvar Notation = function () {\n\t\n\t    /**\n\t     *  Initializes a new instance of `Notation`.\n\t     *\n\t     *  @param {Object} object - The source object to be notated.\n\t     *\n\t     *  @return {Notation}\n\t     *\n\t     *  @example\n\t     *  var assets = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n\t     *  var notaAssets = new Notation(assets);\n\t     *  notaAssets.get('car.model'); // \"Charger\"\n\t     */\n\t\n\t    function Notation(object) {\n\t        _classCallCheck(this, Notation);\n\t\n\t        // if not defined, default to `{}`\n\t        object = object === undefined ? {} : object;\n\t        // if defined, it should be an object.\n\t        if (!_utils2.default.isObject(object)) {\n\t            throw new _notation4.default(ERR.SOURCE);\n\t        }\n\t        this.source_ = object;\n\t    }\n\t\n\t    // --------------------------------\n\t    // Notation Instance Properties\n\t    // --------------------------------\n\t\n\t    /**\n\t     *  Gets the value of the source object.\n\t     *\n\t     *  @return {Object} - The source object.\n\t     *\n\t     *  @example\n\t     *  var o = { name: \"Onur\" };\n\t     *  var me = Notation.create(o)\n\t     *      .set(\"age\", 36)\n\t     *      .set(\"car.brand\", \"Ford\")\n\t     *      .set(\"car.model\", \"Mustang\")\n\t     *      .value;\n\t     *  console.log(me);\n\t     *  // { name: \"Onur\", age: 36, car: { brand: \"Ford\", model: \"Mustang\" } }\n\t     *  console.log(o === me);\n\t     *  // true\n\t     */\n\t\n\t\n\t    _createClass(Notation, [{\n\t        key: 'eachKey',\n\t\n\t\n\t        // --------------------------------\n\t        // Notation Instance Methods\n\t        // --------------------------------\n\t\n\t        /**\n\t         *  Recursively iterates through each key of the source object and invokes\n\t         *  the given callback function with parameters, on each non-object value.\n\t         *\n\t         *  @param {Function} callback - The callback function to be invoked on\n\t         *      each on each non-object value. To break out of the loop, return\n\t         *      `false` from within the callback.\n\t         *      Callback signature: `callback(notation, key, value, object) { ... }`\n\t         *\n\t         *  @return {void}\n\t         *\n\t         *  @example\n\t         *  var assets = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n\t         *  Notation.create(assets).eachKey(function (notation, key, value, object) {\n\t         *      console.log(notation, value);\n\t         *  });\n\t         *  // \"car.brand\"  \"Dodge\"\n\t         *  // \"car.model\"  \"Charger\"\n\t         *  // \"car.year\"  1970\n\t         */\n\t        value: function eachKey(callback) {\n\t            var o = this.source_,\n\t                keys = Object.keys(o);\n\t            _utils2.default.each(keys, function (key, index, list) {\n\t                var prop = o[key],\n\t                    N;\n\t                if (_utils2.default.isObject(prop)) {\n\t                    N = new Notation(prop);\n\t                    N.eachKey(function (notation, nKey, value, prop) {\n\t                        var subKey = key + '.' + notation;\n\t                        callback.call(this, subKey, nKey, value, o);\n\t                    });\n\t                } else {\n\t                    callback.call(this, key, key, prop, o);\n\t                }\n\t            }, this);\n\t        }\n\t\n\t        /**\n\t         *  Iterates through each note of the given notation string by evaluating\n\t         *  it on the source object.\n\t         *\n\t         *  @param {String} notation - The notation string to be iterated through.\n\t         *  @param {Function} callback - The callback function to be invoked on\n\t         *      each iteration. To break out of the loop, return `false` from\n\t         *      within the callback.\n\t         *      Callback signature: `callback(levelValue, note, index, list) { ... }`\n\t         *\n\t         *  @return {void}\n\t         *\n\t         *  @example\n\t         *  var assets = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n\t         *  Notation.create(assets)\n\t         *      .eachNoteValue(\"car.brand\", function (levelValue, note, index, list) {\n\t         *          console.log(note, levelValue); // \"car.brand\" \"Dodge\"\n\t         *      });\n\t         */\n\t\n\t    }, {\n\t        key: 'eachNoteValue',\n\t        value: function eachNoteValue(notation, callback) {\n\t            if (!Notation.isValid(notation)) {\n\t                throw new _notation4.default(ERR.NOTATION + '`' + notation + '`');\n\t            }\n\t            var level = this.source_;\n\t            Notation.eachNote(notation, function (levelNotation, note, index, list) {\n\t                level = _utils2.default.hasOwn(level, note) ? level[note] : undefined;\n\t                if (callback(level, levelNotation, note, index, list) === false) return false;\n\t            });\n\t        }\n\t\n\t        /**\n\t         *  Gets the list of notations from the source object (keys).\n\t         *\n\t         *  @return {Array} - An array of notation strings.\n\t         *\n\t         *  @example\n\t         *  var assets = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n\t         *  var notationsList = Notation.create(assets).getNotations();\n\t         *  // [ \"car.brand\", \"car.model\", \"car.year\" ]\n\t         */\n\t\n\t    }, {\n\t        key: 'getNotations',\n\t        value: function getNotations() {\n\t            var list = [];\n\t            this.eachKey(function (notation, key, value, obj) {\n\t                list.push(notation);\n\t            });\n\t            return list;\n\t        }\n\t\n\t        /**\n\t         *  Gets a flat (single-level) object with notated keys, from the source object.\n\t         *  @alias Notation#getMap\n\t         *\n\t         *  @return {Object} - A new object with flat, notated keys.\n\t         *\n\t         *  @example\n\t         *  var assets = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n\t         *  var flat = Notation.create(assets).getFlat();\n\t         *  // { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\n\t         */\n\t\n\t    }, {\n\t        key: 'getFlat',\n\t        value: function getFlat() {\n\t            var o = {};\n\t            this.eachKey(function (notation, key, value, obj) {\n\t                o[notation] = value;\n\t            });\n\t            return o;\n\t        }\n\t        /**\n\t         *  Alias for `#getFlat`\n\t         *  @private\n\t         */\n\t\n\t    }, {\n\t        key: 'getMap',\n\t        value: function getMap() {\n\t            return this.getFlat();\n\t        }\n\t\n\t        /**\n\t         *  Inspects the given notation on the source object by checking\n\t         *  if the source object actually has the notated property;\n\t         *  and getting its value if exists.\n\t         *\n\t         *  @param {String} notation - The notation string to be inspected.\n\t         *\n\t         *  @return {Object} - The result object has the following properties:\n\t         *      `result.has` {Boolean}  Indicates whether the source object\n\t         *          has the given notation as a (leveled) enumerable property.\n\t         *          If the property exists but has a value of `undefined`,\n\t         *          this will still return `true`.\n\t         *      `result.value` {*}  The value of the notated property.\n\t         *          if the source object does not have the notation,\n\t         *          the value will be `undefined`.\n\t         *\n\t         *  @example\n\t         *  Notation.create({ car: { year: 1970 } }).inspect(\"car.year\");\n\t         *  // { has: true, value: 1970 }\n\t         *  Notation.create({ car: { year: 1970 } }).inspect(\"car.color\");\n\t         *  // { has: false, value: undefined }\n\t         *  Notation.create({ car: { color: undefined } }).inspect(\"car.color\");\n\t         *  // { has: true, value: undefined }\n\t         */\n\t\n\t    }, {\n\t        key: 'inspect',\n\t        value: function inspect(notation) {\n\t            if (!Notation.isValid(notation)) {\n\t                throw new _notation4.default(ERR.NOTATION + '`' + notation + '`');\n\t            }\n\t            var level = this.source_,\n\t                result = { has: false, value: undefined };\n\t            Notation.eachNote(notation, function (levelNotation, note, index, list) {\n\t                if (_utils2.default.hasOwn(level, note)) {\n\t                    level = level[note];\n\t                    result = { has: true, value: level };\n\t                } else {\n\t                    // level = undefined;\n\t                    result = { has: false, value: undefined };\n\t                    return false; // break out\n\t                }\n\t            });\n\t            return result;\n\t        }\n\t\n\t        /**\n\t         *  Inspects and removes the given notation from the source object\n\t         *  by checking if the source object actually has the notated property;\n\t         *  and getting its value if exists, before removing the property.\n\t         *\n\t         *  @param {String} notation - The notation string to be inspected.\n\t         *\n\t         *  @return {Object} - The result object has the following properties:\n\t         *      `result.has` {Boolean}  Indicates whether the source object\n\t         *          has the given notation as a (leveled) enumerable property.\n\t         *          If the property exists but has a value of `undefined`,\n\t         *          this will still return `true`.\n\t         *      `result.value` {*}  The value of the removed property.\n\t         *          if the source object does not have the notation,\n\t         *          the value will be `undefined`.\n\t         *\n\t         *  @example\n\t         *  var obj = { name: \"John\", car: { year: 1970 } };\n\t         *  Notation.create(obj).inspectRemove(\"car.year\"); // { has: true, value: 1970 }\n\t         *  // obj » { name: \"John\", car: {} }\n\t         *  Notation.create(obj).inspectRemove(\"car.year\", true); // { has: true, value: 1970 }\n\t         *  // obj » { name: \"John\" }\n\t         *  Notation.create({ car: { year: 1970 } }).inspectRemove(\"car.color\");\n\t         *  // { has: false, value: undefined }\n\t         *  Notation.create({ car: { color: undefined } }).inspectRemove(\"car.color\");\n\t         *  // { has: true, value: undefined }\n\t         */\n\t\n\t    }, {\n\t        key: 'inspectRemove',\n\t        value: function inspectRemove(notation) {\n\t            if (!Notation.isValid(notation)) {\n\t                throw new _notation4.default(ERR.NOTATION + '`' + notation + '`');\n\t            }\n\t            var o, lastNote;\n\t            if (notation.indexOf('.') < 0) {\n\t                lastNote = notation;\n\t                o = this.source_;\n\t            } else {\n\t                var upToLast = Notation.parent(notation);\n\t                lastNote = Notation.last(notation);\n\t                o = this.inspect(upToLast).value;\n\t            }\n\t            var result;\n\t            if (_utils2.default.hasOwn(o, lastNote)) {\n\t                result = { has: true, value: o[lastNote] };\n\t                delete o[lastNote];\n\t            } else {\n\t                result = { has: false, value: undefined };\n\t            }\n\t\n\t            return result;\n\t        }\n\t\n\t        /**\n\t         *  Checks whether the source object has the given notation\n\t         *  as a (leveled) enumerable property. If the property exists\n\t         *  but has a value of `undefined`, this will still return `true`.\n\t         *\n\t         *  @param {String} notation - The notation string to be checked.\n\t         *\n\t         *  @return {Boolean}\n\t         *\n\t         *  @example\n\t         *  Notation.create({ car: { year: 1970 } }).has(\"car.year\"); // true\n\t         *  Notation.create({ car: { year: undefined } }).has(\"car.year\"); // true\n\t         *  Notation.create({}).has(\"car.color\"); // false\n\t         */\n\t\n\t    }, {\n\t        key: 'has',\n\t        value: function has(notation) {\n\t            return this.inspect(notation).has;\n\t        }\n\t\n\t        /**\n\t         *  Checks whether the source object has the given notation\n\t         *  as a (leveled) defined enumerable property. If the property\n\t         *  exists but has a value of `undefined`, this will return `false`.\n\t         *\n\t         *  @param {String} notation - The notation string to be checked.\n\t         *\n\t         *  @return {Boolean}\n\t         *\n\t         *  @example\n\t         *  Notation.create({ car: { year: 1970 } }).hasDefined(\"car.year\"); // true\n\t         *  Notation.create({ car: { year: undefined } }).hasDefined(\"car.year\"); // false\n\t         *  Notation.create({}).hasDefined(\"car.color\"); // false\n\t         */\n\t\n\t    }, {\n\t        key: 'hasDefined',\n\t        value: function hasDefined(notation) {\n\t            return this.inspect(notation).value !== undefined;\n\t        }\n\t\n\t        /**\n\t         *  Gets the value of the corresponding property at the given\n\t         *  notation.\n\t         *\n\t         *  @param {String} notation - The notation string to be processed.\n\t         *  @param {String} defaultValue - Optional. Default: `undefined`\n\t         *      The default value to be returned if the property is not\n\t         *      found or enumerable.\n\t         *\n\t         *  @return {*} - The value of the notated property.\n\t         *\n\t         *  @example\n\t         *  Notation.create({ car: { brand: \"Dodge\" } }).get(\"car.brand\"); // \"Dodge\"\n\t         *  Notation.create({ car: {} }).get(\"car.model\"); // undefined\n\t         *  Notation.create({ car: {} }).get(\"car.model\", \"Challenger\"); // \"Challenger\"\n\t         *  Notation.create({ car: { model: undefined } }).get(\"car.model\", \"Challenger\"); // undefined\n\t         */\n\t\n\t    }, {\n\t        key: 'get',\n\t        value: function get(notation, defaultValue) {\n\t            var result = this.inspect(notation);\n\t            return !result.has ? defaultValue : result.value;\n\t        }\n\t\n\t        /**\n\t         *  Sets the value of the corresponding property at the given\n\t         *  notation. If the property does not exist, it will be created\n\t         *  and nested at the calculated level. If it exists; its value\n\t         *  will be overwritten by default.\n\t         *\n\t         *  @param {String} notation - The notation string to be processed.\n\t         *  @param {*} value - The value to be set for the notated property.\n\t         *  @param {Boolean} overwrite - Optional. Default: `true`\n\t         *      Whether to overwrite the property if exists.\n\t         *\n\t         *  @return {Notation} - Returns the current `Notation` instance (self).\n\t         *\n\t         *  @example\n\t         *  var assets = { car: { brand: \"Dodge\", year: 1970 } };\n\t         *  Notation.create(assets)\n\t         *      .set(\"car.brand\", \"Ford\")\n\t         *      .set(\"car.model\", \"Mustang\")\n\t         *      .set(\"car.year\", 1965, false)\n\t         *      .set(\"car.color\", \"red\")\n\t         *      .set(\"boat\", \"none\");\n\t         *  console.log(assets);\n\t         *  // { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" } };\n\t         */\n\t\n\t    }, {\n\t        key: 'set',\n\t        value: function set(notation, value, overwrite) {\n\t            if (!Notation.isValid(notation)) {\n\t                throw new _notation4.default(ERR.NOTATION + '`' + notation + '`');\n\t            }\n\t            overwrite = typeof overwrite === 'boolean' ? overwrite : true;\n\t            var level = this.source_,\n\t                last;\n\t            Notation.eachNote(notation, function (levelNotation, note, index, list) {\n\t                last = index === list.length - 1;\n\t                // check if the property is at this level\n\t                if (_utils2.default.hasOwn(level, note)) {\n\t                    // check if we're at the last level\n\t                    if (last) {\n\t                        // if overwrite is set, assign the value.\n\t                        if (overwrite) level[note] = value;\n\t                    } else {\n\t                        // if not, just re-reference the current level.\n\t                        level = level[note];\n\t                    }\n\t                } else {\n\t                    // we don't have this property at this level\n\t                    // so; if this is the last level, we set the value\n\t                    // if not, we set an empty object for the next level\n\t                    level = level[note] = last ? value : {};\n\t                }\n\t            });\n\t            return this;\n\t        }\n\t\n\t        /**\n\t         *  Just like the `.set()` method but instead of a single notation\n\t         *  string, an object of notations and values can be passed.\n\t         *  Sets the value of each corresponding property at the given\n\t         *  notation. If a property does not exist, it will be created\n\t         *  and nested at the calculated level. If it exists; its value\n\t         *  will be overwritten by default.\n\t         *\n\t         *  @param {Object} notationsObject - The notations object to be processed.\n\t         *      This can either be a regular object with non-dotted keys\n\t         *      (which will be merged to the first/root level of the source object);\n\t         *      or a flattened object with notated (dotted) keys.\n\t         *\n\t         *  @param {Boolean} overwrite - Optional. Default: `true`\n\t         *      Whether to overwrite a property if exists.\n\t         *\n\t         *  @return {Notation} - Returns the current `Notation` instance (self).\n\t         *\n\t         *  @example\n\t         *  var assets = { car: { brand: \"Dodge\", year: 1970 } };\n\t         *  Notation.create(assets)\n\t         *      .merge({\n\t         *          \"car.brand\": \"Ford\",\n\t         *          \"car.model\": \"Mustang\",\n\t         *          \"car.year\": 1965, false,\n\t         *          \"car.color\": \"red\",\n\t         *          \"boat\": \"none\"\n\t         *      });\n\t         *  console.log(assets);\n\t         *  // { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" } };\n\t         */\n\t\n\t    }, {\n\t        key: 'merge',\n\t        value: function merge(notationsObject, overwrite) {\n\t            if (!_utils2.default.isObject(notationsObject)) {\n\t                throw new _notation4.default(ERR.NOTA_OBJ + '`' + notationsObject + '`');\n\t            }\n\t            var value;\n\t            _utils2.default.each(Object.keys(notationsObject), function (notation, index, obj) {\n\t                value = notationsObject[notation];\n\t                this.set(notation, value, overwrite);\n\t            }, this);\n\t            return this;\n\t        }\n\t\n\t        /**\n\t         *  Removes the properties by the given list of notations from the source\n\t         *  object and returns a new object with the removed properties.\n\t         *  Opposite of `merge()` method.\n\t         *\n\t         *  @param {Array} notationsArray - The notations array to be processed.\n\t         *\n\t         *  @return {Object} - An object with the removed properties.\n\t         *\n\t         *  @example\n\t         *  var assets = { car: { brand: \"Dodge\", year: 1970 }, notebook: \"Mac\" };\n\t         *  var separated = Notation.create(assets).separate([\"car.brand\", \"boat\" ]);\n\t         *  console.log(separated);\n\t         *  // { notebook: \"Mac\", car: { brand: \"Ford\" } };\n\t         *  console.log(assets);\n\t         *  // { car: { year: 1970 } };\n\t         */\n\t\n\t    }, {\n\t        key: 'separate',\n\t        value: function separate(notationsArray) {\n\t            if (!_utils2.default.isArray(notationsArray)) {\n\t                throw new _notation4.default(ERR.NOTA_OBJ + '`' + notationsArray + '`');\n\t            }\n\t            var o = new Notation({});\n\t            _utils2.default.each(notationsArray, function (notation, index, obj) {\n\t                var result = this.inspectRemove(notation);\n\t                o.set(notation, result.value);\n\t            }, this);\n\t            return o.source_;\n\t        }\n\t\n\t        // iterate globs\n\t        // remove non-star negated globs directly\n\t        // get non-star part iterate thru obj keys\n\t\n\t        /**\n\t         *  Deep clones the source object while filtering its properties\n\t         *  by the given glob notations. Includes all matched properties\n\t         *  and removes the rest.\n\t         *\n\t         *  @param {Array|String} globNotations - The glob notation(s) to\n\t         *      be processed. The difference between normal notations and\n\t         *      glob-notations is that you can use wildcard stars (*) and\n\t         *      negate the notation by prepending a bang (!). A negated\n\t         *      notation will be excluded. Order of the globs do not matter,\n\t         *      they will be logically sorted. Loose globs will be processed\n\t         *      first and verbose globs or normal notations will be processed\n\t         *      last. e.g. `[ \"car.model\", \"*\", \"!car.*\" ]` will be sorted as\n\t         *      `[ \"*\", \"!car.*\", \"car.model\" ]`.\n\t         *      Passing no parameters or passing an empty string (`\"\"` or `[\"\"]`)\n\t         *      will empty the source object.\n\t         *\n\t         *  @return {Notation} - Returns the current `Notation` instance (self).\n\t         *\n\t         *  @example\n\t         *  var assets = { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" } };\n\t         *  var nota = Notation.create(assets);\n\t         *  nota.filter([ \"*\", \"!car.*\", \"car.model\" ]);\n\t         *  console.log(assets); // { notebook: \"Mac\", car: { model: \"Mustang\" } }\n\t         *  nota.filter(\"*\");\n\t         *  console.log(assets); // { notebook: \"Mac\", car: { model: \"Mustang\" } }\n\t         *  nota.filter(); // or nota.filter(\"\");\n\t         *  console.log(assets); // {}\n\t         */\n\t\n\t    }, {\n\t        key: 'filter',\n\t        value: function filter(globNotations) {\n\t            var original = this.value,\n\t                copy = _utils2.default.deepCopy(original);\n\t            // if globNotations is \"*\" or [\"*\"] set the \"copy\" as source and\n\t            // return.\n\t            if (_utils2.default.stringOrArrayOf(globNotations, '*')) {\n\t                this.source_ = copy;\n\t                return this;\n\t            }\n\t            // if globNotations is \"\" or [\"\"] set source to `{}` and return.\n\t            if (arguments.length === 0 || _utils2.default.stringOrArrayOf(globNotations, '')) {\n\t                this.source_ = {};\n\t                return this;\n\t            }\n\t            var globs = _utils2.default.isArray(globNotations)\n\t            // sort the globs in logical order. we also concat the array first\n\t            // bec. we'll change it's content via `.shift()`\n\t            ? _notation2.default.sort(globNotations.concat()) : [globNotations];\n\t            var filtered;\n\t            // if the first item of sorted globs is \"*\" we set the source to the\n\t            // (full) \"copy\" and remove the \"*\" from globs (not to re-process).\n\t            if (globs[0] === '*') {\n\t                filtered = new Notation(copy);\n\t                globs.shift();\n\t            } else {\n\t                // otherwise we set an empty object as the source so that we can\n\t                // add notations/properties to it.\n\t                filtered = new Notation({});\n\t            }\n\t            var g, endStar, normalized;\n\t            // iterate through globs\n\t            _utils2.default.each(globs, function (globNotation, index, array) {\n\t                g = new _notation2.default(globNotation);\n\t                // set flag that indicates whether the glob ends with `.*`\n\t                endStar = g.normalized.slice(-2) === '.*';\n\t                // get the remaining part as the (extra) normalized glob\n\t                normalized = endStar ? g.normalized.slice(0, -2) : g.normalized;\n\t                // check if normalized glob has no wildcard stars e.g. \"a.b\" or\n\t                // \"!a.b.c\" etc..\n\t                if (normalized.indexOf('*') < 0) {\n\t                    if (g.isNegated) {\n\t                        // directly remove the notation if negated\n\t                        filtered.remove(normalized);\n\t                        // if original glob had `.*` at the end, it means remove\n\t                        // contents (not itself). so we'll set an empty object.\n\t                        // meaning `some.prop` (prop) is removed completely but\n\t                        // `some.prop.*` (prop) results in `{}`.\n\t                        if (endStar) filtered.set(normalized, {}, true);\n\t                    } else {\n\t                        // directly copy the same notation from the original\n\t                        filtered.copyFrom(original, normalized, null, true);\n\t                    }\n\t                    // move to the next\n\t                    return true;\n\t                }\n\t                // if glob has wildcard star(s), we'll iterate through keys of the\n\t                // source object and see if (full) notation of each key matches\n\t                // the current glob.\n\t\n\t                // TODO: Optimize the loop below. Instead of checking each key's\n\t                // notation, get the non-star left part of the glob and iterate\n\t                // that property of the source object.\n\t                this.eachKey(function (originalNotation, key, value, obj) {\n\t                    // console.log(originalNotation, key);\n\t                    if (g.test(originalNotation)) {\n\t                        if (g.isNegated) {\n\t                            filtered.remove(originalNotation);\n\t                        } else {\n\t                            filtered.set(originalNotation, value, true);\n\t                        }\n\t                    }\n\t                });\n\t            }, this);\n\t            // finally set the filtered's value as the source of our instance and\n\t            // return.\n\t            this.source_ = filtered.value;\n\t            return this;\n\t        }\n\t\n\t        // store.partners.*\n\t        // *.host » iterate original obj\n\t        // store.*.host » iterate store obj\n\t\n\t        // TODO: remove support for char-star. e.g. `prop1.prop*2`\n\t\n\t        /**\n\t         *  Removes the property at the given notation, from the source object.\n\t         *\n\t         *  @param {String} notation - The notation to be inspected.\n\t         *\n\t         *  @return {Notation} - Returns the current `Notation` instance (self).\n\t         *\n\t         *  @example\n\t         *  var assets = { notebook: \"Mac\", car: { model: \"Mustang\" } };\n\t         *  Notation.create(assets).remove(\"car.model\");\n\t         *  console.log(assets); // { notebook: \"Mac\", car: { } }\n\t         */\n\t\n\t    }, {\n\t        key: 'remove',\n\t        value: function remove(notation) {\n\t            this.inspectRemove(notation);\n\t            return this;\n\t        }\n\t        // Notation.prototype.delete = Notation.prototype.remove;\n\t\n\t    }, {\n\t        key: 'clone',\n\t        value: function clone() {\n\t            var o = _utils2.default.deepCopy(this.value);\n\t            return new Notation(o);\n\t        }\n\t\n\t        /**\n\t         *  Copies the notated property from the source object and adds it to the\n\t         *  destination — only if the source object actually has that property.\n\t         *  This is different than a property with a value of `undefined`.\n\t         *\n\t         *  @param {Object} destination - The destination object that the notated\n\t         *      properties will be copied to.\n\t         *  @param {String} notation - The notation to get the corresponding property\n\t         *      from the source object.\n\t         *  @param {String} newNotation - Optional. The notation to set the source\n\t         *      property on the destination object. In other words, the copied property\n\t         *      will be renamed to this value before set on the destination object.\n\t         *      If not set, `notation` argument will be used.\n\t         *  @param {Boolean} overwrite - Optional. Default: `true`\n\t         *      Whether to overwrite the property on the destination object if it exists.\n\t         *\n\t         *  @return {Notation} - Returns the current `Notation` instance (self).\n\t         *\n\t         *  @example\n\t         *  var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n\t         *  var models = { dodge: \"Charger\" };\n\t         *  Notation.create(assets).copyTo(models, \"car.model\", \"ford\");\n\t         *  console.log(models);\n\t         *  // { dodge: \"Charger\", ford: \"Mustang\" }\n\t         *  // assets object is not modified\n\t         */\n\t\n\t    }, {\n\t        key: 'copyTo',\n\t        value: function copyTo(destination, notation, newNotation, overwrite) {\n\t            if (!_utils2.default.isObject(destination)) throw new _notation4.default(ERR.DEST);\n\t            var result = this.inspect(notation);\n\t            if (result.has) {\n\t                new Notation(destination).set(newNotation || notation, result.value, overwrite);\n\t            }\n\t            return this;\n\t        }\n\t\n\t        /**\n\t         *  Copies the notated property from the destination object and adds it to the\n\t         *  source object — only if the destination object actually has that property.\n\t         *  This is different than a property with a value of `undefined`.\n\t         *\n\t         *  @param {Object} destination - The destination object that the notated\n\t         *      properties will be copied from.\n\t         *  @param {String} notation - The notation to get the corresponding property\n\t         *      from the destination object.\n\t         *  @param {String} newNotation - Optional. The notation to set the destination\n\t         *      property on the source object. In other words, the copied property\n\t         *      will be renamed to this value before set on the source object.\n\t         *      If not set, `notation` argument will be used.\n\t         *  @param {Boolean} overwrite - Optional. Default: `true`\n\t         *      Whether to overwrite the property on the source object if it exists.\n\t         *\n\t         *  @return {Notation} - Returns the current `Notation` instance (self).\n\t         *\n\t         *  @example\n\t         *  var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n\t         *  var models = { dodge: \"Charger\" };\n\t         *  Notation.create(assets).copyFrom(models, \"dodge\", \"car.model\", true);\n\t         *  console.log(assets);\n\t         *  // { car: { brand: \"Ford\", model: \"Charger\" } }\n\t         *  // models object is not modified\n\t         */\n\t\n\t    }, {\n\t        key: 'copyFrom',\n\t        value: function copyFrom(destination, notation, newNotation, overwrite) {\n\t            if (!_utils2.default.isObject(destination)) throw new _notation4.default(ERR.DEST);\n\t            var result = new Notation(destination).inspect(notation);\n\t            if (result.has) {\n\t                this.set(newNotation || notation, result.value, overwrite);\n\t            }\n\t            return this;\n\t        }\n\t\n\t        /**\n\t         *  Removes the notated property from the source object and adds it to the\n\t         *  destination — only if the source object actually has that property.\n\t         *  This is different than a property with a value of `undefined`.\n\t         *\n\t         *  @param {Object} destination - The destination object that the notated\n\t         *      properties will be moved to.\n\t         *  @param {String} notation - The notation to get the corresponding property\n\t         *      from the source object.\n\t         *  @param {String} newNotation - Optional. The notation to set the source\n\t         *      property on the destination object. In other words, the moved property\n\t         *      will be renamed to this value before set on the destination object.\n\t         *      If not set, `notation` argument will be used.\n\t         *  @param {Boolean} overwrite - Optional. Default: `true`\n\t         *      Whether to overwrite the property on the destination object if it exists.\n\t         *\n\t         *  @return {Notation} - Returns the current `Notation` instance (self).\n\t         *\n\t         *  @example\n\t         *  var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n\t         *  var models = { dodge: \"Charger\" };\n\t         *  Notation.create(assets).moveTo(models, \"car.model\", \"ford\");\n\t         *  console.log(assets);\n\t         *  // { car: { brand: \"Ford\" } }\n\t         *  console.log(models);\n\t         *  // { dodge: \"Charger\", ford: \"Mustang\" }\n\t         */\n\t\n\t    }, {\n\t        key: 'moveTo',\n\t        value: function moveTo(destination, notation, newNotation, overwrite) {\n\t            if (!_utils2.default.isObject(destination)) throw new _notation4.default(ERR.DEST);\n\t            var result = this.inspectRemove(notation);\n\t            if (result.has) {\n\t                new Notation(destination).set(newNotation || notation, result.value, overwrite);\n\t            }\n\t            return this;\n\t        }\n\t\n\t        /**\n\t         *  Removes the notated property from the destination object and adds it to the\n\t         *  source object — only if the destination object actually has that property.\n\t         *  This is different than a property with a value of `undefined`.\n\t         *\n\t         *  @param {Object} destination - The destination object that the notated\n\t         *      properties will be moved from.\n\t         *  @param {String} notation - The notation to get the corresponding property\n\t         *      from the destination object.\n\t         *  @param {String} newNotation - Optional. The notation to set the destination\n\t         *      property on the source object. In other words, the moved property\n\t         *      will be renamed to this value before set on the source object.\n\t         *      If not set, `notation` argument will be used.\n\t         *  @param {Boolean} overwrite - Optional. Default: `true`\n\t         *      Whether to overwrite the property on the source object if it exists.\n\t         *\n\t         *  @return {Notation} - Returns the current `Notation` instance (self).\n\t         *\n\t         *  @example\n\t         *  var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n\t         *  var models = { dodge: \"Charger\" };\n\t         *  Notation.create(assets).moveFrom(models, \"dodge\", \"car.model\", true);\n\t         *  console.log(assets);\n\t         *  // { car: { brand: \"Ford\", model: \"Charger\" } }\n\t         *  console.log(models);\n\t         *  // {}\n\t         */\n\t\n\t    }, {\n\t        key: 'moveFrom',\n\t        value: function moveFrom(destination, notation, newNotation, overwrite) {\n\t            if (!_utils2.default.isObject(destination)) throw new _notation4.default(ERR.DEST);\n\t            var result = new Notation(destination).inspectRemove(notation);\n\t            if (result.has) {\n\t                this.set(newNotation || notation, result.value, overwrite);\n\t            }\n\t            return this;\n\t        }\n\t\n\t        /**\n\t         *  Renames the notated property of the source object by the new notation.\n\t         *  @alias Notation#renote\n\t         *\n\t         *  @param {String} notation - The notation to get the corresponding property\n\t         *      (value) from the source object.\n\t         *  @param {String} newNotation - The new notation for the targeted property.\n\t         *      value. If not set, the source object will not be modified.\n\t         *  @param {Boolean} overwrite - Optional. Default: `true`\n\t         *      Whether to overwrite the property at the new notation, if it exists.\n\t         *\n\t         *  @return {Notation} - Returns the current `Notation` instance (self).\n\t         *\n\t         *  @example\n\t         *  var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n\t         *  Notation.create(assets)\n\t         *      .rename(\"car.brand\", \"carBrand\")\n\t         *      .rename(\"car.model\", \"carModel\");\n\t         *  console.log(assets);\n\t         *  // { carBrand: \"Ford\", carModel: \"Mustang\" }\n\t         */\n\t\n\t    }, {\n\t        key: 'rename',\n\t        value: function rename(notation, newNotation, overwrite) {\n\t            if (!newNotation) return this;\n\t            return this.moveTo(this.source_, notation, newNotation, overwrite);\n\t        }\n\t        /**\n\t         *  Alias for `#rename`\n\t         *  @private\n\t         */\n\t\n\t    }, {\n\t        key: 'renote',\n\t        value: function renote(notation, newNotation, overwrite) {\n\t            return this.rename(notation, newNotation, overwrite);\n\t        }\n\t\n\t        /**\n\t         *  Extracts the property at the given notation to a new object by copying\n\t         *  it from the source object. This is equivalent to `.copyTo({}, notation, newNotation)`.\n\t         *  @alias Notation#copyToNew\n\t         *\n\t         *  @param {String} notation - The notation to get the corresponding property\n\t         *      (value) from the source object.\n\t         *  @param {String} newNotation - The new notation to be set on the new object\n\t         *      for the targeted property value. If not set, `notation` argument will\n\t         *      be used.\n\t         *\n\t         *  @return {Object} - Returns a new object with the notated property.\n\t         *\n\t         *  @example\n\t         *  var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n\t         *  var extracted = Notation.create(assets).extract(\"car.brand\", \"carBrand\");\n\t         *  console.log(extracted);\n\t         *  // { carBrand: \"Ford\" }\n\t         *  // assets object is not modified\n\t         */\n\t\n\t    }, {\n\t        key: 'extract',\n\t        value: function extract(notation, newNotation) {\n\t            var o = {};\n\t            this.copyTo(o, notation, newNotation);\n\t            return o;\n\t        }\n\t        /**\n\t         *  Alias for `#extract`\n\t         *  @private\n\t         */\n\t\n\t    }, {\n\t        key: 'copyToNew',\n\t        value: function copyToNew(notation, newNotation) {\n\t            return this.extract(notation, newNotation);\n\t        }\n\t\n\t        /**\n\t         *  Extrudes the property at the given notation to a new object by moving\n\t         *  it from the source object. This is equivalent to `.moveTo({}, notation, newNotation)`.\n\t         *  @alias Notation#moveToNew\n\t         *\n\t         *  @param {String} notation - The notation to get the corresponding property\n\t         *      (value) from the source object.\n\t         *  @param {String} newNotation - The new notation to be set on the new object\n\t         *      for the targeted property value. If not set, `notation` argument will\n\t         *      be used.\n\t         *\n\t         *  @return {Object} - Returns a new object with the notated property.\n\t         *\n\t         *  @example\n\t         *  var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n\t         *  var extruded = Notation.create(assets).extrude(\"car.brand\", \"carBrand\");\n\t         *  console.log(assets);\n\t         *  // { car: { model: \"Mustang\" } }\n\t         *  console.log(extruded);\n\t         *  // { carBrand: \"Ford\" }\n\t         */\n\t\n\t    }, {\n\t        key: 'extrude',\n\t        value: function extrude(notation, newNotation) {\n\t            var o = {};\n\t            this.moveTo(o, notation, newNotation);\n\t            return o;\n\t        }\n\t        /**\n\t         *  Alias for `#extrude`\n\t         *  @private\n\t         */\n\t\n\t    }, {\n\t        key: 'moveToNew',\n\t        value: function moveToNew(notation, newNotation) {\n\t            return this.extrude(notation, newNotation);\n\t        }\n\t\n\t        // --------------------------------\n\t        // Notation Static Methods\n\t        // --------------------------------\n\t\n\t        /**\n\t         *  Basically constructs a new `Notation` instance\n\t         *  with the given object.\n\t         *\n\t         *  @param {Object} object - The object to be notated.\n\t         *\n\t         *  @return {Notation}\n\t         *\n\t         *  @example\n\t         *  var notaObj = Notation.create(obj);\n\t         *  // equivalent to:\n\t         *  var notaObj = new Notation(obj);\n\t         */\n\t\n\t    }, {\n\t        key: 'value',\n\t        get: function get() {\n\t            return this.source_;\n\t        }\n\t    }], [{\n\t        key: 'create',\n\t        value: function create(object) {\n\t            return new Notation(object);\n\t        }\n\t\n\t        /**\n\t         *  Checks whether the given notation string is valid.\n\t         *\n\t         *  @param {String} notation - The notation string to be checked.\n\t         *\n\t         *  @return {Boolean}\n\t         *\n\t         *  @example\n\t         *  Notation.isValid('prop1.prop2.prop3'); // true\n\t         *  Notation.isValid('prop1'); // true\n\t         *  Notation.isValid(null); // false\n\t         */\n\t\n\t    }, {\n\t        key: 'isValid',\n\t        value: function isValid(notation) {\n\t            return typeof notation === 'string' && /^[^\\s\\.!]+(\\.[^\\s\\.!]+)*$/.test(notation);\n\t        }\n\t\n\t        /**\n\t         *  Gets the first (root) note of the notation string.\n\t         *\n\t         *  @param {String} notation - The notation string to be processed.\n\t         *\n\t         *  @return {String}\n\t         *\n\t         *  @example\n\t         *  Notation.first('first.prop2.last'); // \"first\"\n\t         */\n\t\n\t    }, {\n\t        key: 'first',\n\t        value: function first(notation) {\n\t            if (!Notation.isValid(notation)) {\n\t                throw new _notation4.default(ERR.NOTATION + '`' + notation + '`');\n\t            }\n\t            // return notation.replace(/.*\\.([^\\.]*$)/, '$1');\n\t            return notation.split('.')[0];\n\t        }\n\t\n\t        /**\n\t         *  Gets the last note of the notation string.\n\t         *\n\t         *  @param {String} notation - The notation string to be processed.\n\t         *\n\t         *  @return {String}\n\t         *\n\t         *  @example\n\t         *  Notation.last('first.prop2.last'); // \"last\"\n\t         */\n\t\n\t    }, {\n\t        key: 'last',\n\t        value: function last(notation) {\n\t            if (!Notation.isValid(notation)) {\n\t                throw new _notation4.default(ERR.NOTATION + '`' + notation + '`');\n\t            }\n\t            // return notation.replace(/.*\\.([^\\.]*$)/, '$1');\n\t            return notation.split('.').reverse()[0];\n\t        }\n\t\n\t        /**\n\t         *  Gets the parent notation (up to but excluding the last note)\n\t         *  from the notation string.\n\t         *\n\t         *  @param {String} notation - The notation string to be processed.\n\t         *\n\t         *  @return {String}\n\t         *\n\t         *  @example\n\t         *  Notation.parent('first.prop2.last'); // \"first.prop2\"\n\t         *  Notation.parent('single'); // null\n\t         */\n\t\n\t    }, {\n\t        key: 'parent',\n\t        value: function parent(notation) {\n\t            if (!Notation.isValid(notation)) {\n\t                throw new _notation4.default(ERR.NOTATION + '`' + notation + '`');\n\t            }\n\t            return notation.indexOf('.') >= 0 ? notation.replace(/\\.[^\\.]*$/, '') : null;\n\t        }\n\t\n\t        /**\n\t         *  Iterates through each note of the given notation string.\n\t         *\n\t         *  @param {String} notation - The notation string to be iterated through.\n\t         *  @param {Function} callback - The callback function to be invoked on\n\t         *      each iteration. To break out of the loop, return `false` from\n\t         *      within the callback.\n\t         *      Callback signature: `callback(levelNotation, note, index, list) { ... }`\n\t         *\n\t         *  @return {void}\n\t         *\n\t         *  @example\n\t         *  Notation.eachNote(\"first.prop2.last\", function (levelNotation, note, index, list) {\n\t         *      console.log(index, note, levelNotation);\n\t         *  });\n\t         *  // 0 \"first\" \"first\"\n\t         *  // 1 \"first.prop2\" \"prop2\"\n\t         *  // 2 \"first.prop2.last\" \"last\"\n\t         */\n\t\n\t    }, {\n\t        key: 'eachNote',\n\t        value: function eachNote(notation, callback) {\n\t            if (!Notation.isValid(notation)) {\n\t                throw new _notation4.default(ERR.NOTATION + '`' + notation + '`');\n\t            }\n\t            var notes = notation.split('.'),\n\t                levelNotes = [],\n\t                levelNotation;\n\t            _utils2.default.each(notes, function (note, index, list) {\n\t                levelNotes.push(note);\n\t                levelNotation = levelNotes.join('.');\n\t                if (callback(levelNotation, note, index, notes) === false) return false;\n\t            }, Notation);\n\t        }\n\t    }]);\n\t\n\t    return Notation;\n\t}();\n\t\n\tNotation.Error = _notation4.default;\n\tNotation.Glob = _notation2.default;\n\t\n\texports.default = Notation;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar toString = Object.prototype.toString;\n\t\n\tvar utils = {\n\t    isObject: function isObject(o) {\n\t        return toString.call(o) === '[object Object]';\n\t    },\n\t    isArray: function isArray(o) {\n\t        return toString.call(o) === '[object Array]';\n\t    },\n\t    hasOwn: function hasOwn(o, prop) {\n\t        return o && typeof o.hasOwnProperty === 'function' && o.hasOwnProperty(prop);\n\t    },\n\t    deepCopy: function deepCopy(object) {\n\t        if (!utils.isObject(object)) return object;\n\t        var k,\n\t            o,\n\t            copy = {};\n\t        for (k in object) {\n\t            if (utils.hasOwn(object, k)) {\n\t                o = object[k];\n\t                copy[k] = utils.isObject(o) ? utils.deepCopy(o) : o;\n\t            }\n\t        }\n\t        return copy;\n\t    },\n\t\n\t\n\t    // iterates over elements of an array, executing the callback for each\n\t    // element.\n\t    each: function each(array, callback, thisArg) {\n\t        var length = array.length,\n\t            index = -1;\n\t        while (++index < length) {\n\t            if (callback.call(thisArg, array[index], index, array) === false) break;\n\t        }\n\t    },\n\t    eachRight: function eachRight(array, callback) {\n\t        var index = array.length;\n\t        while (index--) {\n\t            if (callback(array[index], index, array) === false) break;\n\t        }\n\t    },\n\t\n\t\n\t    // Borrowed from http://phpjs.org/functions/preg_quote\n\t    pregQuote: function pregQuote(str, delimiter) {\n\t        return String(str).replace(new RegExp('[.\\\\\\\\+*?\\\\[\\\\^\\\\]$(){}=!<>|:\\\\' + (delimiter || '') + '-]', 'g'), '\\\\$&');\n\t    },\n\t    stringOrArrayOf: function stringOrArrayOf(o, value) {\n\t        return typeof o === 'string' && o === value || utils.isArray(o) && o.length === 1 && o[0] === value;\n\t    }\n\t};\n\t\n\texports.default = utils;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tvar _utils2 = _interopRequireDefault(_utils);\n\t\n\tvar _notation = __webpack_require__(4);\n\t\n\tvar _notation2 = _interopRequireDefault(_notation);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// --------------------------------\n\t// CLASS: NotationGlob\n\t// --------------------------------\n\t\n\t// http://www.linfo.org/wildcard.html\n\t// http://en.wikipedia.org/wiki/Glob_%28programming%29\n\t// http://en.wikipedia.org/wiki/Wildcard_character#Computing\n\t\n\tvar NotationGlob = function () {\n\t\n\t    /**\n\t     *  Constructs a `Notation.Glob` object with the given glob string.\n\t     *  @constructor\n\t     *\n\t     *  @param {String} glob - The glob string.\n\t     *\n\t     *  @return {Notation.Glob}\n\t     *\n\t     *  @example\n\t     *      var glob = new Notation.Glob(\"billing.account.*\");\n\t     *      glob.test(\"billing.account.id\"); // true\n\t     */\n\t\n\t    function NotationGlob(glob) {\n\t        _classCallCheck(this, NotationGlob);\n\t\n\t        if (!NotationGlob.isValid(glob)) {\n\t            throw new _notation2.default('Invalid notation glob: \"' + glob + '\"');\n\t        }\n\t        this.glob = glob;\n\t        var ng = NotationGlob.normalize(glob);\n\t        this.normalized = ng.glob;\n\t        this.isNegated = ng.isNegated;\n\t        this.regexp = NotationGlob.toRegExp(this.normalized);\n\t        this.levels = this.normalized.split('.');\n\t    }\n\t\n\t    // --------------------------------\n\t    // NotationGlob Instance Members\n\t    // --------------------------------\n\t\n\t    /**\n\t     *  Checks whether the given notation value matches the source notation glob.\n\t     *\n\t     *  @param {String} notation - The notation string to be tested.\n\t     *\n\t     *  @return {Boolean}\n\t     *\n\t     *  @example\n\t     *  var glob = new Notation.Glob(\"!prop.*.name\");\n\t     *  glob.test(\"prop.account.name\"); // true\n\t     */\n\t\n\t\n\t    _createClass(NotationGlob, [{\n\t        key: 'test',\n\t        value: function test(notation) {\n\t            // we allow \"*\" to match everything. We check for this here\n\t            // instead of the regexp bec. we care for dots (.) within the glob.\n\t            return this.normalized === '*' || this.normalized !== '' && notation !== '' && this.regexp.test(notation);\n\t        }\n\t\n\t        // --------------------------------\n\t        // NotationGlob Static Members\n\t        // --------------------------------\n\t\n\t        /**\n\t         *  Basically constructs a new `NotationGlob` instance\n\t         *  with the given glob string.\n\t         *\n\t         *  @param {String} glob - The source notation glob.\n\t         *\n\t         *  @return {NotationGlob}\n\t         *\n\t         *  @example\n\t         *  var glob = Notation.Glob.create(strGlob);\n\t         *  // equivalent to:\n\t         *  var glob = new Notation.Glob(strGlob);\n\t         */\n\t\n\t    }], [{\n\t        key: 'create',\n\t        value: function create(glob) {\n\t            return new NotationGlob(glob);\n\t        }\n\t\n\t        // Modified from http://stackoverflow.com/a/13818704/112731\n\t\n\t    }, {\n\t        key: 'toRegExp',\n\t        value: function toRegExp(glob, opts) {\n\t            glob = _utils2.default.pregQuote(glob).replace(/\\\\\\*/g, '[^\\\\s\\\\.]*').replace(/\\\\\\?/g, '.');\n\t            return new RegExp('^' + glob, opts || '');\n\t            // we don't end it with a $ so the ending is open\n\t            // `company.*` will produce `/^company\\.[^\\s\\.]*/`\n\t            // which will match both `company.name` and `company.address.street`\n\t            // but will not match `some.company.name`\n\t        }\n\t    }, {\n\t        key: 'normalize',\n\t        value: function normalize(glob) {\n\t            // replace multiple stars with single\n\t            glob = glob.replace(/\\*+/g, '*');\n\t            // empty glob if invalid e.g. '!' | '.abc' | '!*'\n\t            glob = !NotationGlob.isValid(glob) ? '' : glob;\n\t            var bang = glob.slice(0, 1) === '!';\n\t            glob = bang ? glob.slice(1) : glob;\n\t            return {\n\t                glob: glob,\n\t                isNegated: bang\n\t            };\n\t        }\n\t\n\t        // Created test at: https://regex101.com/r/tJ7yI9/\n\t\n\t    }, {\n\t        key: 'isValid',\n\t        value: function isValid(glob) {\n\t            return typeof glob === 'string' && /^!?[^\\s\\.!]+(\\.[^\\s\\.!]+)*$/.test(glob);\n\t        }\n\t\n\t        // TODO: if both \"prop.id\" and \"!prop.id\" exists normalize them.\n\t        // since negated will win, remove the other.\n\t\n\t        /**\n\t         *  Compares two given notation globs and returns an integer value as a\n\t         *  result. This is generally used to sort glob arrays. Loose globs (with\n\t         *  stars especially closer to beginning of the glob string); globs\n\t         *  representing the parent/root of the compared property glob come first.\n\t         *  Verbose/detailed/exact globs come last. (`* < *abc < abc`). For\n\t         *  instance; `store.address` comes before `store.address.street`. So this\n\t         *  works both for `*, store.address.street, !store.address` and `*,\n\t         *  store.address, !store.address.street`. For cases such as `prop.id` vs\n\t         *  `!prop.id` which represent the same property; the negated glob wins\n\t         *  (comes last).\n\t         *\n\t         *  @param {String} a - First notation glob to be compared.\n\t         *  @param {String} b - Second notation glob to be compared.\n\t         *\n\t         *  @return {Number}  Returns `-1` if `a` comes first, `1` if `b` comes\n\t         *      first and `0` if equivalent priority.\n\t         *\n\t         *  @example\n\t         *  var result = Notation.Glob.compare(\"prop.*.name\", \"prop.*\");\n\t         *  console.log(result); // 1\n\t         */\n\t\n\t    }, {\n\t        key: 'compare',\n\t        value: function compare(a, b) {\n\t            // trivial case, both are exactly the same!\n\t            if (a === b) return 0;\n\t            var levelsA = a.split('.'),\n\t                levelsB = b.split('.');\n\t            // Check depth (number of levels)\n\t            if (levelsA.length === levelsB.length) {\n\t                // count wildcards (assuming more wildcards comes first)\n\t                var wild = /(?:^|\\.)\\*(?:$|\\.)/g,\n\t                    mA = a.match(wild),\n\t                    mB = b.match(wild),\n\t                    wildA = mA ? mA.length : 0,\n\t                    wildB = mB ? mB.length : 0;\n\t                if (wildA === wildB) {\n\t                    // check for negation\n\t                    var negA = a.indexOf('!') === 0,\n\t                        negB = b.indexOf('!') === 0;\n\t                    if (negA === negB) {\n\t                        // both are negated or neither are, just return alphabetical\n\t                        return a < b ? -1 : 1;\n\t                    }\n\t                    // compare without the negatation\n\t                    var nonNegA = negA ? a.slice(1) : a,\n\t                        nonNegB = negB ? b.slice(1) : b;\n\t                    if (nonNegA === nonNegB) {\n\t                        return negA ? 1 : -1;\n\t                    }\n\t                    return nonNegA < nonNegB ? -1 : 1;\n\t                }\n\t                return wildA > wildB ? -1 : 1;\n\t            }\n\t\n\t            return levelsA.length < levelsB.length ? -1 : 1;\n\t        }\n\t\n\t        /**\n\t         *  Sorts the notation globs in the given array by their priorities.\n\t         *  Loose globs (with stars especially closer to beginning of the glob string);\n\t         *  globs representing the parent/root of the compared property glob come first.\n\t         *  Verbose/detailed/exact globs come last. (`* < *abc < abc`). For\n\t         *  instance; `store.address` comes before `store.address.street`. For cases\n\t         *  such as `prop.id` vs `!prop.id` which represent the same property; the\n\t         *  negated glob wins (comes last).\n\t         *\n\t         *  @param {Array} globsArray - The notation globs array to be sorted. The passed\n\t         *      array reference is modified.\n\t         *\n\t         *  @return {Array}\n\t         *\n\t         *  @example\n\t         *  var globs = [ \"!prop.*.name\", \"prop.*\", \"prop.id\" ];\n\t         *  Notation.Glob.sort(globs);\n\t         *  console.log(globs);\n\t         *  // [ \"prop.*\", \"prop.id\", \"!prop.*.name\" ];\n\t         */\n\t\n\t    }, {\n\t        key: 'sort',\n\t        value: function sort(globsArray) {\n\t            return globsArray.sort(NotationGlob.compare);\n\t            // return _mergeSortArray(globsArray, NotationGlob.compare);\n\t        }\n\t\n\t        /**\n\t         *  Gets the union from the given couple of glob arrays and returns\n\t         *  a new array of globs. If the exact same element is found in both\n\t         *  arrays, one of them is removed to prevent duplicates. If one of the\n\t         *  arrays contains a negated equivalent of an item in the other array,\n\t         *  the negated item is removed. If any item covers/matches a negated\n\t         *  item in the other array, the negated item is removed.\n\t         *\n\t         *  @param {Array} arrA - First array of glob strings.\n\t         *  @param {Array} arrB - Second array of glob strings.\n\t         *  @param {Boolean} sort - Whether to sort the globs in the final array.\n\t         *      Default: `true`\n\t         *\n\t         *  @return {Array}\n\t         *\n\t         *  @example\n\t         *  var a = [ 'foo.bar', 'bar.baz', '!*.qux' ],\n\t         *      b = [ '!foo.bar', 'bar.qux', 'bar.baz' ],\n\t         *  console.log(Notation.Glob.union(a, b));\n\t         *  // [ '!*.qux', 'foo.bar', 'bar.baz', 'bar.qux' ]\n\t         */\n\t\n\t    }, {\n\t        key: 'union',\n\t        value: function union(arrA, arrB, sort) {\n\t            var nonegA, re, bIndex;\n\t            // iterate through first array\n\t            _utils2.default.eachRight(arrA, function (a, ia) {\n\t                // check if the exact item exists in the second array and remove\n\t                // if exists (to prevent duplicates).\n\t                bIndex = arrB.indexOf(a);\n\t                if (bIndex >= 0) arrB.splice(bIndex, 1);\n\t                // look for negateds and when one found; check if non-negated\n\t                // equivalent exists in the second array. if it exists, remove\n\t                // \"this negated\" from first array.\n\t                // e.g. [ '!foo.bar' ] + [ 'foo.bar' ] => [ 'foo.bar' ]\n\t                if (a.indexOf('!') === 0) {\n\t                    nonegA = a.slice(1);\n\t                    if (arrB.indexOf(nonegA) >= 0) {\n\t                        arrA.splice(ia, 1);\n\t                        return true;\n\t                    }\n\t                    // non-negated is not found in the second. so, iterate through\n\t                    // the second array; look for non-negateds and when found,\n\t                    // check if it covers/matches the negated from the first\n\t                    // array. if so, remove the negated from the first array.\n\t                    // [ '!foo.bar' ] + [ 'foo.*' ]  => [ 'foo.*' ]              // wild covers !v, remove !v\n\t                    // [ 'foo.bar' ]  + [ '!foo.*' ] => [ '!foo.*', 'foo.bar' ]  // !wild covers v, both kept\n\t                    // [ 'baz.que' ]  + [ '!foo.*' ] => [ '!foo.*', 'baz.que' ]  // !wild doesn't cover, both kept\n\t                    _utils2.default.eachRight(arrB, function (b, ib) {\n\t                        if (b.indexOf('!') < 0) {\n\t                            re = NotationGlob.toRegExp(b);\n\t                            if (re.test(nonegA)) arrA.splice(ia, 1);\n\t                        }\n\t                    });\n\t                } else {\n\t                    // item in the first array is not negated; so check if a\n\t                    // negated equivalent exists in the second and remove if\n\t                    // exists.\n\t                    // e.g. [ 'foo.bar' ] + [ '!foo.bar' ] => [ 'foo.bar' ]\n\t                    bIndex = arrB.indexOf('!' + a);\n\t                    if (bIndex >= 0) arrB.splice(bIndex, 1);\n\t                }\n\t            });\n\t\n\t            // concat both arrays and sort (if enabled) so we get a nice union\n\t            // array.\n\t            var result = arrA.concat(arrB);\n\t            return sort === undefined || sort === true ? NotationGlob.sort(result) : result;\n\t        }\n\t    }]);\n\t\n\t    return NotationGlob;\n\t}();\n\t\n\texports.default = NotationGlob;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t/**\n\t *  Error class specific to `Notation`.\n\t */\n\t\n\tvar NotationError = function (_Error) {\n\t    _inherits(NotationError, _Error);\n\t\n\t    /**\n\t     *  Initializes a new `NotationError` instance.\n\t     *  @constructor\n\t     *\n\t     *  @param {String} message - The error message.\n\t     */\n\t\n\t    function NotationError() {\n\t        var message = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n\t\n\t        _classCallCheck(this, NotationError);\n\t\n\t        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(NotationError).call(this, message));\n\t\n\t        _this.name = _this.constructor.name;\n\t\n\t        Object.defineProperty(_this, 'name', {\n\t            enumerable: false,\n\t            writable: true,\n\t            value: 'NotationError'\n\t        });\n\t\n\t        Object.defineProperty(_this, 'message', {\n\t            enumerable: false,\n\t            writable: true,\n\t            value: message\n\t        });\n\t\n\t        if (Error.hasOwnProperty('captureStackTrace')) {\n\t            // V8\n\t            Error.captureStackTrace(_this, _this.constructor);\n\t        } else {\n\t            Object.defineProperty(_this, 'stack', {\n\t                enumerable: false,\n\t                writable: true,\n\t                value: new Error(message).stack\n\t            });\n\t        }\n\t        return _this;\n\t    }\n\t\n\t    return NotationError;\n\t}(Error);\n\t\n\texports.default = NotationError;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** notation.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 80292894717aa3d3badd\n **/","import Notation from './core/Notation';\n// export default Notation;\n// http://stackoverflow.com/a/33683495/112731\nmodule.exports = Notation;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","import utils from '../lib/utils';\nimport NotationGlob from './notation.glob';\nimport NotationError from './notation.error';\n\n// TODO:\n// templates? ${some.property}\n// Error if source object has flattened (dotted) keys.\n// expand if dotted keyed object is passed to constructor?\n\nconst ERR = {\n    SOURCE: 'Invalid source object.',\n    DEST: 'Invalid destination object.',\n    NOTATION: 'Invalid notation: ',\n    NOTA_OBJ: 'Invalid notations object: '\n};\n\n/**\n *  Notation.js for Node and Browser.\n *\n *  Provides various methods for modifying / processing the contents\n *  of the given object; by parsing object notation strings or globs.\n *  Note that this class will only deal with enumerable properties of the\n *  source object; so it should be used to manipulate data objects. It will\n *  not deal with preserving the prototype-chain of the given object.\n *\n *  @version  0.7.0 (2015-05-05)\n *  @author   Onur Yıldırım (onur@cutepilot.com)\n *  @license  MIT\n */\nclass Notation {\n\n    /**\n     *  Initializes a new instance of `Notation`.\n     *\n     *  @param {Object} object - The source object to be notated.\n     *\n     *  @return {Notation}\n     *\n     *  @example\n     *  var assets = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  var notaAssets = new Notation(assets);\n     *  notaAssets.get('car.model'); // \"Charger\"\n     */\n    constructor(object) {\n        // if not defined, default to `{}`\n        object = object === undefined ? {} : object;\n        // if defined, it should be an object.\n        if (!utils.isObject(object)) {\n            throw new NotationError(ERR.SOURCE);\n        }\n        this.source_ = object;\n    }\n\n    // --------------------------------\n    // Notation Instance Properties\n    // --------------------------------\n\n    /**\n     *  Gets the value of the source object.\n     *\n     *  @return {Object} - The source object.\n     *\n     *  @example\n     *  var o = { name: \"Onur\" };\n     *  var me = Notation.create(o)\n     *      .set(\"age\", 36)\n     *      .set(\"car.brand\", \"Ford\")\n     *      .set(\"car.model\", \"Mustang\")\n     *      .value;\n     *  console.log(me);\n     *  // { name: \"Onur\", age: 36, car: { brand: \"Ford\", model: \"Mustang\" } }\n     *  console.log(o === me);\n     *  // true\n     */\n    get value() {\n        return this.source_;\n    }\n\n    // --------------------------------\n    // Notation Instance Methods\n    // --------------------------------\n\n    /**\n     *  Recursively iterates through each key of the source object and invokes\n     *  the given callback function with parameters, on each non-object value.\n     *\n     *  @param {Function} callback - The callback function to be invoked on\n     *      each on each non-object value. To break out of the loop, return\n     *      `false` from within the callback.\n     *      Callback signature: `callback(notation, key, value, object) { ... }`\n     *\n     *  @return {void}\n     *\n     *  @example\n     *  var assets = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  Notation.create(assets).eachKey(function (notation, key, value, object) {\n     *      console.log(notation, value);\n     *  });\n     *  // \"car.brand\"  \"Dodge\"\n     *  // \"car.model\"  \"Charger\"\n     *  // \"car.year\"  1970\n     */\n    eachKey(callback) {\n        var o = this.source_,\n            keys = Object.keys(o);\n        utils.each(keys, function (key, index, list) {\n            var prop = o[key],\n                N;\n            if (utils.isObject(prop)) {\n                N = new Notation(prop);\n                N.eachKey(function (notation, nKey, value, prop) {\n                    var subKey = key + '.' + notation;\n                    callback.call(this, subKey, nKey, value, o);\n                });\n            } else {\n                callback.call(this, key, key, prop, o);\n            }\n        }, this);\n    }\n\n    /**\n     *  Iterates through each note of the given notation string by evaluating\n     *  it on the source object.\n     *\n     *  @param {String} notation - The notation string to be iterated through.\n     *  @param {Function} callback - The callback function to be invoked on\n     *      each iteration. To break out of the loop, return `false` from\n     *      within the callback.\n     *      Callback signature: `callback(levelValue, note, index, list) { ... }`\n     *\n     *  @return {void}\n     *\n     *  @example\n     *  var assets = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  Notation.create(assets)\n     *      .eachNoteValue(\"car.brand\", function (levelValue, note, index, list) {\n     *          console.log(note, levelValue); // \"car.brand\" \"Dodge\"\n     *      });\n     */\n    eachNoteValue(notation, callback) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\n        }\n        var level = this.source_;\n        Notation.eachNote(notation, function (levelNotation, note, index, list) {\n            level = utils.hasOwn(level, note) ? level[note] : undefined;\n            if (callback(level, levelNotation, note, index, list) === false) return false;\n\n        });\n    }\n\n    /**\n     *  Gets the list of notations from the source object (keys).\n     *\n     *  @return {Array} - An array of notation strings.\n     *\n     *  @example\n     *  var assets = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  var notationsList = Notation.create(assets).getNotations();\n     *  // [ \"car.brand\", \"car.model\", \"car.year\" ]\n     */\n    getNotations() {\n        var list = [];\n        this.eachKey(function (notation, key, value, obj) {\n            list.push(notation);\n        });\n        return list;\n    }\n\n    /**\n     *  Gets a flat (single-level) object with notated keys, from the source object.\n     *  @alias Notation#getMap\n     *\n     *  @return {Object} - A new object with flat, notated keys.\n     *\n     *  @example\n     *  var assets = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\n     *  var flat = Notation.create(assets).getFlat();\n     *  // { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\n     */\n    getFlat() {\n        var o = {};\n        this.eachKey(function (notation, key, value, obj) {\n            o[notation] = value;\n        });\n        return o;\n    }\n    /**\n     *  Alias for `#getFlat`\n     *  @private\n     */\n    getMap() {\n        return this.getFlat();\n    }\n\n    /**\n     *  Inspects the given notation on the source object by checking\n     *  if the source object actually has the notated property;\n     *  and getting its value if exists.\n     *\n     *  @param {String} notation - The notation string to be inspected.\n     *\n     *  @return {Object} - The result object has the following properties:\n     *      `result.has` {Boolean}  Indicates whether the source object\n     *          has the given notation as a (leveled) enumerable property.\n     *          If the property exists but has a value of `undefined`,\n     *          this will still return `true`.\n     *      `result.value` {*}  The value of the notated property.\n     *          if the source object does not have the notation,\n     *          the value will be `undefined`.\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).inspect(\"car.year\");\n     *  // { has: true, value: 1970 }\n     *  Notation.create({ car: { year: 1970 } }).inspect(\"car.color\");\n     *  // { has: false, value: undefined }\n     *  Notation.create({ car: { color: undefined } }).inspect(\"car.color\");\n     *  // { has: true, value: undefined }\n     */\n    inspect(notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\n        }\n        var level = this.source_,\n            result = { has: false, value: undefined };\n        Notation.eachNote(notation, function (levelNotation, note, index, list) {\n            if (utils.hasOwn(level, note)) {\n                level = level[note];\n                result = { has: true, value: level };\n            } else {\n                // level = undefined;\n                result = { has: false, value: undefined };\n                return false; // break out\n            }\n        });\n        return result;\n    }\n\n    /**\n     *  Inspects and removes the given notation from the source object\n     *  by checking if the source object actually has the notated property;\n     *  and getting its value if exists, before removing the property.\n     *\n     *  @param {String} notation - The notation string to be inspected.\n     *\n     *  @return {Object} - The result object has the following properties:\n     *      `result.has` {Boolean}  Indicates whether the source object\n     *          has the given notation as a (leveled) enumerable property.\n     *          If the property exists but has a value of `undefined`,\n     *          this will still return `true`.\n     *      `result.value` {*}  The value of the removed property.\n     *          if the source object does not have the notation,\n     *          the value will be `undefined`.\n     *\n     *  @example\n     *  var obj = { name: \"John\", car: { year: 1970 } };\n     *  Notation.create(obj).inspectRemove(\"car.year\"); // { has: true, value: 1970 }\n     *  // obj » { name: \"John\", car: {} }\n     *  Notation.create(obj).inspectRemove(\"car.year\", true); // { has: true, value: 1970 }\n     *  // obj » { name: \"John\" }\n     *  Notation.create({ car: { year: 1970 } }).inspectRemove(\"car.color\");\n     *  // { has: false, value: undefined }\n     *  Notation.create({ car: { color: undefined } }).inspectRemove(\"car.color\");\n     *  // { has: true, value: undefined }\n     */\n    inspectRemove(notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\n        }\n        var o, lastNote;\n        if (notation.indexOf('.') < 0) {\n            lastNote = notation;\n            o = this.source_;\n        } else {\n            var upToLast = Notation.parent(notation);\n            lastNote = Notation.last(notation);\n            o = this.inspect(upToLast).value;\n        }\n        var result;\n        if (utils.hasOwn(o, lastNote)) {\n            result = { has: true, value: o[lastNote] };\n            delete o[lastNote];\n        } else {\n            result = { has: false, value: undefined };\n        }\n\n        return result;\n    }\n\n    /**\n     *  Checks whether the source object has the given notation\n     *  as a (leveled) enumerable property. If the property exists\n     *  but has a value of `undefined`, this will still return `true`.\n     *\n     *  @param {String} notation - The notation string to be checked.\n     *\n     *  @return {Boolean}\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).has(\"car.year\"); // true\n     *  Notation.create({ car: { year: undefined } }).has(\"car.year\"); // true\n     *  Notation.create({}).has(\"car.color\"); // false\n     */\n    has(notation) {\n        return this.inspect(notation).has;\n    }\n\n    /**\n     *  Checks whether the source object has the given notation\n     *  as a (leveled) defined enumerable property. If the property\n     *  exists but has a value of `undefined`, this will return `false`.\n     *\n     *  @param {String} notation - The notation string to be checked.\n     *\n     *  @return {Boolean}\n     *\n     *  @example\n     *  Notation.create({ car: { year: 1970 } }).hasDefined(\"car.year\"); // true\n     *  Notation.create({ car: { year: undefined } }).hasDefined(\"car.year\"); // false\n     *  Notation.create({}).hasDefined(\"car.color\"); // false\n     */\n    hasDefined(notation) {\n        return this.inspect(notation).value !== undefined;\n    }\n\n    /**\n     *  Gets the value of the corresponding property at the given\n     *  notation.\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *  @param {String} defaultValue - Optional. Default: `undefined`\n     *      The default value to be returned if the property is not\n     *      found or enumerable.\n     *\n     *  @return {*} - The value of the notated property.\n     *\n     *  @example\n     *  Notation.create({ car: { brand: \"Dodge\" } }).get(\"car.brand\"); // \"Dodge\"\n     *  Notation.create({ car: {} }).get(\"car.model\"); // undefined\n     *  Notation.create({ car: {} }).get(\"car.model\", \"Challenger\"); // \"Challenger\"\n     *  Notation.create({ car: { model: undefined } }).get(\"car.model\", \"Challenger\"); // undefined\n     */\n    get(notation, defaultValue) {\n        var result = this.inspect(notation);\n        return !result.has ? defaultValue : result.value;\n    }\n\n    /**\n     *  Sets the value of the corresponding property at the given\n     *  notation. If the property does not exist, it will be created\n     *  and nested at the calculated level. If it exists; its value\n     *  will be overwritten by default.\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *  @param {*} value - The value to be set for the notated property.\n     *  @param {Boolean} overwrite - Optional. Default: `true`\n     *      Whether to overwrite the property if exists.\n     *\n     *  @return {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var assets = { car: { brand: \"Dodge\", year: 1970 } };\n     *  Notation.create(assets)\n     *      .set(\"car.brand\", \"Ford\")\n     *      .set(\"car.model\", \"Mustang\")\n     *      .set(\"car.year\", 1965, false)\n     *      .set(\"car.color\", \"red\")\n     *      .set(\"boat\", \"none\");\n     *  console.log(assets);\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" } };\n     */\n    set(notation, value, overwrite) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\n        }\n        overwrite = typeof overwrite === 'boolean' ? overwrite : true;\n        var level = this.source_,\n            last;\n        Notation.eachNote(notation, function (levelNotation, note, index, list) {\n            last = index === list.length - 1;\n            // check if the property is at this level\n            if (utils.hasOwn(level, note)) {\n                // check if we're at the last level\n                if (last) {\n                    // if overwrite is set, assign the value.\n                    if (overwrite) level[note] = value;\n                } else {\n                    // if not, just re-reference the current level.\n                    level = level[note];\n                }\n            } else {\n                // we don't have this property at this level\n                // so; if this is the last level, we set the value\n                // if not, we set an empty object for the next level\n                level = level[note] = (last ? value : {});\n            }\n        });\n        return this;\n    }\n\n    /**\n     *  Just like the `.set()` method but instead of a single notation\n     *  string, an object of notations and values can be passed.\n     *  Sets the value of each corresponding property at the given\n     *  notation. If a property does not exist, it will be created\n     *  and nested at the calculated level. If it exists; its value\n     *  will be overwritten by default.\n     *\n     *  @param {Object} notationsObject - The notations object to be processed.\n     *      This can either be a regular object with non-dotted keys\n     *      (which will be merged to the first/root level of the source object);\n     *      or a flattened object with notated (dotted) keys.\n     *\n     *  @param {Boolean} overwrite - Optional. Default: `true`\n     *      Whether to overwrite a property if exists.\n     *\n     *  @return {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var assets = { car: { brand: \"Dodge\", year: 1970 } };\n     *  Notation.create(assets)\n     *      .merge({\n     *          \"car.brand\": \"Ford\",\n     *          \"car.model\": \"Mustang\",\n     *          \"car.year\": 1965, false,\n     *          \"car.color\": \"red\",\n     *          \"boat\": \"none\"\n     *      });\n     *  console.log(assets);\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" } };\n     */\n    merge(notationsObject, overwrite) {\n        if (!utils.isObject(notationsObject)) {\n            throw new NotationError(ERR.NOTA_OBJ + '`' + notationsObject + '`');\n        }\n        var value;\n        utils.each(Object.keys(notationsObject), function (notation, index, obj) {\n            value = notationsObject[notation];\n            this.set(notation, value, overwrite);\n        }, this);\n        return this;\n    }\n\n    /**\n     *  Removes the properties by the given list of notations from the source\n     *  object and returns a new object with the removed properties.\n     *  Opposite of `merge()` method.\n     *\n     *  @param {Array} notationsArray - The notations array to be processed.\n     *\n     *  @return {Object} - An object with the removed properties.\n     *\n     *  @example\n     *  var assets = { car: { brand: \"Dodge\", year: 1970 }, notebook: \"Mac\" };\n     *  var separated = Notation.create(assets).separate([\"car.brand\", \"boat\" ]);\n     *  console.log(separated);\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\" } };\n     *  console.log(assets);\n     *  // { car: { year: 1970 } };\n     */\n    separate(notationsArray) {\n        if (!utils.isArray(notationsArray)) {\n            throw new NotationError(ERR.NOTA_OBJ + '`' + notationsArray + '`');\n        }\n        var o = new Notation({});\n        utils.each(notationsArray, function (notation, index, obj) {\n            var result = this.inspectRemove(notation);\n            o.set(notation, result.value);\n        }, this);\n        return o.source_;\n    }\n\n    // iterate globs\n    // remove non-star negated globs directly\n    // get non-star part iterate thru obj keys\n\n    /**\n     *  Deep clones the source object while filtering its properties\n     *  by the given glob notations. Includes all matched properties\n     *  and removes the rest.\n     *\n     *  @param {Array|String} globNotations - The glob notation(s) to\n     *      be processed. The difference between normal notations and\n     *      glob-notations is that you can use wildcard stars (*) and\n     *      negate the notation by prepending a bang (!). A negated\n     *      notation will be excluded. Order of the globs do not matter,\n     *      they will be logically sorted. Loose globs will be processed\n     *      first and verbose globs or normal notations will be processed\n     *      last. e.g. `[ \"car.model\", \"*\", \"!car.*\" ]` will be sorted as\n     *      `[ \"*\", \"!car.*\", \"car.model\" ]`.\n     *      Passing no parameters or passing an empty string (`\"\"` or `[\"\"]`)\n     *      will empty the source object.\n     *\n     *  @return {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var assets = { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" } };\n     *  var nota = Notation.create(assets);\n     *  nota.filter([ \"*\", \"!car.*\", \"car.model\" ]);\n     *  console.log(assets); // { notebook: \"Mac\", car: { model: \"Mustang\" } }\n     *  nota.filter(\"*\");\n     *  console.log(assets); // { notebook: \"Mac\", car: { model: \"Mustang\" } }\n     *  nota.filter(); // or nota.filter(\"\");\n     *  console.log(assets); // {}\n     */\n    filter(globNotations) {\n        var original = this.value,\n            copy = utils.deepCopy(original);\n        // if globNotations is \"*\" or [\"*\"] set the \"copy\" as source and\n        // return.\n        if (utils.stringOrArrayOf(globNotations, '*')) {\n            this.source_ = copy;\n            return this;\n        }\n        // if globNotations is \"\" or [\"\"] set source to `{}` and return.\n        if (arguments.length === 0 || utils.stringOrArrayOf(globNotations, '')) {\n            this.source_ = {};\n            return this;\n        }\n        var globs = utils.isArray(globNotations)\n            // sort the globs in logical order. we also concat the array first\n            // bec. we'll change it's content via `.shift()`\n            ? NotationGlob.sort(globNotations.concat()) : [globNotations];\n        var filtered;\n        // if the first item of sorted globs is \"*\" we set the source to the\n        // (full) \"copy\" and remove the \"*\" from globs (not to re-process).\n        if (globs[0] === '*') {\n            filtered = new Notation(copy);\n            globs.shift();\n        } else {\n            // otherwise we set an empty object as the source so that we can\n            // add notations/properties to it.\n            filtered = new Notation({});\n        }\n        var g, endStar, normalized;\n        // iterate through globs\n        utils.each(globs, function (globNotation, index, array) {\n            g = new NotationGlob(globNotation);\n            // set flag that indicates whether the glob ends with `.*`\n            endStar = g.normalized.slice(-2) === '.*';\n            // get the remaining part as the (extra) normalized glob\n            normalized = endStar ? g.normalized.slice(0, -2) : g.normalized;\n            // check if normalized glob has no wildcard stars e.g. \"a.b\" or\n            // \"!a.b.c\" etc..\n            if (normalized.indexOf('*') < 0) {\n                if (g.isNegated) {\n                    // directly remove the notation if negated\n                    filtered.remove(normalized);\n                    // if original glob had `.*` at the end, it means remove\n                    // contents (not itself). so we'll set an empty object.\n                    // meaning `some.prop` (prop) is removed completely but\n                    // `some.prop.*` (prop) results in `{}`.\n                    if (endStar) filtered.set(normalized, {}, true);\n                } else {\n                    // directly copy the same notation from the original\n                    filtered.copyFrom(original, normalized, null, true);\n                }\n                // move to the next\n                return true;\n            }\n            // if glob has wildcard star(s), we'll iterate through keys of the\n            // source object and see if (full) notation of each key matches\n            // the current glob.\n\n            // TODO: Optimize the loop below. Instead of checking each key's\n            // notation, get the non-star left part of the glob and iterate\n            // that property of the source object.\n            this.eachKey(function (originalNotation, key, value, obj) {\n                // console.log(originalNotation, key);\n                if (g.test(originalNotation)) {\n                    if (g.isNegated) {\n                        filtered.remove(originalNotation);\n                    } else {\n                        filtered.set(originalNotation, value, true);\n                    }\n                }\n            });\n        }, this);\n        // finally set the filtered's value as the source of our instance and\n        // return.\n        this.source_ = filtered.value;\n        return this;\n    }\n\n    // store.partners.*\n    // *.host » iterate original obj\n    // store.*.host » iterate store obj\n\n    // TODO: remove support for char-star. e.g. `prop1.prop*2`\n\n    /**\n     *  Removes the property at the given notation, from the source object.\n     *\n     *  @param {String} notation - The notation to be inspected.\n     *\n     *  @return {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var assets = { notebook: \"Mac\", car: { model: \"Mustang\" } };\n     *  Notation.create(assets).remove(\"car.model\");\n     *  console.log(assets); // { notebook: \"Mac\", car: { } }\n     */\n    remove(notation) {\n        this.inspectRemove(notation);\n        return this;\n    }\n    // Notation.prototype.delete = Notation.prototype.remove;\n\n    clone() {\n        var o = utils.deepCopy(this.value);\n        return new Notation(o);\n    }\n\n    /**\n     *  Copies the notated property from the source object and adds it to the\n     *  destination — only if the source object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *\n     *  @param {Object} destination - The destination object that the notated\n     *      properties will be copied to.\n     *  @param {String} notation - The notation to get the corresponding property\n     *      from the source object.\n     *  @param {String} newNotation - Optional. The notation to set the source\n     *      property on the destination object. In other words, the copied property\n     *      will be renamed to this value before set on the destination object.\n     *      If not set, `notation` argument will be used.\n     *  @param {Boolean} overwrite - Optional. Default: `true`\n     *      Whether to overwrite the property on the destination object if it exists.\n     *\n     *  @return {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  var models = { dodge: \"Charger\" };\n     *  Notation.create(assets).copyTo(models, \"car.model\", \"ford\");\n     *  console.log(models);\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\n     *  // assets object is not modified\n     */\n    copyTo(destination, notation, newNotation, overwrite) {\n        if (!utils.isObject(destination)) throw new NotationError(ERR.DEST);\n        var result = this.inspect(notation);\n        if (result.has) {\n            new Notation(destination).set(newNotation || notation, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Copies the notated property from the destination object and adds it to the\n     *  source object — only if the destination object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *\n     *  @param {Object} destination - The destination object that the notated\n     *      properties will be copied from.\n     *  @param {String} notation - The notation to get the corresponding property\n     *      from the destination object.\n     *  @param {String} newNotation - Optional. The notation to set the destination\n     *      property on the source object. In other words, the copied property\n     *      will be renamed to this value before set on the source object.\n     *      If not set, `notation` argument will be used.\n     *  @param {Boolean} overwrite - Optional. Default: `true`\n     *      Whether to overwrite the property on the source object if it exists.\n     *\n     *  @return {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  var models = { dodge: \"Charger\" };\n     *  Notation.create(assets).copyFrom(models, \"dodge\", \"car.model\", true);\n     *  console.log(assets);\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\n     *  // models object is not modified\n     */\n    copyFrom(destination, notation, newNotation, overwrite) {\n        if (!utils.isObject(destination)) throw new NotationError(ERR.DEST);\n        var result = new Notation(destination).inspect(notation);\n        if (result.has) {\n            this.set(newNotation || notation, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Removes the notated property from the source object and adds it to the\n     *  destination — only if the source object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *\n     *  @param {Object} destination - The destination object that the notated\n     *      properties will be moved to.\n     *  @param {String} notation - The notation to get the corresponding property\n     *      from the source object.\n     *  @param {String} newNotation - Optional. The notation to set the source\n     *      property on the destination object. In other words, the moved property\n     *      will be renamed to this value before set on the destination object.\n     *      If not set, `notation` argument will be used.\n     *  @param {Boolean} overwrite - Optional. Default: `true`\n     *      Whether to overwrite the property on the destination object if it exists.\n     *\n     *  @return {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  var models = { dodge: \"Charger\" };\n     *  Notation.create(assets).moveTo(models, \"car.model\", \"ford\");\n     *  console.log(assets);\n     *  // { car: { brand: \"Ford\" } }\n     *  console.log(models);\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\n     */\n    moveTo(destination, notation, newNotation, overwrite) {\n        if (!utils.isObject(destination)) throw new NotationError(ERR.DEST);\n        var result = this.inspectRemove(notation);\n        if (result.has) {\n            new Notation(destination).set(newNotation || notation, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Removes the notated property from the destination object and adds it to the\n     *  source object — only if the destination object actually has that property.\n     *  This is different than a property with a value of `undefined`.\n     *\n     *  @param {Object} destination - The destination object that the notated\n     *      properties will be moved from.\n     *  @param {String} notation - The notation to get the corresponding property\n     *      from the destination object.\n     *  @param {String} newNotation - Optional. The notation to set the destination\n     *      property on the source object. In other words, the moved property\n     *      will be renamed to this value before set on the source object.\n     *      If not set, `notation` argument will be used.\n     *  @param {Boolean} overwrite - Optional. Default: `true`\n     *      Whether to overwrite the property on the source object if it exists.\n     *\n     *  @return {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  var models = { dodge: \"Charger\" };\n     *  Notation.create(assets).moveFrom(models, \"dodge\", \"car.model\", true);\n     *  console.log(assets);\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\n     *  console.log(models);\n     *  // {}\n     */\n    moveFrom(destination, notation, newNotation, overwrite) {\n        if (!utils.isObject(destination)) throw new NotationError(ERR.DEST);\n        var result = new Notation(destination).inspectRemove(notation);\n        if (result.has) {\n            this.set(newNotation || notation, result.value, overwrite);\n        }\n        return this;\n    }\n\n    /**\n     *  Renames the notated property of the source object by the new notation.\n     *  @alias Notation#renote\n     *\n     *  @param {String} notation - The notation to get the corresponding property\n     *      (value) from the source object.\n     *  @param {String} newNotation - The new notation for the targeted property.\n     *      value. If not set, the source object will not be modified.\n     *  @param {Boolean} overwrite - Optional. Default: `true`\n     *      Whether to overwrite the property at the new notation, if it exists.\n     *\n     *  @return {Notation} - Returns the current `Notation` instance (self).\n     *\n     *  @example\n     *  var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  Notation.create(assets)\n     *      .rename(\"car.brand\", \"carBrand\")\n     *      .rename(\"car.model\", \"carModel\");\n     *  console.log(assets);\n     *  // { carBrand: \"Ford\", carModel: \"Mustang\" }\n     */\n    rename(notation, newNotation, overwrite) {\n        if (!newNotation) return this;\n        return this.moveTo(this.source_, notation, newNotation, overwrite);\n    }\n    /**\n     *  Alias for `#rename`\n     *  @private\n     */\n    renote(notation, newNotation, overwrite) {\n        return this.rename(notation, newNotation, overwrite);\n    }\n\n    /**\n     *  Extracts the property at the given notation to a new object by copying\n     *  it from the source object. This is equivalent to `.copyTo({}, notation, newNotation)`.\n     *  @alias Notation#copyToNew\n     *\n     *  @param {String} notation - The notation to get the corresponding property\n     *      (value) from the source object.\n     *  @param {String} newNotation - The new notation to be set on the new object\n     *      for the targeted property value. If not set, `notation` argument will\n     *      be used.\n     *\n     *  @return {Object} - Returns a new object with the notated property.\n     *\n     *  @example\n     *  var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  var extracted = Notation.create(assets).extract(\"car.brand\", \"carBrand\");\n     *  console.log(extracted);\n     *  // { carBrand: \"Ford\" }\n     *  // assets object is not modified\n     */\n    extract(notation, newNotation) {\n        var o = {};\n        this.copyTo(o, notation, newNotation);\n        return o;\n    }\n    /**\n     *  Alias for `#extract`\n     *  @private\n     */\n    copyToNew(notation, newNotation) {\n        return this.extract(notation, newNotation);\n    }\n\n    /**\n     *  Extrudes the property at the given notation to a new object by moving\n     *  it from the source object. This is equivalent to `.moveTo({}, notation, newNotation)`.\n     *  @alias Notation#moveToNew\n     *\n     *  @param {String} notation - The notation to get the corresponding property\n     *      (value) from the source object.\n     *  @param {String} newNotation - The new notation to be set on the new object\n     *      for the targeted property value. If not set, `notation` argument will\n     *      be used.\n     *\n     *  @return {Object} - Returns a new object with the notated property.\n     *\n     *  @example\n     *  var assets = { car: { brand: \"Ford\", model: \"Mustang\" } };\n     *  var extruded = Notation.create(assets).extrude(\"car.brand\", \"carBrand\");\n     *  console.log(assets);\n     *  // { car: { model: \"Mustang\" } }\n     *  console.log(extruded);\n     *  // { carBrand: \"Ford\" }\n     */\n    extrude(notation, newNotation) {\n        var o = {};\n        this.moveTo(o, notation, newNotation);\n        return o;\n    }\n    /**\n     *  Alias for `#extrude`\n     *  @private\n     */\n    moveToNew(notation, newNotation) {\n        return this.extrude(notation, newNotation);\n    }\n\n    // --------------------------------\n    // Notation Static Methods\n    // --------------------------------\n\n    /**\n     *  Basically constructs a new `Notation` instance\n     *  with the given object.\n     *\n     *  @param {Object} object - The object to be notated.\n     *\n     *  @return {Notation}\n     *\n     *  @example\n     *  var notaObj = Notation.create(obj);\n     *  // equivalent to:\n     *  var notaObj = new Notation(obj);\n     */\n    static create(object) {\n        return new Notation(object);\n    }\n\n    /**\n     *  Checks whether the given notation string is valid.\n     *\n     *  @param {String} notation - The notation string to be checked.\n     *\n     *  @return {Boolean}\n     *\n     *  @example\n     *  Notation.isValid('prop1.prop2.prop3'); // true\n     *  Notation.isValid('prop1'); // true\n     *  Notation.isValid(null); // false\n     */\n    static isValid(notation) {\n        return (typeof notation === 'string') &&\n            (/^[^\\s\\.!]+(\\.[^\\s\\.!]+)*$/).test(notation);\n    }\n\n    /**\n     *  Gets the first (root) note of the notation string.\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *\n     *  @return {String}\n     *\n     *  @example\n     *  Notation.first('first.prop2.last'); // \"first\"\n     */\n    static first(notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\n        }\n        // return notation.replace(/.*\\.([^\\.]*$)/, '$1');\n        return notation.split('.')[0];\n    }\n\n    /**\n     *  Gets the last note of the notation string.\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *\n     *  @return {String}\n     *\n     *  @example\n     *  Notation.last('first.prop2.last'); // \"last\"\n     */\n    static last(notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\n        }\n        // return notation.replace(/.*\\.([^\\.]*$)/, '$1');\n        return notation.split('.').reverse()[0];\n    }\n\n    /**\n     *  Gets the parent notation (up to but excluding the last note)\n     *  from the notation string.\n     *\n     *  @param {String} notation - The notation string to be processed.\n     *\n     *  @return {String}\n     *\n     *  @example\n     *  Notation.parent('first.prop2.last'); // \"first.prop2\"\n     *  Notation.parent('single'); // null\n     */\n    static parent(notation) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\n        }\n        return notation.indexOf('.') >= 0\n            ? notation.replace(/\\.[^\\.]*$/, '')\n            : null;\n    }\n\n    /**\n     *  Iterates through each note of the given notation string.\n     *\n     *  @param {String} notation - The notation string to be iterated through.\n     *  @param {Function} callback - The callback function to be invoked on\n     *      each iteration. To break out of the loop, return `false` from\n     *      within the callback.\n     *      Callback signature: `callback(levelNotation, note, index, list) { ... }`\n     *\n     *  @return {void}\n     *\n     *  @example\n     *  Notation.eachNote(\"first.prop2.last\", function (levelNotation, note, index, list) {\n     *      console.log(index, note, levelNotation);\n     *  });\n     *  // 0 \"first\" \"first\"\n     *  // 1 \"first.prop2\" \"prop2\"\n     *  // 2 \"first.prop2.last\" \"last\"\n     */\n    static eachNote(notation, callback) {\n        if (!Notation.isValid(notation)) {\n            throw new NotationError(ERR.NOTATION + '`' + notation + '`');\n        }\n        var notes = notation.split('.'),\n            levelNotes = [],\n            levelNotation;\n        utils.each(notes, function (note, index, list) {\n            levelNotes.push(note);\n            levelNotation = levelNotes.join('.');\n            if (callback(levelNotation, note, index, notes) === false) return false;\n        }, Notation);\n    }\n\n}\n\nNotation.Error = NotationError;\nNotation.Glob = NotationGlob;\n\nexport default Notation;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/Notation.js\n **/","\nlet toString = Object.prototype.toString;\n\nconst utils = {\n\n    isObject(o) {\n        return toString.call(o) === '[object Object]';\n    },\n\n    isArray(o) {\n        return toString.call(o) === '[object Array]';\n    },\n\n    hasOwn(o, prop) {\n        return o && typeof o.hasOwnProperty === 'function' && o.hasOwnProperty(prop);\n    },\n\n    deepCopy(object) {\n        if (!utils.isObject(object)) return object;\n        var k, o,\n            copy = {};\n        for (k in object) {\n            if (utils.hasOwn(object, k)) {\n                o = object[k];\n                copy[k] = utils.isObject(o) ? utils.deepCopy(o) : o;\n            }\n        }\n        return copy;\n    },\n\n    // iterates over elements of an array, executing the callback for each\n    // element.\n    each(array, callback, thisArg) {\n        var length = array.length,\n            index = -1;\n        while (++index < length) {\n            if (callback.call(thisArg, array[index], index, array) === false) break;\n        }\n    },\n\n    eachRight(array, callback) {\n        var index = array.length;\n        while (index--) {\n            if (callback(array[index], index, array) === false) break;\n        }\n    },\n\n    // Borrowed from http://phpjs.org/functions/preg_quote\n    pregQuote(str, delimiter) {\n        return String(str)\n            .replace(new RegExp('[.\\\\\\\\+*?\\\\[\\\\^\\\\]$(){}=!<>|:\\\\' + (delimiter || '') + '-]', 'g'), '\\\\$&');\n    },\n\n    stringOrArrayOf(o, value) {\n        return (typeof o === 'string' && o === value)\n            || (utils.isArray(o) && o.length === 1 && o[0] === value);\n    }\n\n};\n\nexport default utils;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/utils.js\n **/","import utils from '../lib/utils';\nimport NotationError from './notation.error';\n\n// --------------------------------\n// CLASS: NotationGlob\n// --------------------------------\n\n// http://www.linfo.org/wildcard.html\n// http://en.wikipedia.org/wiki/Glob_%28programming%29\n// http://en.wikipedia.org/wiki/Wildcard_character#Computing\n\nclass NotationGlob {\n\n    /**\n     *  Constructs a `Notation.Glob` object with the given glob string.\n     *  @constructor\n     *\n     *  @param {String} glob - The glob string.\n     *\n     *  @return {Notation.Glob}\n     *\n     *  @example\n     *      var glob = new Notation.Glob(\"billing.account.*\");\n     *      glob.test(\"billing.account.id\"); // true\n     */\n    constructor(glob) {\n        if (!NotationGlob.isValid(glob)) {\n            throw new NotationError('Invalid notation glob: \"' + glob + '\"');\n        }\n        this.glob = glob;\n        var ng = NotationGlob.normalize(glob);\n        this.normalized = ng.glob;\n        this.isNegated = ng.isNegated;\n        this.regexp = NotationGlob.toRegExp(this.normalized);\n        this.levels = this.normalized.split('.');\n    }\n\n    // --------------------------------\n    // NotationGlob Instance Members\n    // --------------------------------\n\n    /**\n     *  Checks whether the given notation value matches the source notation glob.\n     *\n     *  @param {String} notation - The notation string to be tested.\n     *\n     *  @return {Boolean}\n     *\n     *  @example\n     *  var glob = new Notation.Glob(\"!prop.*.name\");\n     *  glob.test(\"prop.account.name\"); // true\n     */\n    test(notation) {\n        // we allow \"*\" to match everything. We check for this here\n        // instead of the regexp bec. we care for dots (.) within the glob.\n        return this.normalized === '*'\n            || (this.normalized !== '' && notation !== '' && this.regexp.test(notation));\n    }\n\n    // --------------------------------\n    // NotationGlob Static Members\n    // --------------------------------\n\n    /**\n     *  Basically constructs a new `NotationGlob` instance\n     *  with the given glob string.\n     *\n     *  @param {String} glob - The source notation glob.\n     *\n     *  @return {NotationGlob}\n     *\n     *  @example\n     *  var glob = Notation.Glob.create(strGlob);\n     *  // equivalent to:\n     *  var glob = new Notation.Glob(strGlob);\n     */\n    static create(glob) {\n        return new NotationGlob(glob);\n    }\n\n    // Modified from http://stackoverflow.com/a/13818704/112731\n    static toRegExp(glob, opts) {\n        glob = utils.pregQuote(glob).replace(/\\\\\\*/g, '[^\\\\s\\\\.]*').replace(/\\\\\\?/g, '.');\n        return new RegExp('^' + glob, opts || '');\n        // we don't end it with a $ so the ending is open\n        // `company.*` will produce `/^company\\.[^\\s\\.]*/`\n        // which will match both `company.name` and `company.address.street`\n        // but will not match `some.company.name`\n    }\n\n    static normalize(glob) {\n        // replace multiple stars with single\n        glob = glob.replace(/\\*+/g, '*');\n        // empty glob if invalid e.g. '!' | '.abc' | '!*'\n        glob = !NotationGlob.isValid(glob) ? '' : glob;\n        var bang = glob.slice(0, 1) === '!';\n        glob = bang ? glob.slice(1) : glob;\n        return {\n            glob: glob,\n            isNegated: bang\n        };\n    }\n\n    // Created test at: https://regex101.com/r/tJ7yI9/\n    static isValid(glob) {\n        return (typeof glob === 'string') &&\n            (/^!?[^\\s\\.!]+(\\.[^\\s\\.!]+)*$/).test(glob);\n    }\n\n    // TODO: if both \"prop.id\" and \"!prop.id\" exists normalize them.\n    // since negated will win, remove the other.\n\n    /**\n     *  Compares two given notation globs and returns an integer value as a\n     *  result. This is generally used to sort glob arrays. Loose globs (with\n     *  stars especially closer to beginning of the glob string); globs\n     *  representing the parent/root of the compared property glob come first.\n     *  Verbose/detailed/exact globs come last. (`* < *abc < abc`). For\n     *  instance; `store.address` comes before `store.address.street`. So this\n     *  works both for `*, store.address.street, !store.address` and `*,\n     *  store.address, !store.address.street`. For cases such as `prop.id` vs\n     *  `!prop.id` which represent the same property; the negated glob wins\n     *  (comes last).\n     *\n     *  @param {String} a - First notation glob to be compared.\n     *  @param {String} b - Second notation glob to be compared.\n     *\n     *  @return {Number}  Returns `-1` if `a` comes first, `1` if `b` comes\n     *      first and `0` if equivalent priority.\n     *\n     *  @example\n     *  var result = Notation.Glob.compare(\"prop.*.name\", \"prop.*\");\n     *  console.log(result); // 1\n     */\n    static compare(a, b) {\n        // trivial case, both are exactly the same!\n        if (a === b) return 0;\n        var levelsA = a.split('.'),\n            levelsB = b.split('.');\n        // Check depth (number of levels)\n        if (levelsA.length === levelsB.length) {\n            // count wildcards (assuming more wildcards comes first)\n            var wild = /(?:^|\\.)\\*(?:$|\\.)/g,\n                mA = a.match(wild),\n                mB = b.match(wild),\n                wildA = mA ? mA.length : 0,\n                wildB = mB ? mB.length : 0;\n            if (wildA === wildB) {\n                // check for negation\n                var negA = a.indexOf('!') === 0,\n                    negB = b.indexOf('!') === 0;\n                if (negA === negB) {\n                    // both are negated or neither are, just return alphabetical\n                    return a < b ? -1 : 1;\n                }\n                // compare without the negatation\n                var nonNegA = negA ? a.slice(1) : a,\n                    nonNegB = negB ? b.slice(1) : b;\n                if (nonNegA === nonNegB) {\n                    return negA ? 1 : -1;\n                }\n                return nonNegA < nonNegB ? -1 : 1;\n            }\n            return wildA > wildB ? -1 : 1;\n        }\n\n        return levelsA.length < levelsB.length ? -1 : 1;\n    }\n\n    /**\n     *  Sorts the notation globs in the given array by their priorities.\n     *  Loose globs (with stars especially closer to beginning of the glob string);\n     *  globs representing the parent/root of the compared property glob come first.\n     *  Verbose/detailed/exact globs come last. (`* < *abc < abc`). For\n     *  instance; `store.address` comes before `store.address.street`. For cases\n     *  such as `prop.id` vs `!prop.id` which represent the same property; the\n     *  negated glob wins (comes last).\n     *\n     *  @param {Array} globsArray - The notation globs array to be sorted. The passed\n     *      array reference is modified.\n     *\n     *  @return {Array}\n     *\n     *  @example\n     *  var globs = [ \"!prop.*.name\", \"prop.*\", \"prop.id\" ];\n     *  Notation.Glob.sort(globs);\n     *  console.log(globs);\n     *  // [ \"prop.*\", \"prop.id\", \"!prop.*.name\" ];\n     */\n    static sort(globsArray) {\n        return globsArray.sort(NotationGlob.compare);\n        // return _mergeSortArray(globsArray, NotationGlob.compare);\n    }\n\n    /**\n     *  Gets the union from the given couple of glob arrays and returns\n     *  a new array of globs. If the exact same element is found in both\n     *  arrays, one of them is removed to prevent duplicates. If one of the\n     *  arrays contains a negated equivalent of an item in the other array,\n     *  the negated item is removed. If any item covers/matches a negated\n     *  item in the other array, the negated item is removed.\n     *\n     *  @param {Array} arrA - First array of glob strings.\n     *  @param {Array} arrB - Second array of glob strings.\n     *  @param {Boolean} sort - Whether to sort the globs in the final array.\n     *      Default: `true`\n     *\n     *  @return {Array}\n     *\n     *  @example\n     *  var a = [ 'foo.bar', 'bar.baz', '!*.qux' ],\n     *      b = [ '!foo.bar', 'bar.qux', 'bar.baz' ],\n     *  console.log(Notation.Glob.union(a, b));\n     *  // [ '!*.qux', 'foo.bar', 'bar.baz', 'bar.qux' ]\n     */\n    static union(arrA, arrB, sort) {\n        var nonegA, re, bIndex;\n        // iterate through first array\n        utils.eachRight(arrA, function (a, ia) {\n            // check if the exact item exists in the second array and remove\n            // if exists (to prevent duplicates).\n            bIndex = arrB.indexOf(a);\n            if (bIndex >= 0) arrB.splice(bIndex, 1);\n            // look for negateds and when one found; check if non-negated\n            // equivalent exists in the second array. if it exists, remove\n            // \"this negated\" from first array.\n            // e.g. [ '!foo.bar' ] + [ 'foo.bar' ] => [ 'foo.bar' ]\n            if (a.indexOf('!') === 0) {\n                nonegA = a.slice(1);\n                if (arrB.indexOf(nonegA) >= 0) {\n                    arrA.splice(ia, 1);\n                    return true;\n                }\n                // non-negated is not found in the second. so, iterate through\n                // the second array; look for non-negateds and when found,\n                // check if it covers/matches the negated from the first\n                // array. if so, remove the negated from the first array.\n                // [ '!foo.bar' ] + [ 'foo.*' ]  => [ 'foo.*' ]              // wild covers !v, remove !v\n                // [ 'foo.bar' ]  + [ '!foo.*' ] => [ '!foo.*', 'foo.bar' ]  // !wild covers v, both kept\n                // [ 'baz.que' ]  + [ '!foo.*' ] => [ '!foo.*', 'baz.que' ]  // !wild doesn't cover, both kept\n                utils.eachRight(arrB, function (b, ib) {\n                    if (b.indexOf('!') < 0) {\n                        re = NotationGlob.toRegExp(b);\n                        if (re.test(nonegA)) arrA.splice(ia, 1);\n                    }\n                });\n            } else {\n                // item in the first array is not negated; so check if a\n                // negated equivalent exists in the second and remove if\n                // exists.\n                // e.g. [ 'foo.bar' ] + [ '!foo.bar' ] => [ 'foo.bar' ]\n                bIndex = arrB.indexOf('!' + a);\n                if (bIndex >= 0) arrB.splice(bIndex, 1);\n            }\n        });\n\n        // concat both arrays and sort (if enabled) so we get a nice union\n        // array.\n        var result = arrA.concat(arrB);\n        return (sort === undefined || sort === true)\n            ? NotationGlob.sort(result)\n            : result;\n    }\n\n}\n\nexport default NotationGlob;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/notation.glob.js\n **/","\n/**\n *  Error class specific to `Notation`.\n */\nclass NotationError extends Error {\n\n    /**\n     *  Initializes a new `NotationError` instance.\n     *  @constructor\n     *\n     *  @param {String} message - The error message.\n     */\n    constructor(message = '') {\n        super(message);\n        this.name = this.constructor.name;\n\n        Object.defineProperty(this, 'name', {\n            enumerable: false,\n            writable: true,\n            value: 'NotationError'\n        });\n\n        Object.defineProperty(this, 'message', {\n            enumerable: false,\n            writable: true,\n            value: message\n        });\n\n        if (Error.hasOwnProperty('captureStackTrace')) { // V8\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            Object.defineProperty(this, 'stack', {\n                enumerable: false,\n                writable: true,\n                value: (new Error(message)).stack\n            });\n        }\n    }\n}\n\nexport default NotationError;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/core/notation.error.js\n **/"],"sourceRoot":""}